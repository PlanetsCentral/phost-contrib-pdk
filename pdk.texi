\input texinfo  @c-*-texinfo-*-
@c %**start of header
@c HINT: process this with `makeinfo --no-split' to produce a single
@c file `pdk.inf' which can be read using an info browser of your choice.
@setfilename pdk.inf
@settitle Portable Host Development Kit API
@finalout
@c %**end of header

@titlepage
@title THE PDK API
@subtitle THE PORTABLE HOST DEVELOPMENT KIT
@subtitle Application Programming Interface Reference
@subtitle PDK Library Version 4.5
@author TexInfo version
@author Version 2006-Jul-15
@author Andrew Sterian
@author Piotr Winiarczyk
@author Stefan Reuther
@end titlepage

@node Top, Manifest Constants, (dir), (dir)
@center THE PORTABLE HOST DEVELOPMENT KIT
@center Application Programming Interface Reference
@center Version 4.5

This document outlines the usage of the PDK for writing programs. A good
understanding of the ANSI C language is assumed. The entire API is declared
in the include file PHOSTPDK.H. When reading through the following
documentation, the contents of the PHOSTPDK.H file should be inspected for
clarification.

This document is meant mainly as a reference guide, not as a tutorial on
how to use the PDK. The best way to learn about PDK programming is to study
the example source files that come with the PDK.

This file is divided into several sections. The function call interface
section is further subdivided into logical functional groups. The sections
in this file are as follows:

@menu
* Manifest Constants::
* Common Types::
* Data Structures::
* Global Variables::
* Function Call Interface::
* Variables Index::
* Functions Index::
@end menu

@iftex
@itemize @minus
@item Manifest Constants
@item Common Types
@item Data Structures
@item Global Variables
@item Function Call Interface
@item Variables Index
@item Functions Index
@end itemize
@end iftex

@node Manifest Constants, Common Types, Top, Top
@chapter Manifest Constants
@vindex RACE_NR
@vindex SHIP_NR
@vindex PLANET_NR
@vindex BASE_NR
@vindex MINE_NR
@vindex HULL_NR
@vindex ENGINE_NR
@vindex BEAM_NR
@vindex TORP_NR
@vindex LONGNAME_SIZE
@vindex SHORTNAME_SIZE
@vindex ADJECTIVE_SIZE
@vindex PLANETNAME_SIZE
@vindex RACEHULLS
@vindex MAX_SPEED
@vindex MAX_BEAMS
@vindex MAX_TUBES
@vindex MAX_BAYS
@vindex MAX_PLANET_BAYS
@vindex MAX_BASE_DEFENSE
@vindex MAX_BASE_FIGHTERS
@vindex MAX_TECH
@vindex MAX_DENSITY
@vindex MAX_HAPPY
@vindex MIN_HAPPY
@vindex MAX_COORDINATE
@vindex MIN_COORDINATE
@vindex MAX_SHIP_CREDITS
@vindex MAX_WORMHOLES
@vindex MAX_MINES
@vindex MAX_FACTORIES
@vindex MAX_DEFENSE
@vindex MAX_POPULATION
@vindex MAX_TAX
@vindex MAX_TEMP

The file PHOSTPDK.H defines some constants that may be useful in writing
your program. The constants are used in the PDK itself so using these
constants ensures that your program will be compatible with the PDK through
all revisions.

@multitable @columnfractions .27 .73
@item Constant @tab Description
@item RACE_NR  @tab The number of races in the game (11)
@item SHIP_NR  @tab The maximum number of ships in the game (999)
@item PLANET_NR  @tab The maximum number of planets in the game (500)
@item BASE_NR  @tab The maximum number of bases in the game (500)
@item MINE_NR  @tab The maximum number of minefields in the game (10000)
@item HULL_NR  @tab The number of different hull types in the game (105)
@item ENGINE_NR  @tab The number of different engine types in the game (9)
@item BEAM_NR  @tab The number of different beam types in the game (10)
@item TORP_NR  @tab The number of different torpedo/tube types in the game (10)
@end multitable

@multitable @columnfractions .27 .73
@item Constant        @tab Description
@item LONGNAME_SIZE   @tab The maximum length of a race's full name (30 characters)
@item SHORTNAME_SIZE  @tab The maximum length of a race's short name (20 characters)
@item ADJECTIVE_SIZE  @tab The maximum length of a race's adjective (12 characters)
@item PLANETNAME_SIZE @tab The maximum length of a planet's name (20 characters)
@end multitable

@multitable @columnfractions .28 .72
@item Constant  @tab Description
@item RACEHULLS  @tab The number of hulls a race can build at a base (20)
@item MAX_SPEED  @tab The maximum warp speed on ships (9)
@item MAX_BEAMS  @tab The maximum number of beams on a ship (20)
@item MAX_TUBES  @tab The maximum number of tubes on a ship (20)
@item MAX_BAYS   @tab The maximum number of fighter bays on a ship (20)
@item MAX_PLANET_BAYS @tab The maximum number of bays a planet gets in combat (50)
@item MAX_BASE_DEFENSE @tab The maximum number of defense posts on a base (200)
@item MAX_BASE_FIGHTERS @tab The maximum number of fighters on a starbase (60)
@item MAX_TECH  @tab The maximum tech level in any tech (10)
@item MAX_DENSITY @tab The maximum mineral density in a planet (100)
@item MAX_HAPPY  @tab The maximum happiness of colonists and natives (100)
@item MIN_HAPPY  @tab The minimum happiness of colonists and natives (-300)
@item MAX_COORDINATE @tab The maximum X or Y co-ordinate value of objects (10000)
@item MIN_COORDINATE @tab The minimum X or Y co-ordinate value of objects (0)
@item MAX_SHIP_CREDITS @tab The maximum number of credits on a ship (10000)
@item MAX_WORMHOLES @tab The maximum number of supported wormholes (100)
@item MAX_MINES  @tab The maximum number of mines on a planet (700)
@item MAX_FACTORIES @tab The maximum number of factories on a planet (600)
@item MAX_DEFENSE @tab The maximum number of defense posts on a planet (550)
@item MAX_POPULATION @tab The maximum number of colonists/natives on a planet (25E6)
@item MAX_TAX  @tab The maximum tax rate on a planet (100)
@item MAX_TEMP  @tab The maximum temperature on a planet (100)
@end multitable

@node Common Types, Data Structures, Manifest Constants, Top
@chapter Common Types
@vindex Int16
@vindex Uns16
@vindex Int32
@vindex Uns32
@vindex Boolean
@vindex RandType_Def
@vindex CargoType_Def
@vindex RaceType_Def
@vindex NativeType_Def
@vindex NativeGovm_Def
@vindex ShipMission_Def
@vindex BaseMission_Def
@vindex BaseFixMission_Def
@vindex BaseTech_Def
@vindex BuildOrder_Struct
@vindex BaseOrder_Struct
@vindex AllianceLevel_Def
@vindex AllianceState_Def
@vindex FileLocation_Def
@vindex CombatResult_Def
@vindex Language_Def
@vindex UtilMode_Def
@vindex DOSCVT_Def
@vindex ShipsType_Def
@vindex PointsType_Def
@vindex PlayerKillType_Def

The following typedefs are used throughout the PDK code as both function
parameters and return values. For compatibility and portability to multiple
platforms, the use of the following types in code that interfaces to the
PDK is encouraged.

@multitable @columnfractions .27 .73
@item Int16 @tab a 16-bit signed integer
@item Uns16 @tab a 16-bit unsigned integer
@item Int32 @tab a 32-bit signed integer
@item Uns32 @tab a 32-bit unsigned integer
@item Boolean @tab an enumerated type with the values False (0) and True (1)
@item RandType_Def @tab the return type of the PDK's random number functions
(equivalent to Uns16)
@item CargoType_Def @tab an enumerated type listing the possible types of cargo
@item RaceType_Def @tab an enumerated type listing the different races
@item NativeType_Def @tab an enumerated type listing the different native types
@item NativeGovm_Def @tab an enumerated type listing the different native
government types
@item ShipMission_Def @tab an enumerated type listing the various ship missions
@item BaseMission_Def @tab an enumerated type listing the various base missions
@item BaseFixMission_Def @tab an enumerated type indicating whether the base
is performing a fix or a recycle mission
@item BaseTech_Def @tab an enumerated type listing the 4 types of base tech
@item BuildOrder_Struct @tab a structure containing the components of a base
build order
@item BaseOrder_Struct @tab a structure containing the components of an entry
in PHOST's build queue
@item AllianceLevel_Def @tab an enumerated type listing the various levels of
alliance supported by PHOST
@item AllianceState_Def @tab an enumerated type listing the 3 possible states
for each level of alliance (on, off, conditional)
@item FileLocation_Def @tab an enumerated type listing various options for
the file management functions
@item CombatResult_Def @tab an enumerated type describing the various
outcomes of a battle
@item Language_Def @tab an enumerated type listing the various languages
supported by PHOST
@item UtilMode_Def @tab an enumerated type listing UTIL.DAT access modes
(see "UTILx.DAT functions")
@item DOSCVT_Def @tab an enumerated type listing data types the PDK
can read/write in DOS format (see "Cross-Platform Portability Part II")
@item ShipsType_Def @tab an enumerated type listing ships types in terms
of being war ship or freighter
@item PointsType_Def @tab an enumerated type listing points type
@item PlayerKillType_Def @tab an enumerated type listing player kill switches types
@end multitable

@node Data Structures, Global Variables, Common Types, Top
@chapter Data Structures

The only data structures defined by the PDK are Pconfig_Struct which
contains all of the host configuration information and UFO_Struct which
defines an entry in the UFO.HST file. Note that the Pconfig_Struct
structure is NOT backwards compatible with PHOST v2.x and HOST since it has
several "array-ized" config options. These are options that were previously
identical for all players but have now been made per-player-configurable in
PHOST 3. For example, gPconfigInfo->TerraformRate is now an array of 12
elements (the 0th element is ignored, the rest are indexed by player number
from 1 to 11).

Note that some members of this structure are arrays. For arrays that are
indexed by player, element 0 of these arrays is ignored.

Note that all "array-ized" config options (and ones that were
per-player-configurable in previous versions) are indexed by PLAYER number,
not RACE number. For games in which PlayerRace is nonstandard, this is a
significant distinction. It allows two players to play the same race yet
have different configuration options, if so desired.

PDK 4.2 can read HCONFIG.HST files and set up the configuration information
accordingly. However, keep in mind that HOST is different from PHOST
at several places, even with "identical" configuration.

@node Global Variables, Function Call Interface, Data Structures, Top
@chapter Global Variables

The PDK defines and uses the following global variables.

@menu
* gRootDirectory::
* gGameDirectory::
* gLogFile::
* gNewlyMastered::
* gPconfigInfo::
* poptarg::
* gNonPHOSTWarnings::
* gUsingTHost::
@end menu

@iftex
@itemize @minus
@item gRootDirectory
@item gGameDirectory
@item gLogFile
@item gNewlyMastered
@item gPconfigInfo
@item poptarg
@item gNonPHOSTWarnings
@item gUsingTHost
@end itemize
@end iftex

@node gRootDirectory, gGameDirectory, Global Variables, Global Variables
@subsection const char *gRootDirectory
@vindex gRootDirectory

This variable indicates the root (main) directory in which global data
files (such as PLANET.NM, HULLSPEC.DAT) usually reside. By default, this
variable points to "." indicating that the current directory is to be used
as the root directory. The PDK file input/output functions use this
variable in searching for global data files.

This variable can be reassigned to point to another string, but note that
the variable does not point to writable storage. Look at the example source
files for models of how to use this variable.

@node gGameDirectory, gLogFile, gRootDirectory, Global Variables
@subsection const char *gGameDirectory
@vindex gGameDirectory

This variable indicates the game directory in which game-specific files
(such as PLANET.@:HST, PCONFIG.@:SRC) are expected to reside. By default, this
variable points to "." indicating that the current directory is to be used
as the game directory. The PDK file input/output functions use this
variable in searching for game data files.

This variable can be reassigned to point to another string, but note that
the variable does not point to writable storage. Look at the example source
files for models of how to use this variable.

@node gLogFile, gNewlyMastered, gGameDirectory, Global Variables
@subsection FILE *gLogFile
@vindex gLogFile

This variable indicates a file that is to store logging information
generated during program execution. If this variable is NULL (0, the
default value) then no file logging is performed. The Error(), Info(), etc.
functions write to this file pointer if it is non-zero.

@node gNewlyMastered, gPconfigInfo, gLogFile, Global Variables
@subsection Boolean gNewlyMastered
@vindex gNewlyMastered

This variable is False by default but is set to True by the ReadHostData()
routine when a newly-mastered game is encountered (that is, the
NEXTTURN.HST file is of 0 length).

@node gPconfigInfo, poptarg, gNewlyMastered, Global Variables
@subsection Pconfig_Struct *gPconfigInfo
@vindex gPconfigInfo

This variable points to the data contained in the game configuration file,
PCONFIG.SRC. By default, this variable is NULL (0). This pointer points to
modifiable data but the PDK does not save any modifications to the
PCONFIG.SRC file. Changing the PCONFIG.SRC file (if desired) is up to the
application.

@node poptarg, gNonPHOSTWarnings, gPconfigInfo, Global Variables
@subsection char *poptarg
@subheading int   poptind
@vindex poptarg
@vindex poptind

These variables are used by the command-line option processing function
pgetopt(). Please see the description of pgetopt() below for usage
information on these global variables.

@node gNonPHOSTWarnings, gUsingTHost, poptarg, Global Variables
@subsection Boolean gNonPHOSTWarnings
@vindex gNonPHOSTWarnings

This variable should be set to True if the PDK is to display warnings about
a game not being hosted by PHOST (for example, when the AUXDATA.HST file is
not found). If a program that uses the PDK works differently for PHOST
games then it is best to set this variable to True, to let the host know
that behavior may not be as expected. If a program works just as well for
HOST games as for PHOST games then it is better to set this variable to
False in order to not generate warning messages that are irrelevant.

@node gUsingTHost,  , gNonPHOSTWarnings, Global Variables
@subsection  Boolean gUsingTHost
@vindex gUsingTHost

This variable is set to True by ReadHostData() if the game configuration
was imported from HCONFIG.HST, not PCONFIG.SRC. Actually, it's
Read_THost_HConfig_File() which sets this variable.

@node Function Call Interface, Variables Index, Global Variables, Top
@chapter Function Call Interface

The heart of the PDK API is the function call interface. Function calls are
described here according to logical groupings. The best method of
discerning how these functions are to be used together is to study the
example source code files that are provided with the PDK distribution.

Note: of the friendly code-related functions, some are available both as
@code{FooFC} and @code{FooFCode}. Traditionally, the PDK has used both
endings inconsistently; the "canonical" name now is the one ending with
@code{FCode}.

@menu
* PDK Initialization and Cleanup::
* Data File Input/Output::
* Data File Mastering::
* Player Status::
* Ship Accessors::
* Planet Accessors::
* Starbase Accessors::
* Minefield Accessors::
* Wormhole Accessors::
* Hull Accessors::
* Engine Accessors::
* Torpedo Accessors::
* Beam Weapon Accessors::
* Race Name Accessors::
* Host Run Time Accessors::
* Enumeration Functions::
* External Message Interface::
* AUXHOST Message Interface::
* RST Message Interface::
* Build Queue Interface::
* Player Activity Level::
* Alliance Management::
* Game Status Interface::
* File Utility Functions::
* Memory Management::
* Messaging and Logging::
* Random Number Generation::
* Cross-Platform Portability::
* Cross-Platform Portability Part II::
* Command-Line Option Processing::
* Combat Interface::
* Remote Control Interface::
* Config File Reader Interface::
* Special Ship Function Accessors::
* Wraparound Map Functions::
* UTILx.DAT Functions::
* Score Functions::
* FCode Functions::
* Command Message Functions::
* Auxiliary Data & Experience::
* Tons::
@end menu


@node PDK Initialization and Cleanup, Data File Input/Output, Function Call Interface, Function Call Interface
@section PDK Initialization and Cleanup
@menu
* InitPHOSTLib::
* FreePHOSTLib::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item InitPHOSTLib
@item FreePHOSTLib
@end itemize
@end iftex

@node InitPHOSTLib, FreePHOSTLib, PDK Initialization and Cleanup, PDK Initialization and Cleanup
@subsection void InitPHOSTLib(void)
@findex InitPHOSTLib

This function must be called before any other PDK function is invoked.
Memory is allocated for some necessary data structures and some global
variables are initialized. This function should only be called once in any
program, or once after every call to FreePHOSTLib().

@node FreePHOSTLib,  , InitPHOSTLib, PDK Initialization and Cleanup
@subsection void FreePHOSTLib(void)
@findex FreePHOSTLib

This function should be called before the program exits. It ensures orderly
deallocation of memory and other resources that were created in
InitPHOSTLib(). After calling this function, it is possible to call
InitPHOSTLib() again, which should also (eventually) be followed by another
call to FreePHOSTLib().

@node Data File Input/Output, Data File Mastering, PDK Initialization and Cleanup, Function Call Interface
@section Data File Input/Output

All of these functions return True if successful, or False if unsuccessful.
Note that the Read_XXX_File() routines from version 2 of the PDK have been
removed as they caused too much confusion when dependencies arose between
the data files.

NOTE: These routines should not be called multiple times in one program
without first calling FreePHOSTLib(). For example, the following usage is
incorrect:

@example
            InitPHOSTLib();
              /* ... */
            ReadGlobalData();
              /* ... */             /* THIS IS WRONG!!! */
            ReadGlobalData();
              /* ... */
            FreePHOSTLib();
@end example

Calling FreePHOSTLib() prior to re-reading the data solves the problem:

@example
            InitPHOSTLib();
              /* ... */
            ReadGlobalData();
              /* ... */             /* This is RIGHT */
            FreePHOSTLib();
            InitPHOSTLib();
            ReadGlobalData();
              /* ... */
            FreePHOSTLib();
@end example

@menu
* ReadGlobalData::
* ReadHostData::
* IsCLOAKCFound::
* Write_Planets_File::
* Write_Ships_File::
* Write_Bases_File::
* Write_Mines_File::
* Write_HostGen_File::
* Write_AuxData_File::
* Write_Racenames_File::
* WriteWormholeFile::
* Write_Truehull_File::
* Write_Hullspec_File::
* Write_Engspec_File::
* Write_Beamspec_File::
* Write_Torpspec_File::
* Write_Planetname_File::
* Write_Xyplan_File::
* WriteHostData::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item ReadGlobalData
@item ReadHostData
@item IsCLOAKCFound
@item Write_Planets_File
@item Write_Ships_File
@item Write_Bases_File
@item Write_Mines_File
@item Write_HostGen_File
@item Write_AuxData_File
@item Write_Racenames_File
@item WriteWormholeFile
@item Write_Truehull_File
@item Write_Hullspec_File
@item Write_Engspec_File
@item Write_Beamspec_File
@item Write_Torpspec_File
@item Write_Planetname_File
@item Write_Xyplan_File
@item WriteHostData
@end itemize
@end iftex

@node ReadGlobalData, ReadHostData, Data File Input/Output, Data File Input/Output
@subsection Boolean ReadGlobalData(void)
@findex ReadGlobalData

This routine reads "static" game data. Specifically, the following files
are read:

@example
         BEAMSPEC.DAT
         TORPSPEC.DAT
         HULLSPEC.DAT
         ENGSPEC.DAT
         TRUEHULL.DAT
         XYPLAN.DAT
         RACE.NM
         PLANET.NM
@end example

The routine returns False if unsuccessful.

NOTE: ReadGlobalData() does

@example
               Read_Beamspec_File()
               Read_Torpspec_File()
               Read_Racenames_File()
               Read_Hullspec_File()
               Read_Engspec_File()
               Read_Truehull_File()
               Read_Xyplan_File()
               Read_Planetname_File()
@end example

You can call these routines, too, but that's not recommended.

@node ReadHostData, IsCLOAKCFound, ReadGlobalData, Data File Input/Output
@subsection Boolean ReadHostData(void)
@findex ReadHostData

This routine reads all "dynamic" game data. Specifically, the following
files are read:

@example
         PCONFIG.SRC
         NEXTTURN.HST
         PDATA.HST
         SHIP.HST
         BDATA.HST
         MINES.HST
         GEN.HST
         WORMHOLE.TXT
         AUXDATA.HST
         HULLFUNC.TXT
@end example

This routine returns False if unsuccessful.

NOTE: It is strongly recommended that you always call both ReadHostData()
and ReadGlobalData() (the latter first) as dependencies still remain
between accessors of dynamic data and the existence of static data.

The routine returns False if unsuccessful.

NOTE: ReadHostData() is roughly equivalent to calling

@example
               Read_HConfig_File() || Read_THost_HConfig_File()
               Read_Turntime_File()
               Read_Planets_File(&gPlanetControl)
               Read_Ships_File(&gShipControl)
               Read_Bases_File(&gBaseControl1, &gBaseControl2)
               Read_Mines_File()
               Read_HostGen_File()
               ReadWormholeFile()       (not in MS-C for DOS)
               Read_AuxData_File()
               ReadCLOAKCFile()
               ReadHullfunc()
@end example

You can call these routines, too, but that's not recommended.

@node IsCLOAKCFound, Write_Planets_File, ReadHostData, Data File Input/Output
@subsection Boolean IsCLOAKCFound(void)
@findex IsCLOAKCFound

This function returns whether CLOAKC.HST was found or not.
The CLOAKC.HST file is available in later HOST and PHOST versions,
ReadHostData() will try to read CLOAKC.HST but it will return no error
if CLOAKC.HST was not found.

@node Write_Planets_File, Write_Ships_File, IsCLOAKCFound, Data File Input/Output
@subsection Boolean Write_Planets_File(Int16 pControl)
@findex Write_Planets_File

This routine writes the PDATA.HST file to the game directory. Any changes
made to planetary data are saved to this file. If the planetary data was
not initially read using ReadHostData(), then a call to this function
has no effect (any existing PDATA.HST file is not overwritten). The
'pControl' parameter specifies the first word to write to this file.

@node Write_Ships_File, Write_Bases_File, Write_Planets_File, Data File Input/Output
@subsection Boolean Write_Ships_File(Int16 pControl)
@findex Write_Ships_File

This routine writes the SHIP.HST file to the game directory. Any changes
made to ship data are saved to this file. If the ship data was not
initially read using ReadHostData(), then a call to this function has no
effect (any existing SHIP.HST file is not overwritten).

@node Write_Bases_File, Write_Mines_File, Write_Ships_File, Data File Input/Output
@subsection Boolean Write_Bases_File(Int16 pControl1, Int16 pControl2)
@findex Write_Bases_File

This routine writes the BDATA.HST file to the game directory. Any changes
made to starbase data are saved to this file. If the starbase data was not
initially read using ReadHostData(), then a call to this function has no
effect (any existing BDATA.HST file is not overwritten). The 'pControl1'
and 'pControl2' parameters specify the first and last words to write to
this file. The 'pControl2' parameter should be the current turn number for
HOST compatibility.

@node Write_Mines_File, Write_HostGen_File, Write_Bases_File, Data File Input/Output
@subsection Boolean Write_Mines_File(void)
@findex Write_Mines_File

This routine writes the MINES.HST file to the game directory. Any changes
made to minefield data are saved to this file. If the minefield data was
not initially read using ReadHostData(), then a call to this function
has no effect (any existing MINES.HST file is not overwritten).

@node Write_HostGen_File, Write_AuxData_File, Write_Mines_File, Data File Input/Output
@subsection Boolean Write_HostGen_File(void)
@findex Write_HostGen_File

This routine writes the GEN.HST file to the game directory. Any changes
made to player active status or to player passwords are saved to this file.
If the above data was not initially read using ReadHostData(), then a
call to this function has no effect (any existing GEN.HST file is not
overwritten).

@node Write_AuxData_File, Write_Racenames_File, Write_HostGen_File, Data File Input/Output
@subsection Boolean Write_AuxData_File(void)
@findex Write_AuxData_File

This routine writes the AUXDATA.HST file to the game directory. Any changes
made to PHOST-specific data (e.g., the build queue, player alliance info,
etc.) are saved to this file. If the above data was not initially read
using ReadHostData(), then a call to this function will create a new
AUXDATA.HST file with default (mostly 0) values.

@node Write_Racenames_File, WriteWormholeFile, Write_AuxData_File, Data File Input/Output
@subsection Boolean Write_Racenames_File(void)
@findex Write_Racenames_File

This routine writes the RACE.NM file to the game directory. Any changes
made to race names are saved to this file. If the above data was not
initially read using ReadGlobalData(), then the data written out will
be all blanks (not recommended). Note that the RACE.NM file will always be
written to the game directory, even if the original file was found in the
main directory so that the master name file is never overwritten.


@node WriteWormholeFile, Write_Truehull_File, Write_Racenames_File, Data File Input/Output
@subsection Boolean WriteWormholeFile(void)
@findex WriteWormholeFile

This routine writes the WORMHOLE.TXT file to the game directory with the
current wormhole information.

@node Write_Truehull_File, Write_Hullspec_File, WriteWormholeFile, Data File Input/Output
@subsection Boolean Write_Truehull_File(void)
@findex Write_Truehull_File

This routine writes the TRUEHULL.DAT file to the root directory. Any changes
of race-assigned hulls made by calling PutTrueHull procedure are saved to this file.

@node Write_Hullspec_File, Write_Engspec_File, Write_Truehull_File, Data File Input/Output
@subsection Boolean Write_Hullspec_File(void)
@findex Write_Hullspec_File

This routine writes the HULLSPEC.DAT file to the root directory. Any changes
made to hulls specification are saved to this file.

@node Write_Engspec_File, Write_Beamspec_File, Write_Hullspec_File, Data File Input/Output
@subsection Boolean Write_Engspec_File(void)
@findex Write_Engspec_File

This routine writes the ENGSPEC.DAT file to the root directory. Any changes
made to engines specification are saved to this file.

@node Write_Beamspec_File, Write_Torpspec_File, Write_Engspec_File, Data File Input/Output
@subsection Boolean Write_Beamspec_File(void)
@findex Write_Beamspec_File

This routine writes the BEAMSPEC.DAT file to the root directory. Any changes
made to beams specification are saved to this file.

@node Write_Torpspec_File, Write_Planetname_File, Write_Beamspec_File, Data File Input/Output
@subsection Boolean Write_Torpspec_File(void)
@findex Write_Torpspec_File

This routine writes the TORPSPEC.DAT file to the root directory. Any changes
made to torpedos specification are saved to this file.

@node Write_Planetname_File, Write_Xyplan_File, Write_Torpspec_File, Data File Input/Output
@subsection Boolean Write_Planetname_File(void)
@findex Write_Planetname_File

This routine writes the PLANET.NM file to the root directory. Any changes
to planet names made by calling PutPlanetName procedure are saved to this file.

@node Write_Xyplan_File, WriteHostData, Write_Planetname_File, Data File Input/Output
@subsection Boolean Write_Xyplan_File(void)
@findex Write_Xyplan_File

This routine writes the XYPLAN.DAT file to the root directory. Any changes
to planet coordinates made by calling PutPlanetLocationX or PutPlanetLocationY
procedures are saved to this file.

@node WriteHostData,  , Write_Xyplan_File, Data File Input/Output
@subsection Boolean WriteHostData(void)
@findex WriteHostData

This routine is a short-cut way of calling all of the individual
data-writing routines. That is, calling this function is equivalent to
calling the following functions in order:

@example
               Write_Planets_File
               Write_Ships_File
               Write_Bases_File
               Write_Mines_File
               Write_AuxData_File
               Write_HostGen_File
               WriteWormholeFile    (EXCEPT in Microsoft-DOS)
@end example

Note that Write_Racenames_File() is not included.

@node Data File Mastering, Player Status, Data File Input/Output, Function Call Interface
@section Data File Mastering

These routines can be called in place of the ReadHostData() routine to
create the necessary data structures. They can also be called at any time
to re-initialize those structures with null data (i.e., clearing out all
elements from the structures). These routines support the creation of a
portable MASTER program since they allow a Write_XXX_File() routine to be
called without a corresponding call to ReadHostData().

@menu
* InitializePlanets::
* InitializeShips::
* InitializeBases::
* InitializeMines::
* InitializeHostGen::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item InitializePlanets
@item InitializeShips
@item InitializeBases
@item InitializeMines
@item InitializeHostGen
@end itemize
@end iftex

@node InitializePlanets, InitializeShips, Data File Mastering, Data File Mastering
@subsection void InitializePlanets(void)
@findex InitializePlanets

This routine clears all planet structures. Minerals, owners, colonists,
etc. are all removed and set to 0.

@node InitializeShips, InitializeBases, InitializePlanets, Data File Mastering
@subsection void InitializeShips(void)
@findex InitializeShips

This routine clears all ships. All ships are deleted.

@node InitializeBases, InitializeMines, InitializeShips, Data File Mastering
@subsection void InitializeBases(void)
@findex InitializeBases

This routine clears all bases. All bases are deleted.

@node InitializeMines, InitializeHostGen, InitializeBases, Data File Mastering
@subsection void InitializeMines(void)
@findex InitializeMines

This routine removes all mine fields.

@node InitializeHostGen,  , InitializeMines, Data File Mastering
@subsection void InitializeHostGen(void)
@findex InitializeHostGen

This routine prepares for a call to Write_HostGen_File() if there was no
call to ReadHostData(). All players are marked inactive and all player
passwords are set to NOPASSWORD.

@node Player Status, Ship Accessors, Data File Mastering, Function Call Interface
@section Player Status

Basic player status functions are defined here. Player kill functions are implemented too.
The following functions require a prior call to ReadHostData().

@menu
* PlayerIsActive::
* PutPlayerIsActive::
* PlayerPassword::
* PutPlayerPassword::
* KillPlayerConfigure::
* PutKillPlayerConfigure::
* KillPlayer::
* KillPlayerShips::
* KillPlayerPlanets::
* KillPlayerBases::
* KillPlayerMinefields::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item PlayerIsActive
@item PutPlayerIsActive
@item PlayerPassword
@item PutPlayerPassword
@item KillPlayerConfigure
@item PutKillPlayerConfigure
@item KillPlayer
@item KillPlayerShips
@item KillPlayerPlanets
@item KillPlayerBases
@item KillPlayerMinefields
@end itemize
@end iftex

@node PlayerIsActive, PutPlayerIsActive, Player Status, Player Status
@subsection Boolean PlayerIsActive(RaceType_Def pPlayer)
@findex PlayerIsActive

This function returns True if the given player is active in this game,
otherwise False is returned.

@node PutPlayerIsActive, PlayerPassword, PlayerIsActive, Player Status
@subsection void PutPlayerIsActive(RaceType_Def pPlayer, Boolean pActive)
@findex PutPlayerIsActive

This function can set or clear the active status of a player in the game.
The KILLRACE program, for example, calls this function to remove a player
from the game. The player's activity status is not saved unless a call to
Write_HostGen_File() is performed.

@node PlayerPassword, PutPlayerPassword, PutPlayerIsActive, Player Status
@subsection const char *PlayerPassword(RaceType_Def pPlayer)
@findex PlayerPassword

This function returns the password for a given player as a null-terminated
character string.

@node PutPlayerPassword, KillPlayerConfigure, PlayerPassword, Player Status
@subsection void PutPlayerPassword(RaceType_Def pPlayer, const char *pPwd)
@findex PutPlayerPassword

This function sets the password for a given player. The 'pPwd' parameter
must be a null-terminated plain-text string of no more than 10 characters.
The player's password is only saved when Write_HostGen_File() is called.

@node KillPlayerConfigure, PutKillPlayerConfigure, PutPlayerPassword, Player Status
@subsection Boolean KillPlayerConfigure(PlayerKillType_Def lKillConf)
@findex KillPlayerConfigure

This function returns kill config switch lKillConf.

@node PutKillPlayerConfigure, KillPlayer, KillPlayerConfigure, Player Status
@subsection void PutKillPlayerConfigure(PlayerKillType_Def lKillConf, Boolean lValue)
@findex PutKillPlayerConfigure

This function sets kill config switch lKillConf to value lValue.

@node KillPlayer, KillPlayerShips, PutKillPlayerConfigure, Player Status
@subsection void KillPlayer(RaceType_Def Race)
@findex KillPlayer

This functions kills a given player. All his alliances are cleared and player is
set inactive. Ships, planets, bases and minefields are erased if appropriate
kill config switch is set to True. To manipulate kill config switches see
KillPlayerConfigure and PutKillPlayerConfigure procedures.

@node KillPlayerShips, KillPlayerPlanets, KillPlayer, Player Status
@subsection void KillPlayerShips(RaceType_Def Race)
@findex KillPlayerShips

This functions kills all ships of a given player.

@node KillPlayerPlanets, KillPlayerBases, KillPlayerShips, Player Status
@subsection void KillPlayerPlanets(RaceType_Def Race)
@findex KillPlayerPlanets

This functions kills all planets of a given player. Colonists number is set to 0,
colonist happiness is set to 100, planet owner is set to NoOwner, planet FC is randomized.
If KillPlayerConfigure (KILL_Cash_Supplies) returns True all supplies and cash on planets are deleted.
If KillPlayerConfigure (KILL_Structures) returns True all mineral mines, factories and
defense posts on planets are deleted.

@node KillPlayerBases, KillPlayerMinefields, KillPlayerPlanets, Player Status
@subsection void KillPlayerBases(RaceType_Def Race)
@findex KillPlayerBases

This functions kills all bases of a given player.

@node KillPlayerMinefields,  , KillPlayerBases, Player Status
@subsection void KillPlayerMinefields(RaceType_Def Race)
@findex KillPlayerMinefields

This functions kills all minefields of a given player setting their
units number to 0.

@node Ship Accessors, Planet Accessors, Player Status, Function Call Interface
@section Ship Accessors

The following functions all assume that the SHIPS.HST file has been read
from disk using the ReadHostData() function. Your program will likely
crash if this assumption isn't met.

@menu
* IsShipExist::
* DeleteShip::
* IsShipCloaked::
* MarkShipCloaking::
* ShipCombatShieldLevel::
* SetShipCombatShieldLevel::
* ShipOwner::
* ShipSpeed::
* ShipLocationX::
* ShipLocationY::
* ShipWaypointX::
* ShipWaypointY::
* ShipRelWaypointX::
* ShipRelWaypointY::
* ShipHull::
* ShipEngine::
* ShipBeamType::
* ShipBeamNumber::
* ShipTorpType::
* ShipTubeNumber::
* ShipBays::
* ShipAmmunition::
* ShipMission::
* ShipEnemy::
* ShipTowTarget::
* ShipInterceptTarget::
* ShipDamage::
* ShipCrew::
* ShipDump::
* ShipDumpPlanet::
* ShipTransfer::
* ShipTransferShip::
* ShipName::
* ShipFC::
* ShipCargo::
* CreateShip::
* ShipTotalMass::
* ShipTravelMass::
* ShipCargoMass::
* ShipMissionName::
* PutShipCargo::
* PutShipName::
* PutShipOwner::
* PutShipFC::
* PutShipSpeed::
* PutShipWaypointX::
* PutShipWaypointY::
* PutShipRelWaypointX::
* PutShipRelWaypointY::
* PutShipLocationX::
* PutShipLocationY::
* PutShipHull::
* PutShipEngine::
* PutShipBeamType::
* PutShipBeamNumber::
* PutShipTorpType::
* PutShipTubeNumber::
* PutShipBays::
* PutShipAmmunition::
* PutShipMission::
* PutShipEnemy::
* PutShipTowTarget::
* PutShipInterceptTarget::
* PutShipDamage::
* PutShipCrew::
* PutShipDump::
* PutShipDumpPlanet::
* PutShipTransfer::
* PutShipTransferShip::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item IsShipExist
@item DeleteShip
@item IsShipCloaked
@item MarkShipCloaking
@item ShipCombatShieldLevel
@item SetShipCombatShieldLevel
@item ShipOwner
@item ShipSpeed
@item ShipLocationX
@item ShipLocationY
@item ShipWaypointX
@item ShipWaypointY
@item ShipRelWaypointX
@item ShipRelWaypointY
@item ShipHull
@item ShipEngine
@item ShipBeamType
@item ShipBeamNumber
@item ShipTorpType
@item ShipTubeNumber
@item ShipBays
@item ShipAmmunition
@item ShipMission
@item ShipEnemy
@item ShipTowTarget
@item ShipInterceptTarget
@item ShipDamage
@item ShipCrew
@item ShipDump
@item ShipDumpPlanet
@item ShipTransfer
@item ShipTransferShip
@item ShipName
@item ShipFC
@item ShipCargo
@item CreateShip
@item ShipTotalMass
@item ShipTravelMass
@item ShipCargoMass
@item ShipMissionName
@item PutShipCargo
@item PutShipName
@item PutShipOwner
@item PutShipFC
@item PutShipSpeed
@item PutShipWaypointX
@item PutShipWaypointY
@item PutShipRelWaypointX
@item PutShipRelWaypointY
@item PutShipLocationX
@item PutShipLocationY
@item PutShipHull
@item PutShipEngine
@item PutShipBeamType
@item PutShipBeamNumber
@item PutShipTorpType
@item PutShipTubeNumber
@item PutShipBays
@item PutShipAmmunition
@item PutShipMission
@item PutShipEnemy
@item PutShipTowTarget
@item PutShipInterceptTarget
@item PutShipDamage
@item PutShipCrew
@item PutShipDump
@item PutShipDumpPlanet
@item PutShipTransfer
@item PutShipTransferShip
@end itemize
@end iftex

@node IsShipExist, DeleteShip, Ship Accessors, Ship Accessors
@subsection Boolean IsShipExist(Uns16 pID)
@findex IsShipExist

This function returns True if the given parameter represents a valid ship
number (in the range 1 to SHIP_NR) and the ship is in play. All other
functions listed below assume that the ship specified by the function's
parameter is a valid ship. This function will accept a parameter that
is not a legal, active ship number.

@node DeleteShip, IsShipCloaked, IsShipExist, Ship Accessors
@subsection void DeleteShip(Uns16 pID)
@findex DeleteShip

This function removes the given ship from play.

@node IsShipCloaked, MarkShipCloaking, DeleteShip, Ship Accessors
@subsection Boolean IsShipCloaked(Uns16 pID)
@findex IsShipCloaked

This seemingly simple function is actually quite complicated. The problem
is that this function tries to return the most accurate information about a
ship's cloak status that it can find. Unfortunately, this information is
not always available. Simply checking the ship's mission is insufficient
since it may be set to 'Cloak' yet the host program has decided that the
ship's cloak has failed on this turn (due to random chance, or due to
excessive damage or lack of fuel, etc.)

The one case in which the true cloak status of the ship is known is when
PHOST version 3.2.2.11 or higher has been used to write the AUXDATA.HST
file (including all versions of PHOST 3). In this case, PHOST will write to
this file the true cloak status of the ship, and IsShipCloaked() returns
this information. Obviously, a call to ReadHostData() must be performed in
this case.

In all other cases (HOST is used, no AUXDATA file exists or this file is
not read, or the game is being hosted with PHOST 3.2.2.10 or lower) then
IsShipCloaked() simply performs the check on the ship's mission to estimate
cloak status. That is, if the ship can cloak, and the ship's mission is
Cloak or the ship is owned by the Birdman race and the ship's mission is
Super Spy, then the ship is considered to be cloaked.

@node MarkShipCloaking, ShipCombatShieldLevel, IsShipCloaked, Ship Accessors
@subsection void MarkShipCloaking(Uns16 pID, Boolean pCloaked)
@findex MarkShipCloaking

This function sets the cloak status of a ship using the CLOAKC.HST file.
Setting the cloak status True works only if the ship is capable of cloaking.
Note that the cloak status is not permanent in PHOST, the cloak status
is redetermined after all actions that affect cloaking (damage, fuel
usage etc.)

Setting the cloak status to False works different since PHOST 3.2.3.3:
If a ship was cloaked and the status is set to False, then PHOST assumes
that the ship remains uncloaked for the rest of the turn. There will be no
cloak failure message (PHOST assumes that the program that altered the cloak
status sends the appropriate messages).

@node ShipCombatShieldLevel, SetShipCombatShieldLevel, MarkShipCloaking, Ship Accessors
@subsection Uns16 ShipCombatShieldLevel(Uns16 pID)
@findex ShipCombatShieldLevel

This returns the shield value for combat from CLOAKC.HST. ShipCombatShieldLevel
will return 0 if no CLOAKC.HST was found (check IsCLOAKCFound()).
Note that ShipCombatShieldLevel returns 0 for unarmed ships.

@node SetShipCombatShieldLevel, ShipOwner, ShipCombatShieldLevel, Ship Accessors
@subsection void SetShipCombatShieldLevel(Uns16 pID, Uns16 pShields)
@findex SetShipCombatShieldLevel

This function sets the combat shield level of a ship. Since the shield
level is redetermined after all events that affect the damage of a ship
(repairs, movement, combat) it is intended to allow programs to manipulate
the shields in the auxbc phase. Note that this function will work
only with PHOST 3.2.3.3 or later (check GameFilesVersion())

@node ShipOwner, ShipSpeed, SetShipCombatShieldLevel, Ship Accessors
@subsection RaceType_Def ShipOwner(Uns16 pID)
@findex ShipOwner

This function returns the current owner of the given ship.

@node ShipSpeed, ShipLocationX, ShipOwner, Ship Accessors
@subsection Uns16 ShipSpeed(Uns16 pID)
@findex ShipSpeed

This function returns the warp speed setting of the given ship.

@node ShipLocationX, ShipLocationY, ShipSpeed, Ship Accessors
@subsection Uns16 ShipLocationX(Uns16 pID)
@findex ShipLocationX

This function returns the X component of the given ship's position.

@node ShipLocationY, ShipWaypointX, ShipLocationX, Ship Accessors
@subsection Uns16 ShipLocationY(Uns16 pID)
@findex ShipLocationY

This function returns the Y component of the given ship's position.

@node ShipWaypointX, ShipWaypointY, ShipLocationY, Ship Accessors
@subsection Uns16 ShipWaypointX(Uns16 pID)
@findex ShipWaypointX

This function returns the X component of the given ship's destination. The
returned value is an *absolute* position, not a position relative to the
ship's current location.

@node ShipWaypointY, ShipRelWaypointX, ShipWaypointX, Ship Accessors
@subsection Uns16 ShipWaypointY(Uns16 pID)
@findex ShipWaypointY

This function returns the Y component of the given ship's destination. The
returned value is an *absolute* position, not a position relative to the
ship's current location.

@node ShipRelWaypointX, ShipRelWaypointY, ShipWaypointY, Ship Accessors
@subsection Int16 ShipRelWaypointX(Uns16 pID)
@findex ShipRelWaypointX

This function returns the X displacement component of the given ship's
waypoint. The returned value is a signed *relative* displacement, relative
to the ship's current position.

@node ShipRelWaypointY, ShipHull, ShipRelWaypointX, Ship Accessors
@subsection Int16 ShipRelWaypointY(Uns16 pID)
@findex ShipRelWaypointY

This function returns the Y displacement component of the given ship's
waypoint. The returned value is a signed *relative* displacement, relative
to the ship's current position.

@node ShipHull, ShipEngine, ShipRelWaypointY, Ship Accessors
@subsection Uns16 ShipHull(Uns16 pID)
@findex ShipHull

This function returns the hull type of the given ship (in the range 1 to
HULL_NR).

@node ShipEngine, ShipBeamType, ShipHull, Ship Accessors
@subsection Uns16 ShipEngine(Uns16 pID)
@findex ShipEngine

This function returns the engine type of the given ship (in the range 1 to
ENGINE_NR).

@node ShipBeamType, ShipBeamNumber, ShipEngine, Ship Accessors
@subsection Uns16 ShipBeamType(Uns16 pID)
@findex ShipBeamType

This function returns the type of beams on the given ship (in the range 1
to BEAM_NR).

@node ShipBeamNumber, ShipTorpType, ShipBeamType, Ship Accessors
@subsection Uns16 ShipBeamNumber(Uns16 pID)
@findex ShipBeamNumber

This function returns the number of beams mounted on the given ship.

@node ShipTorpType, ShipTubeNumber, ShipBeamNumber, Ship Accessors
@subsection Uns16 ShipTorpType(Uns16 pID)
@findex ShipTorpType

This function returns the type of torpedo launchers on the given ship (in
the range 1 to TORP_NR).

@node ShipTubeNumber, ShipBays, ShipTorpType, Ship Accessors
@subsection Uns16 ShipTubeNumber(Uns16 pID)
@findex ShipTubeNumber

This function returns the number of torpedo launchers on the given ship.

@node ShipBays, ShipAmmunition, ShipTubeNumber, Ship Accessors
@subsection Uns16 ShipBays(Uns16 pID)
@findex ShipBays

This function returns the number of fighter bays on the given ship.

@node ShipAmmunition, ShipMission, ShipBays, Ship Accessors
@subsection Uns16 ShipAmmunition(Uns16 pID)
@findex ShipAmmunition

This function returns the number of torpedoes or fighters on the given
ship. If the ship has torpedo launchers, then this function returns the
number of torpedoes. If the ship has fighter bays, then this function
returns the number of fighters.

@node ShipMission, ShipEnemy, ShipAmmunition, Ship Accessors
@subsection ShipMission_Def ShipMission(Uns16 pID)
@findex ShipMission

This function returns the current ship's mission.

@node ShipEnemy, ShipTowTarget, ShipMission, Ship Accessors
@subsection RaceType_Def ShipEnemy(Uns16 pID)
@findex ShipEnemy

This function returns the primary enemy setting of the given ship.

@node ShipTowTarget, ShipInterceptTarget, ShipEnemy, Ship Accessors
@subsection Uns16 ShipTowTarget(Uns16 pID)
@findex ShipTowTarget

This function returns the ship ID number of the ship that is specified as a
tow target of the given ship. If the given ship has no tow target, this
function returns 0. Note that it is NOT guaranteed that the returned value
represents an active ship that can legally be towed. Programs should
perform error checks before using the return value.

@node ShipInterceptTarget, ShipDamage, ShipTowTarget, Ship Accessors
@subsection Uns16 ShipInterceptTarget(Uns16 pID)
@findex ShipInterceptTarget

This function returns the ship ID number of the ship that is specified as
the given ship's intercept target. If the given ship is not intercepting
another ship, then this function returns 0. Note that it is NOT guaranteed
that the returned value represents an active ship that is visible to the
given ship's owner. Programs should perform error checks before using the
return value.

@node ShipDamage, ShipCrew, ShipInterceptTarget, Ship Accessors
@subsection Uns16 ShipDamage(Uns16 pID)
@findex ShipDamage

This function returns the damage level of the given ship.

@node ShipCrew, ShipDump, ShipDamage, Ship Accessors
@subsection Uns16 ShipCrew(Uns16 pID)
@findex ShipCrew

This function returns the number of crew members on the given ship.

@node ShipDump, ShipDumpPlanet, ShipCrew, Ship Accessors
@subsection Uns16 ShipDump(Uns16 pID, CargoType_Def pType)
@findex ShipDump

This function returns the amount of the specified cargo to dump from the
given ship.

@node ShipDumpPlanet, ShipTransfer, ShipDump, Ship Accessors
@subsection Uns16 ShipDumpPlanet(Uns16 pID)
@findex ShipDumpPlanet

This function returns the planet number at which the given ship has been
set to dump cargo. If the planet number is 0, then the ship is jettisoning
cargo rather than dumping it at a planet.

@node ShipTransfer, ShipTransferShip, ShipDumpPlanet, Ship Accessors
@subsection Uns16 ShipTransfer(Uns16 pID, CargoType_Def pType)
@findex ShipTransfer

This function returns the amount of the specified cargo to transfer to
another ship. The ship to transfer to is determined by calling
ShipTransferShip().

@node ShipTransferShip, ShipName, ShipTransfer, Ship Accessors
@subsection Uns16 ShipTransferShip(Uns16 pID)
@findex ShipTransferShip

This function returns the ship ID number of the ship to which the given
ship is transferring cargo. This function returns 0 if there is no ship to
ship transfer occurring.

@node ShipName, ShipFC, ShipTransferShip, Ship Accessors
@subsection char* ShipName(Uns16 pID, char* pName)
@findex ShipName

This function returns the name of the given ship. If the 'pName' parameter
is 0, then the name is stored in a temporary area which is overwritten with
each call to this routine. Otherwise, the name is stored in the area
pointed to by 'pName', which must be at least 21 characters long. The
return value of this routine points to either 'pName' if it is non-zero or
to the temporary area containing the ship's name.

@node ShipFC, ShipCargo, ShipName, Ship Accessors
@subsection const char* ShipFC(Uns16 pID, char* pFCode)
@findex ShipFCode
@findex ShipFC

This function returns the friendly code of the given ship. If the 'pFCode'
parameter is 0, then the friendly code is stored in a temporary area which
is overwritten with each call to this routine. Otherwise, the friendly code
is stored in the area pointed to by 'pFCode', which must be at least 4
characters long. The return value of this routine points to the
null-terminated friendly code string, either in 'pFCode' or in the
temporary area.

This function is also available under the name @code{ShipFCode}.

@node ShipCargo, CreateShip, ShipFC, Ship Accessors
@subsection Uns16 ShipCargo(Uns16 pID, CargoType_Def pType)
@findex ShipCargo

This routine returns the amount of the specified cargo on the given ship.

@node CreateShip, ShipTotalMass, ShipCargo, Ship Accessors
@subsection Uns16 CreateShip(RaceType_Def pOwner)
@findex CreateShip

This function activates a new ship ID. If all ship slots are full, then
this function returns 0. Otherwise, this function returns the ship ID of a
newly-created ship (which will be the lowest number that does not represent
an active ship). The new ship has no attributes set other than its ID and
its owner, which is specified in 'pOwner'. The hull type, weapons, engines,
etc. must all be set separately.

@node ShipTotalMass, ShipTravelMass, CreateShip, Ship Accessors
@subsection Uns16 ShipTotalMass(Uns16 sID)
@findex ShipTotalMass

This routine returns total ship mass including hull, equipment, cargo,
ammunition and fuel masses.

@node ShipTravelMass, ShipCargoMass, ShipTotalMass, Ship Accessors
@subsection Uns16 ShipTravelMass(Uns16 sID)
@findex ShipTravelMass

This routine returns total ship mass and total ship mass of ship being
towed by this ship, if ship sID is towing.

@node ShipCargoMass, ShipMissionName, ShipTravelMass, Ship Accessors
@subsection Uns16 ShipCargoMass(Uns16 sID)
@findex ShipCargoMass

This routine returns given ship cargo mass, summing cargo tritanium, duranium,
molybdenum, supplies, clans and ship ammunition (torpedos or fighters).

@node ShipMissionName, PutShipCargo, ShipCargoMass, Ship Accessors
@subsection char *ShipMissionName(Uns16 sID, char *pBuffer)
@findex ShipMissionName

This routine returns given ship mission as string. If the 'pBuffer' parameter
is 0, then the name is stored in a temporary area which is overwritten with
each call to this routine. Otherwise, the name is stored in the area
pointed to by 'pBuffer', which must be at least 21 characters long. The
return value of this routine points to either 'pBuffer' if it is non-zero or
to the temporary area containing the ship's name.

@node PutShipCargo, PutShipName, ShipMissionName, Ship Accessors
@subsection void PutShipCargo(Uns16 pID, CargoType_Def pType, Uns16 pCargo)
@findex PutShipCargo

This routine sets the specified cargo on the given ship to a new amount.

@node PutShipName, PutShipOwner, PutShipCargo, Ship Accessors
@subsection void PutShipName(Uns16 pID, const char* pName)
@findex PutShipName

This routine sets the given ship's name to a new value. The 'pName'
parameter must point to a null-terminated string. Only the first 20
characters will be used.

@node PutShipOwner, PutShipFC, PutShipName, Ship Accessors
@subsection void PutShipOwner(Uns16 pID, RaceType_Def pOwner)
@findex PutShipOwner

This routine sets the given ship's owner to the specified value.

@node PutShipFC, PutShipSpeed, PutShipOwner, Ship Accessors
@subsection void PutShipFC(Uns16 pID, char* pFCode)
@findex PutShipFCode
@findex PutShipFC

This routine changes the given ship's friendly code to a new value. The
'pFCode' parameter must point to a null-terminated string. Only the first 3
characters are used.

This function is also available under the name @code{PutShipFCode}.

@node PutShipSpeed, PutShipWaypointX, PutShipFC, Ship Accessors
@subsection void PutShipSpeed(Uns16 pID, Uns16 pSpeed)
@findex PutShipSpeed

This routine changes the given ship's speed to a new value. The 'pSpeed'
parameter must be in the range 0 through 9.

@node PutShipWaypointX, PutShipWaypointY, PutShipSpeed, Ship Accessors
@subsection void PutShipWaypointX(Uns16 pID, Uns16 pWaypoint)
@findex PutShipWaypointX

This routine sets the X component of an absolute waypoint for the ship.

@node PutShipWaypointY, PutShipRelWaypointX, PutShipWaypointX, Ship Accessors
@subsection void PutShipWaypointY(Uns16 pID, Uns16 pWaypoint)
@findex PutShipWaypointY

This routine sets the Y component of an absolute waypoint for the ship.

@node PutShipRelWaypointX, PutShipRelWaypointY, PutShipWaypointY, Ship Accessors
@subsection void PutShipRelWaypointX(Uns16 pID, Int16 pRel)
@findex PutShipRelWaypointX

This routine sets the X displacement of a relative waypoint for the ship
(relative to the ship's current position).

@node PutShipRelWaypointY, PutShipLocationX, PutShipRelWaypointX, Ship Accessors
@subsection void PutShipRelWaypointY(Uns16 pID, Int16 pRel)
@findex PutShipRelWaypointY

This routine sets the Y displacement of a relative waypoint for the ship
(relative to the ship's current position).

@node PutShipLocationX, PutShipLocationY, PutShipRelWaypointY, Ship Accessors
@subsection void PutShipLocationX(Uns16 pID, Int16 pLocation)
@findex PutShipLocationX

This routine sets the X component of the ship's position.

@node PutShipLocationY, PutShipHull, PutShipLocationX, Ship Accessors
@subsection void PutShipLocationY(Uns16 pID, Int16 pLocation)
@findex PutShipLocationY

This routine sets the Y component of the ship's position.

@node PutShipHull, PutShipEngine, PutShipLocationY, Ship Accessors
@subsection void PutShipHull(Uns16 pID, Uns16 pHull)
@findex PutShipHull

This routine changes the ship's hull to the specified value (which must be
in the range 1 through HULL_NR).

@node PutShipEngine, PutShipBeamType, PutShipHull, Ship Accessors
@subsection void PutShipEngine(Uns16 pID, Uns16 pEngine)
@findex PutShipEngine

This routine sets the given ship's engine type to the specified value
(which must be in the range 1 through ENGINE_NR).

@node PutShipBeamType, PutShipBeamNumber, PutShipEngine, Ship Accessors
@subsection void PutShipBeamType(Uns16 pID, Uns16 pBeamType)
@findex PutShipBeamType

This routine sets the given ship's beam weapon type to the specified value
(which must be in the range 1 through BEAM_NR).

@node PutShipBeamNumber, PutShipTorpType, PutShipBeamType, Ship Accessors
@subsection void PutShipBeamNumber(Uns16 pID, Uns16 pBeamNumber)
@findex PutShipBeamNumber

This routine sets the given ship's number of beam weapons to the specified
value.

@node PutShipTorpType, PutShipTubeNumber, PutShipBeamNumber, Ship Accessors
@subsection void PutShipTorpType(Uns16 pID, Uns16 pTorpType)
@findex PutShipTorpType

This routine sets the given ship's torpedo launcher type to the specified
value (which must be in the range 1 through TORP_NR).

@node PutShipTubeNumber, PutShipBays, PutShipTorpType, Ship Accessors
@subsection void PutShipTubeNumber(Uns16 pID, Uns16 pTubeNumber)
@findex PutShipTubeNumber

This routine sets the given ship's number of torpedo launchers to the
specified value.

@node PutShipBays, PutShipAmmunition, PutShipTubeNumber, Ship Accessors
@subsection void PutShipBays(Uns16 pID, Uns16 pBays)
@findex PutShipBays

This routine sets the given ship's number of fighter bays to the specified
value. Note that a ship cannot have both fighter bays and torpedo
launchers.

@node PutShipAmmunition, PutShipMission, PutShipBays, Ship Accessors
@subsection void PutShipAmmunition(Uns16 pID, Uns16 pAmmunition)
@findex PutShipAmmunition

This routine sets the given ship's number of torpedoes or fighters to the
specified value. If the ship has torpedo launchers, then this function sets
the number of torpedoes. If the ship has bays, then this function sets the
number of fighters.

@node PutShipMission, PutShipEnemy, PutShipAmmunition, Ship Accessors
@subsection void PutShipMission(Uns16 pID, ShipMission_Def pMission)
@findex PutShipMission

This function sets the given ship's mission.

@node PutShipEnemy, PutShipTowTarget, PutShipMission, Ship Accessors
@subsection void PutShipEnemy(Uns16 pID, RaceType_Def pEnemy)
@findex PutShipEnemy

This function sets the given ship's primary enemy.

@node PutShipTowTarget, PutShipInterceptTarget, PutShipEnemy, Ship Accessors
@subsection void PutShipTowTarget(Uns16 pID, Uns16 pTarget)
@findex PutShipTowTarget

This function specifies the ship ID number of the ship that the given ship
is trying to tow.

@node PutShipInterceptTarget, PutShipDamage, PutShipTowTarget, Ship Accessors
@subsection void PutShipInterceptTarget(Uns16 pID, Uns16 pTarget)
@findex PutShipInterceptTarget

This function specifies the ship ID number of the ship that the given ship
is trying to intercept.

@node PutShipDamage, PutShipCrew, PutShipInterceptTarget, Ship Accessors
@subsection void PutShipDamage(Uns16 pID, Uns16 pDamage)
@findex PutShipDamage

This function sets the damage level of the given ship. The damage level
must not exceed 150.

@node PutShipCrew, PutShipDump, PutShipDamage, Ship Accessors
@subsection void PutShipCrew(Uns16 pID, Uns16 pCrew)
@findex PutShipCrew

This function sets the number of crew members on the given ship.

@node PutShipDump, PutShipDumpPlanet, PutShipCrew, Ship Accessors
@subsection void PutShipDump(Uns16 pID, CargoType_Def pType, Uns16 pCargo)
@findex PutShipDump

This function sets the amount of cargo that the given ship will dump or
jettison.

@node PutShipDumpPlanet, PutShipTransfer, PutShipDump, Ship Accessors
@subsection void PutShipDumpPlanet(Uns16 pID, Uns16 pPlanet)
@findex PutShipDumpPlanet

This function sets the planet at which the given ship will dump cargo. If
the planet number is given as 0, then the ship is jettisoning cargo rather
than dumping it to a planet.

@node PutShipTransfer, PutShipTransferShip, PutShipDumpPlanet, Ship Accessors
@subsection void PutShipTransfer(Uns16 pID, CargoType_Def pType, Uns16 pCargo)
@findex PutShipTransfer

This function sets the amount of cargo that the given ship will transfer to
another ship.

@node PutShipTransferShip,  , PutShipTransfer, Ship Accessors
@subsection void PutShipTransferShip(Uns16 pID, Uns16 pShip)
@findex PutShipTransferShip

This function sets the target ship that is to receive all cargo that the
given ship is transferring.

@node Planet Accessors, Starbase Accessors, Ship Accessors, Function Call Interface
@section Planet Accessors

The following functions all assume that the PDATA.HST and XYPLAN.DAT files
have been read from disk using the ReadHostData() and ReadGlobalData()
functions. Your program will likely crash if this assumption isn't met.

@menu
* IsPlanetExist::
* PlanetLocationX::
* PlanetLocationY::
* PlanetOwner::
* PlanetMines::
* PlanetFactories::
* PlanetDefense::
* PlanetCargo::
* PlanetCore::
* PlanetDensity::
* PlanetColTax::
* PlanetNatTax::
* PlanetColHappy::
* PlanetNatHappy::
* PlanetNatType::
* PlanetNatGovm::
* PlanetNativePopulation::
* PlanetTemp::
* PlanetBuildBase::
* PlanetHasNatives::
* PlanetNatString::
* PlanetNatGovmString::
* PlanetMaxFactories::
* PlanetMaxDefense::
* PlanetMaxMines::
* PlanetMining::
* PlanetGovTaxRate::
* NumberOfShipsHissingPlanet::
* PlanetNatHappyChange::
* PlanetColHappyChange::
* PlanetColIncome::
* PlanetNatIncome::
* PlanetSuppIncome::
* PlanetName::
* PlanetFCode::
* PlanetTempString::
* PutPlanetLocationX::
* PutPlanetLocationY::
* PutPlanetName::
* PutPlanetOwner::
* ChangePlanetOwner::
* PutPlanetFC::
* PutPlanetMines::
* PutPlanetFactories::
* PutPlanetDefense::
* PutPlanetCargo::
* PutPlanetCore::
* PutPlanetDensity::
* PutPlanetColTax::
* PutPlanetNatTax::
* PutPlanetColHappy::
* PutPlanetNatHappy::
* PutPlanetNatGovm::
* PutPlanetNativePopulation::
* PutPlanetNatType::
* PutPlanetTemp::
* PutPlanetBuildBase::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item IsPlanetExist
@item PlanetLocationX
@item PlanetLocationY
@item PlanetOwner
@item PlanetMines
@item PlanetFactories
@item PlanetDefense
@item PlanetCargo
@item PlanetCore
@item PlanetDensity
@item PlanetColTax
@item PlanetNatTax
@item PlanetColHappy
@item PlanetNatHappy
@item PlanetNatType
@item PlanetNatGovm
@item PlanetNativePopulation
@item PlanetTemp
@item PlanetBuildBase
@item PlanetHasNatives
@item PlanetNatString
@item PlanetNatGovmString
@item PlanetMaxFactories
@item PlanetMaxDefense
@item PlanetMaxMines
@item PlanetMining
@item PlanetGovTaxRate
@item NumberOfShipsHissingPlanet
@item PlanetNatHappyChange
@item PlanetColHappyChange
@item PlanetColIncome
@item PlanetNatIncome
@item PlanetSuppIncome
@item PlanetName
@item PlanetFCode
@item PlanetTempString
@item PutPlanetLocationX
@item PutPlanetLocationY
@item PutPlanetName
@item PutPlanetOwner
@item ChangePlanetOwner
@item PutPlanetFC
@item PutPlanetMines
@item PutPlanetFactories
@item PutPlanetDefense
@item PutPlanetCargo
@item PutPlanetCore
@item PutPlanetDensity
@item PutPlanetColTax
@item PutPlanetNatTax
@item PutPlanetColHappy
@item PutPlanetNatHappy
@item PutPlanetNatGovm
@item PutPlanetNativePopulation
@item PutPlanetNatType
@item PutPlanetTemp
@item PutPlanetBuildBase
@end itemize
@end iftex

@node IsPlanetExist, PlanetLocationX, Planet Accessors, Planet Accessors
@subsection Boolean IsPlanetExist(Uns16 pID)
@findex IsPlanetExist

This function returns True if the given parameter represents a valid planet
number (in the range 1 to PLANET_NR) and the planet is in play. All other
functions listed below assume that the planet specified by the function's
parameter is a valid planet. Only this function will accept a parameter
that is not a legal, active planet number.

@node PlanetLocationX, PlanetLocationY, IsPlanetExist, Planet Accessors
@subsection Uns16 PlanetLocationX(Uns16 pID)
@findex PlanetLocationX

This function returns the X component of the given planet's location.

@node PlanetLocationY, PlanetOwner, PlanetLocationX, Planet Accessors
@subsection Uns16 PlanetLocationY(Uns16 pID)
@findex PlanetLocationY

This function returns the Y component of the given planet's location.

@node PlanetOwner, PlanetMines, PlanetLocationY, Planet Accessors
@subsection RaceType_Def PlanetOwner(Uns16 pID)
@findex PlanetOwner

This function returns the current owner of the given planet. The return
value may be 'NoOwner' if the planet is unowned.

@node PlanetMines, PlanetFactories, PlanetOwner, Planet Accessors
@subsection Uns16 PlanetMines(Uns16 pID)
@findex PlanetMines

This function returns the number of mines on the given planet.

@node PlanetFactories, PlanetDefense, PlanetMines, Planet Accessors
@subsection Uns16 PlanetFactories(Uns16 pID)
@findex PlanetFactories

This function returns the number of factories on the given planet.

@node PlanetDefense, PlanetCargo, PlanetFactories, Planet Accessors
@subsection Uns16 PlanetDefense(Uns16 pID)
@findex PlanetDefense

This function returns the number of defense posts on the given planet.

@node PlanetCargo, PlanetCore, PlanetDefense, Planet Accessors
@subsection Uns32 PlanetCargo(Uns16 pID, CargoType_Def pType)
@findex PlanetCargo

This function returns the amount of cargo of the given type on the planet.
Note that if the cargo type is COLONISTS, then the true number of colonists
(not clans) is returned.

@node PlanetCore, PlanetDensity, PlanetCargo, Planet Accessors
@subsection Uns32 PlanetCore(Uns16 pID, CargoType_Def pType)
@findex PlanetCore

This function returns the amount of the specified cargo in the given
planet's core.

@node PlanetDensity, PlanetColTax, PlanetCore, Planet Accessors
@subsection Uns16 PlanetDensity(Uns16 pID, CargoType_Def pType)
@findex PlanetDensity

This function returns the mineral density of the specified mineral in the
given planet's core.

@node PlanetColTax, PlanetNatTax, PlanetDensity, Planet Accessors
@subsection Uns16 PlanetColTax(Uns16 pID)
@findex PlanetColTax

This function returns the current colonist tax rate on the given planet.
The number is interpreted as a percentage so a return value of 5 means that
the tax rate is 5%.

@node PlanetNatTax, PlanetColHappy, PlanetColTax, Planet Accessors
@subsection Uns16 PlanetNatTax(Uns16 pID)
@findex PlanetNatTax

This function returns the current native tax rate on the given planet. The
number is interpreted as a percentage so a return value of 5 means that the
tax rate is 5%.

@node PlanetColHappy, PlanetNatHappy, PlanetNatTax, Planet Accessors
@subsection Int16 PlanetColHappy(Uns16 pID)
@findex PlanetColHappy

This function returns the happiness level of colonists on the given planet.
The return value is upper-bounded by 100.

@node PlanetNatHappy, PlanetNatType, PlanetColHappy, Planet Accessors
@subsection Int16 PlanetNatHappy(Uns16 pID)
@findex PlanetNatHappy

This function returns the happiness level of natives on the given planet.
The return value is upper-bounded by 100.

@node PlanetNatType, PlanetNatGovm, PlanetNatHappy, Planet Accessors
@subsection NativeType_Def PlanetNatType(Uns16 pID)
@findex PlanetNatType

This function returns the type of natives on the given planet. If the
planet has no natives, then 'NoNatives' is returned.

@node PlanetNatGovm, PlanetNativePopulation, PlanetNatType, Planet Accessors
@subsection NativeGovm_Def PlanetNatGovm(Uns16 pID)
@findex PlanetNatGovm

This function returns the type of native government on the given planet.

@node PlanetNativePopulation, PlanetTemp, PlanetNatGovm, Planet Accessors
@subsection Uns32 PlanetNativePopulation(Uns16 pID)
@findex PlanetNativePopulation

This function returns the number of natives on the given planet. Note that
the true number of natives, not clans, is returned.

@node PlanetTemp, PlanetBuildBase, PlanetNativePopulation, Planet Accessors
@subsection Uns16 PlanetTemp(Uns16 pID)
@findex PlanetTemp

This function returns the given planet's temperature in the range 0 through
100.

@node PlanetBuildBase, PlanetHasNatives, PlanetTemp, Planet Accessors
@subsection Boolean PlanetBuildBase(Uns16 pID)
@findex PlanetBuildBase

This function returns True if the given planet is constructing a starbase
on this turn.

@node PlanetHasNatives, PlanetNatString, PlanetBuildBase, Planet Accessors
@subsection Boolean PlanetHasNatives(Uns16 pPlanet)
@findex PlanetHasNatives

This function returns True if the given planet has natives. This function
is just a short-cut for checking both PlanetNativePopulation() and
PlanetNatType().

@node PlanetNatString, PlanetNatGovmString, PlanetHasNatives, Planet Accessors
@subsection char *PlanetNatString(Uns16 pID, char *pBuffer)
@findex PlanetNatString

This function returns given planet natives name as string. If the 'pName' parameter
is 0, then the name is stored in a temporary area which is overwritten with
each call to this routine. Otherwise, the name is stored in the area
pointed to by 'pName', which must be at least 21 characters long. The
return value of this routine points to either 'pName' if it is non-zero or
to the temporary area containing the ship's name.

@node PlanetNatGovmString, PlanetMaxFactories, PlanetNatString, Planet Accessors
@subsection char *PlanetNatGovmString(int pID, char *pBuffer)
@findex PlanetNatGovmString

This function returns given planet natives government type name as string.
If the 'pName' parameter is 0, then the name is stored in a temporary
area which is overwritten with each call to this routine. Otherwise,
the name is stored in the area pointed to by 'pName', which must be at
least 21 characters long. The return value of this routine points to either
'pName' if it is non-zero or to the temporary area containing the ship's name.

@node PlanetMaxFactories, PlanetMaxDefense, PlanetNatGovmString, Planet Accessors
@subsection Uns16 PlanetMaxFactories(Uns16 pID)
@findex PlanetMaxFactories

This function returns given planet maximal number of factories allowed
to build due to colonist population.

@node PlanetMaxDefense, PlanetMaxMines, PlanetMaxFactories, Planet Accessors
@subsection Uns16 PlanetMaxDefense(Uns16 pID)
@findex PlanetMaxDefense

This function returns given planet maximal number of defense outposts
allowed to build due to colonist population.

@node PlanetMaxMines, PlanetMining, PlanetMaxDefense, Planet Accessors
@subsection Uns16 PlanetMaxMines(Uns16 pID)
@findex PlanetMaxMines

This function returns given planet maximal number of mineral mines allowed
to build due to colonist population.

@node PlanetMining, PlanetGovTaxRate, PlanetMaxMines, Planet Accessors
@subsection Uns16 PlanetMining(Uns16 pID, Uns16 Mineral)
@findex PlanetMining

This function returns given planet mining production of given material
from mineral mines.

@node PlanetGovTaxRate, NumberOfShipsHissingPlanet, PlanetMining, Planet Accessors
@subsection Uns16 PlanetGovTaxRate(Uns16 pID)
@findex PlanetGovTaxRate

This function returns given planet natives tax modificator due to natives
government type. If Anarchy type native government is present on planet this
function will return 20, for participatory government this will be 160.

@node NumberOfShipsHissingPlanet, PlanetNatHappyChange, PlanetGovTaxRate, Planet Accessors
@subsection Uns16 NumberOfShipsHissingPlanet(Uns16 pID)
@findex NumberOfShipsHissingPlanet

This function returns number of ships hissing given planet. Ship owner should be
Gorn, ship mission must be set to Hiss, ship must have fuel and beams to be counted.

@node PlanetNatHappyChange, PlanetColHappyChange, NumberOfShipsHissingPlanet, Planet Accessors
@subsection int PlanetNatHappyChange(Uns16 pID)
@findex PlanetNatHappyChange

This function returns given planet natives happiness change next turn due
to taxes. Ships doing Hiss mission are NOT included.

@node PlanetColHappyChange, PlanetColIncome, PlanetNatHappyChange, Planet Accessors
@subsection int PlanetColHappyChange(Uns16 pID)
@findex PlanetColHappyChange

This function returns given planet colonist happiness change next turn due
to taxes. Ships doing Hiss mission are NOT included.

@node PlanetColIncome, PlanetNatIncome, PlanetColHappyChange, Planet Accessors
@subsection Uns16 PlanetColIncome(Uns16 pID)
@findex PlanetColIncome

This function returns given planet income from colonist.

@node PlanetNatIncome, PlanetSuppIncome, PlanetColIncome, Planet Accessors
@subsection Uns16 PlanetNatIncome(Uns16 pID)
@findex PlanetNatIncome

This function returns given planet income from natives.

@node PlanetSuppIncome, PlanetName, PlanetNatIncome, Planet Accessors
@subsection Uns16 PlanetSuppIncome(Uns16 pID)
@findex PlanetSuppIncome

This function returns given planet total supplies production including factories
and Bovinoid natives.

@node PlanetName, PlanetFCode, PlanetSuppIncome, Planet Accessors
@subsection const char *PlanetName(Uns16 pID, char *pBuffer)
@findex PlanetName

This function returns the given planet's name as a null-terminated string.
If the 'pBuffer' parameter is 0, then the planet's name is stored in a
temporary location that is overwritten with each call to this routine.
Otherwise, the planet's name is stored in 'pBuffer', which must point to an
area that is at least PLANETNAME_SIZE+1 characters in length.

@node PlanetFCode, PlanetTempString, PlanetName, Planet Accessors
@subsection const char* PlanetFCode(Uns16 pID, char* pFCode)
@findex PlanetFCode

This function returns the given planet's friendly code as a null-terminated
string. If the 'pFCode' parameter is 0, then the planet's friendly code is
stored in a temporary location that is overwritten with each call to this
routine. Otherwise, the planet's friendly code is stored in 'pFCode' which
must point to an area that is at least 4 characters in length.

@node PlanetTempString, PutPlanetLocationX, PlanetFCode, Planet Accessors
@subsection const char *PlanetTempString(Uns16 pPlanet)
@findex PlanetTempString

This function returns a string that describes the planet's climate (e.g.,
"Arctic World", "Temperate - cool", etc.)

@node PutPlanetLocationX, PutPlanetLocationY, PlanetTempString, Planet Accessors
@subsection void PutPlanetLocationX(Uns16 pID, Uns16 pX)
@findex PutPlanetLocationX

This function sets the X component of the given planet's location.
To save changes use Write_Xyplan_File() function.

@node PutPlanetLocationY, PutPlanetName, PutPlanetLocationX, Planet Accessors
@subsection void PutPlanetLocationY(Uns16 pID, Uns16 pY)
@findex PutPlanetLocationY

This function sets the Y component of the given planet's location.
To save changes use Write_Xyplan_File() function.

@node PutPlanetName, PutPlanetOwner, PutPlanetLocationY, Planet Accessors
@subsection void PutPlanetName(Uns16 pID, char *pName)
@findex PutPlanetName

This routine sets the given planet's name to a new value. The 'pName'
parameter must point to a null-terminated string. Only the first
PLANETNAME_SIZE characters will be used. To save changes use
Write_Planetname_File() function.

@node PutPlanetOwner, ChangePlanetOwner, PutPlanetName, Planet Accessors
@subsection void PutPlanetOwner(Uns16 pID, RaceType_Def pOwner)
@findex PutPlanetOwner

This function sets the given planet's owner to the specified race. Note
that care must be exercised to take into account any starbase that may be
present at this planet. See also @xref{ChangePlanetOwner}.

@node ChangePlanetOwner, PutPlanetFC, PutPlanetOwner, Planet Accessors
@subsection void ChangePlanetOwner(Uns16 pID, RaceType_Def pOwner)
@findex ChangePlanetOwner

This function changes ownership of the specified planet to the given race.
If the planet has a starbase, that base's ownership is changed as well,
the build order is canceled and the hulls removed.

@node PutPlanetFC, PutPlanetMines, ChangePlanetOwner, Planet Accessors
@subsection void PutPlanetFC(Uns16 pID, char* pFCode)
@findex PutPlanetFC

This function sets the given planet's friendly code to the string pointed
to by 'pFCode'. This parameter must point to a null-terminated string. Only
the first 3 characters are used.

@node PutPlanetMines, PutPlanetFactories, PutPlanetFC, Planet Accessors
@subsection void PutPlanetMines(Uns16 pID, Uns16 pMines)
@findex PutPlanetMines

This function sets the number of mines on the given planet.

@node PutPlanetFactories, PutPlanetDefense, PutPlanetMines, Planet Accessors
@subsection void PutPlanetFactories(Uns16 pID, Uns16 pFactories)
@findex PutPlanetFactories

This function sets the number of factories on the given planet.

@node PutPlanetDefense, PutPlanetCargo, PutPlanetFactories, Planet Accessors
@subsection void PutPlanetDefense(Uns16 pID, Uns16 pDefense)
@findex PutPlanetDefense

This function sets the number of defense posts on the given planet.

@node PutPlanetCargo, PutPlanetCore, PutPlanetDefense, Planet Accessors
@subsection void PutPlanetCargo(Uns16 pID, CargoType_Def pType, Uns32 pAmount)
@findex PutPlanetCargo

This function sets the amount of the specified cargo on the surface of the
given planet. Note that for a cargo type of COLONISTS, the cargo amount
represents the true number of colonists, not clans. Also note, however,
that the colonist number is stored as clans, so that if the number of
colonists is not a multiple of 100, this number is divided by 100 and
truncated before being stored.

@node PutPlanetCore, PutPlanetDensity, PutPlanetCargo, Planet Accessors
@subsection void PutPlanetCore(Uns16 pID, CargoType_Def pType, Uns32 pAmount)
@findex PutPlanetCore

This routine sets the amount of a mineral in the given planet's core.

@node PutPlanetDensity, PutPlanetColTax, PutPlanetCore, Planet Accessors
@subsection void PutPlanetDensity(Uns16 pID, CargoType_Def pType, Uns16 pDensity)
@findex PutPlanetDensity

This routine sets the given planet's mineral density. The density must be
in the range 10 through 100.

@node PutPlanetColTax, PutPlanetNatTax, PutPlanetDensity, Planet Accessors
@subsection void PutPlanetColTax(Uns16 pID, Uns16 pTax)
@findex PutPlanetColTax

This routine sets the given planet's colonist tax rate. The tax rate must
be in the range 0 through 100.

@node PutPlanetNatTax, PutPlanetColHappy, PutPlanetColTax, Planet Accessors
@subsection void PutPlanetNatTax(Uns16 pID, Uns16 pTax)
@findex PutPlanetNatTax

This routine sets the given planet's native tax rate. The tax rate must be
in the range 0 through 100.

@node PutPlanetColHappy, PutPlanetNatHappy, PutPlanetNatTax, Planet Accessors
@subsection void PutPlanetColHappy(Uns16 pID, Int16 pHappy)
@findex PutPlanetColHappy

This routine sets the colonist happiness level on the given planet. The
happiness level must not exceed 100.

@node PutPlanetNatHappy, PutPlanetNatGovm, PutPlanetColHappy, Planet Accessors
@subsection void PutPlanetNatHappy(Uns16 pID, Int16 pHappy)
@findex PutPlanetNatHappy

This routine sets the native happiness level on the given planet. The
happiness level must not exceed 100.

@node PutPlanetNatGovm, PutPlanetNativePopulation, PutPlanetNatHappy, Planet Accessors
@subsection void PutPlanetNatGovm(Uns16 pID, NativeGovm_Def pGovm)
@findex PutPlanetNatGovm

This routine sets the type of native government on the given planet.

@node PutPlanetNativePopulation, PutPlanetNatType, PutPlanetNatGovm, Planet Accessors
@subsection void PutPlanetNativePopulation(Uns16 pID, Uns32 pPopulation)
@findex PutPlanetNativePopulation

This routine sets the number of natives on the given planet. Note that the
true number of natives must be specified, not the number of clans.

@node PutPlanetNatType, PutPlanetTemp, PutPlanetNativePopulation, Planet Accessors
@subsection void PutPlanetNatType(Uns16 pID, NativeType_Def pType)
@findex PutPlanetNatType

This routine sets the natives' type on the given planet.

@node PutPlanetTemp, PutPlanetBuildBase, PutPlanetNatType, Planet Accessors
@subsection void PutPlanetTemp(Uns16 pID, Uns16 pTemp)
@findex PutPlanetTemp

This routine sets the given planet's temperature. The temperature must be
in the range 0 through 100.

@node PutPlanetBuildBase,  , PutPlanetTemp, Planet Accessors
@subsection void PutPlanetBuildBase(Uns16 pID, Boolean pBuild)
@findex PutPlanetBuildBase

This routine sets or clears the flag that indicates that the given planet
wishes to build a starbase on the current turn.

@node Starbase Accessors, Minefield Accessors, Planet Accessors, Function Call Interface
@section Starbase Accessors

The following functions all assume that the BDATA.HST file has been read
from disk using the ReadHostData() function. Your program will likely
crash if this assumption isn't met.

@menu
* IsBasePresent::
* IsBaseExist::
* CreateBase::
* DeleteBase::
* BaseOwner::
* BaseDefense::
* BaseDamage::
* BaseFighters::
* BaseOrder::
* BaseFixOrder::
* BaseFixingShip::
* BaseTech::
* BaseHulls::
* BaseEngines::
* BaseBeams::
* BaseTubes::
* BaseTorps::
* BaseBuildOrder::
* BaseOrderString::
* PutBaseOwner::
* PutBaseDefense::
* PutBaseDamage::
* PutBaseFighters::
* PutBaseOrder::
* PutBaseFixOrder::
* PutBaseFixingShip::
* PutBaseTech::
* PutBaseHulls::
* PutBaseEngines::
* PutBaseBeams::
* PutBaseTubes::
* PutBaseTorps::
* PutBaseBuildOrder::
* ClearBaseBuildOrder::
* ClearBaseHulls::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item IsBasePresent
@item IsBaseExist
@item CreateBase
@item DeleteBase
@item BaseOwner
@item BaseDefense
@item BaseDamage
@item BaseFighters
@item BaseOrder
@item BaseFixOrder
@item BaseFixingShip
@item BaseTech
@item BaseHulls
@item BaseEngines
@item BaseBeams
@item BaseTubes
@item BaseTorps
@item BaseBuildOrder
@item BaseOrderString
@item PutBaseOwner
@item PutBaseDefense
@item PutBaseDamage
@item PutBaseFighters
@item PutBaseOrder
@item PutBaseFixOrder
@item PutBaseFixingShip
@item PutBaseTech
@item PutBaseHulls
@item PutBaseEngines
@item PutBaseBeams
@item PutBaseTubes
@item PutBaseTorps
@item PutBaseBuildOrder
@item ClearBaseBuildOrder
@item ClearBaseHulls
@end itemize
@end iftex

@node IsBasePresent, IsBaseExist, Starbase Accessors, Starbase Accessors
@subsection Boolean IsBasePresent(Uns16 pID)
@findex IsBasePresent

This function returns True if the given parameter represents a valid base
number (in the range 1 to PLANET_NR) and the base is physically present.
All other functions listed below (except for IsBaseExist()) assume that the
base specified by the function's parameter is a valid base. Only these two
functions will accept a parameter that is not a legal, active base number.

Note that a base may be physically present but not "active", meaning that
the corresponding planet is unowned. When a planet is owned, the
corresponding base must have the same owner, but it is possible for a base
to be owned and the corresponding planet to have no owner.


@node IsBaseExist, CreateBase, IsBasePresent, Starbase Accessors
@subsection Boolean IsBaseExist(Uns16 pID)
@findex IsBaseExist

This function is identical to IsBasePresent() except that the given base
must also be owned by the corresponding planet's owner, in addition to
being physically present. That is, the base is "active" in that it can
defend the planet, produce ships, etc.

@node CreateBase, DeleteBase, IsBaseExist, Starbase Accessors
@subsection void CreateBase(Uns16 pPlanet)
@findex CreateBase

This function creates a starbase at the corresponding planet. There must
not already be a base physically present at that planet. The base owner is
set to be the same as the planet owner and all tech levels are set to 1.
Otherwise, all values for the new base are set to 0.

@node DeleteBase, BaseOwner, CreateBase, Starbase Accessors
@subsection void DeleteBase(Uns16 pID)
@findex DeleteBase

This function physically deletes a starbase. Everything on the base (ship
components, fighters, etc.) is lost.

@node BaseOwner, BaseDefense, DeleteBase, Starbase Accessors
@subsection RaceType_Def BaseOwner(Uns16 pID)
@findex BaseOwner

This function returns a starbase's owner. This owner must match the
corresponding planet's owner when the planet is owned, otherwise it should
remain as the former owner of the planet.

@node BaseDefense, BaseDamage, BaseOwner, Starbase Accessors
@subsection Uns16 BaseDefense(Uns16 pID)
@findex BaseDefense

This routine returns the number of defense posts on the starbase.

@node BaseDamage, BaseFighters, BaseDefense, Starbase Accessors
@subsection Uns16 BaseDamage(Uns16 pID)
@findex  BaseDamage

This routine returns the damage level of the starbase in the range 0
through 100.

@node BaseFighters, BaseOrder, BaseDamage, Starbase Accessors
@subsection Uns16 BaseFighters(Uns16 pID)
@findex BaseFighters

This routine returns the number of fighters on the starbase.

@node BaseOrder, BaseFixOrder, BaseFighters, Starbase Accessors
@subsection BaseMission_Def BaseOrder(Uns16 pID)
@findex BaseOrder

This routine returns the starbase's current mission.

@node BaseFixOrder, BaseFixingShip, BaseOrder, Starbase Accessors
@subsection BaseFixMission_Def BaseFixOrder(Uns16 pID)
@findex BaseFixOrder

This routine returns an indication of whether the base is fixing or
recycling a ship.

@node BaseFixingShip, BaseTech, BaseFixOrder, Starbase Accessors
@subsection Uns16 BaseFixingShip(Uns16 pID)
@findex BaseFixingShip

This routine returns the ID number of a ship which the base is fixing or
recycling. If this routine returns 0, then there is no ship being fixed or
recycled.

@node BaseTech, BaseHulls, BaseFixingShip, Starbase Accessors
@subsection Uns16 BaseTech(Uns16 pID, BaseTech_Def pType)
@findex BaseTech

This routine returns the level (in the range 1 through 10) of the
specified tech at the base.

@node BaseHulls, BaseEngines, BaseTech, Starbase Accessors
@subsection Uns16 BaseHulls(Uns16 pID, Uns16 pHullType)
@findex BaseHulls

This routine returns the number of hulls in storage at the given base. The
'pHullType' parameter must be in the range 1 through RACEHULLS and does not
represent a true hull number, but rather an index into the list of hull
numbers (accessible via the TrueHull() function).

@node BaseEngines, BaseBeams, BaseHulls, Starbase Accessors
@subsection Uns16 BaseEngines(Uns16 pID, Uns16 pEngineType)
@findex BaseEngines

This routine returns the number of engines of the given tech (in the range
1 through ENGINE_NR) in storage at the given base.

@node BaseBeams, BaseTubes, BaseEngines, Starbase Accessors
@subsection Uns16 BaseBeams(Uns16 pID, Uns16 pBeamType)
@findex BaseBeams

This routine returns the number of beams of the given tech (in the range 1
through BEAM_NR) in storage at the given base.

@node BaseTubes, BaseTorps, BaseBeams, Starbase Accessors
@subsection Uns16 BaseTubes(Uns16 pID, Uns16 pTorpType)
@findex BaseTubes

This routine returns the number of torpedo launchers of the given tech (in
the range 1 through TORP_NR) in storage at the given base.

@node BaseTorps, BaseBuildOrder, BaseTubes, Starbase Accessors
@subsection Uns16 BaseTorps(Uns16 pID, Uns16 pTorpType)
@findex BaseTorps

This routine returns the number of torpedoes of the given tech (in the
range 1 through TORP_NR) in storage at the given base.

@node BaseBuildOrder, BaseOrderString, BaseTorps, Starbase Accessors
@subsection Boolean BaseBuildOrder(Uns16 pID, BuildOrder_Struct *pOrder)
@findex BaseBuildOrder

This routine returns True if the given base has a pending build order,
otherwise it returns False. If there is a pending build order, then the
build order is stored in the 'pOrder' structure (which must already have
been allocated).

@node BaseOrderString, PutBaseOwner, BaseBuildOrder, Starbase Accessors
@subsection char *BaseOrderString(int bID, char *pBuffer)
@findex BaseOrderString

This function returns base mission as string. If the 'pName' parameter
is 0, then the name is stored in a temporary area which is overwritten with
each call to this routine. Otherwise, the name is stored in the area
pointed to by 'pName', which must be at least 31 characters long. The
return value of this routine points to either 'pName' if it is non-zero or
to the temporary area containing the ship's name.

@node PutBaseOwner, PutBaseDefense, BaseOrderString, Starbase Accessors
@subsection void PutBaseOwner(Uns16 pID, RaceType_Def pOwner)
@findex PutBaseOwner

This routine sets the new owner of a starbase. A starbase must always be
owned (i.e., 'pOwner' cannot be 'NoOwner') and a starbase's owner must
match the owner of the corresponding planet, when the planet is owned.

@node PutBaseDefense, PutBaseDamage, PutBaseOwner, Starbase Accessors
@subsection void PutBaseDefense(Uns16 pID, Uns16 pDefense)
@findex PutBaseDefense

This routine sets the number of defense posts on the given base (which must
be in the range 0 through 200).

@node PutBaseDamage, PutBaseFighters, PutBaseDefense, Starbase Accessors
@subsection void PutBaseDamage(Uns16 pID, Uns16 pDamage)
@findex PutBaseDamage

This routine sets the damage level of the given base (in the range 0
through 99).

@node PutBaseFighters, PutBaseOrder, PutBaseDamage, Starbase Accessors
@subsection void PutBaseFighters(Uns16 pID, Uns16 pFighters)
@findex PutBaseFighters

This routine sets the number of fighters on the given base (in the range 0
through 60).

@node PutBaseOrder, PutBaseFixOrder, PutBaseFighters, Starbase Accessors
@subsection void PutBaseOrder(Uns16 pID, BaseMission_Def pOrder)
@findex PutBaseOrder

This routine sets the given base's primary mission.

@node PutBaseFixOrder, PutBaseFixingShip, PutBaseOrder, Starbase Accessors
@subsection void PutBaseFixOrder(Uns16 pID, BaseFixMission_Def pOrder)
@findex PutBaseFixOrder

This routine sets the given base's fix/recycle mission.

@node PutBaseFixingShip, PutBaseTech, PutBaseFixOrder, Starbase Accessors
@subsection void PutBaseFixingShip(Uns16 pID, Uns16 pShip)
@findex PutBaseFixingShip

This routine sets the ship ID number of the ship that is to be fixed or
recycled at the given base.

@node PutBaseTech, PutBaseHulls, PutBaseFixingShip, Starbase Accessors
@subsection void PutBaseTech(Uns16 pID, BaseTech_Def pType, Uns16 pTech)
@findex PutBaseTech

This routine sets a tech level at the given base. Tech levels must be in
the range 1 through 10.

@node PutBaseHulls, PutBaseEngines, PutBaseTech, Starbase Accessors
@subsection void PutBaseHulls(Uns16 pID, Uns16 pHullType, Uns16 pNumber)
@findex PutBaseHulls

This routine sets the number of the given hull type at the given base. The
'pHullType' parameter must be in the range 1 through RACEHULLS and does not
represent a true hull number. This parameter represents an index into the
list of true hull numbers, which is accessible via the TrueHull() function.

@node PutBaseEngines, PutBaseBeams, PutBaseHulls, Starbase Accessors
@subsection void PutBaseEngines(Uns16 pID, Uns16 pEngineType, Uns16 pNumber)
@findex PutBaseEngines

This routine sets the number of engines of the given tech (in the range 1
through ENGINE_NR) at the given base.

@node PutBaseBeams, PutBaseTubes, PutBaseEngines, Starbase Accessors
@subsection void PutBaseBeams(Uns16 pID, Uns16 pBeamType, Uns16 pNumber)
@findex PutBaseBeams

This routine sets the number of beams of the given tech (in the range 1
through BEAM_NR) at the given base.

@node PutBaseTubes, PutBaseTorps, PutBaseBeams, Starbase Accessors
@subsection void PutBaseTubes(Uns16 pID, Uns16 pTorpType, Uns16 pNumber)
@findex PutBaseTubes

This routine sets the number of torpedo launchers of the given tech (in the
range 1 through TORP_NR) at the given base.

@node PutBaseTorps, PutBaseBuildOrder, PutBaseTubes, Starbase Accessors
@subsection void PutBaseTorps(Uns16 pID, Uns16 pTorpType, Uns16 pNumber)
@findex PutBaseTorps

This routine sets the number of torpedoes of the given tech (in the range 1
through TORP_NR) at the given base.

@node PutBaseBuildOrder, ClearBaseBuildOrder, PutBaseTorps, Starbase Accessors
@subsection void PutBaseBuildOrder(Uns16 pID, BuildOrder_Struct *pOrderPtr)
@findex PutBaseBuildOrder

This routine sets the given base's build order.

@node ClearBaseBuildOrder, ClearBaseHulls, PutBaseBuildOrder, Starbase Accessors
@subsection void ClearBaseBuildOrder(Uns16 pID)
@findex ClearBaseBuildOrder

This routine clears any build order pending at the current base. Note that
this routine does not remove any build order from the build queue.

@node ClearBaseHulls,  , ClearBaseBuildOrder, Starbase Accessors
@subsection void ClearBaseHulls(Uns16 pID)
@findex ClearBaseHulls

This routine removes all hulls from storage at the given base.


@node Minefield Accessors, Wormhole Accessors, Starbase Accessors, Function Call Interface
@section Minefield Accessors

The following functions all assume that the MINES.HST file has been read
from disk using the ReadHostData() function. Your program will likely
crash if this assumption isn't met.

@menu
* GetNumMinefields::
* IsMinefieldExist::
* MinefieldRadius::
* MinefieldPositionX::
* MinefieldPositionY::
* MinefieldOwner::
* MinefieldUnits::
* IsMinefieldWeb::
* PutMinefieldUnits::
* PutMinefieldOwner::
* PutMinefieldPositionX::
* PutMinefieldPositionY::
* PutMinefieldWeb::
* CreateMinefield::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item GetNumMinefields
@item IsMinefieldExist
@item MinefieldRadius
@item MinefieldPositionX
@item MinefieldPositionY
@item MinefieldOwner
@item MinefieldUnits
@item IsMinefieldWeb
@item PutMinefieldUnits
@item PutMinefieldOwner
@item PutMinefieldPositionX
@item PutMinefieldPositionY
@item PutMinefieldWeb
@item CreateMinefield
@end itemize
@end iftex

@node GetNumMinefields, IsMinefieldExist, Minefield Accessors, Minefield Accessors
@subsection Uns16 GetNumMinefields(void)
@findex GetNumMinefields

This function returns the max number of minefields in the game. It will return
500 if the configuration file wasn't read and CPNumMinefields otherwise.


@node IsMinefieldExist, MinefieldRadius, GetNumMinefields, Minefield Accessors
@subsection Boolean IsMinefieldExist(Uns16 pID)
@findex IsMinefieldExist

This function returns True if the minefield ID is lower than CPNumMinefields
(configuration variable) and the minefield with the given ID exists (i.e., has
more than 0 units in it). The ID number must be in the range 1 through MINE_NR.

@node MinefieldRadius, MinefieldPositionX, IsMinefieldExist, Minefield Accessors
@subsection double MinefieldRadius(Uns16 pID)
@findex MinefieldRadius

This function returns the radius of the given minefield.

@node MinefieldPositionX, MinefieldPositionY, MinefieldRadius, Minefield Accessors
@subsection Uns16 MinefieldPositionX(Uns16 pID)
@findex MinefieldPositionX

This function returns the X component of the center of the given minefield.

@node MinefieldPositionY, MinefieldOwner, MinefieldPositionX, Minefield Accessors
@subsection Uns16 MinefieldPositionY(Uns16 pID)
@findex MinefieldPositionY

This function returns the Y component of the center of the given minefield.

@node MinefieldOwner, MinefieldUnits, MinefieldPositionY, Minefield Accessors
@subsection RaceType_Def MinefieldOwner(Uns16 pID)
@findex MinefieldOwner

This function returns the race that owns the given minefield.

@node MinefieldUnits, IsMinefieldWeb, MinefieldOwner, Minefield Accessors
@subsection Uns32 MinefieldUnits(Uns16 pID)
@findex MinefieldUnits

This function returns the number of units in the given minefield.

@node IsMinefieldWeb, PutMinefieldUnits, MinefieldUnits, Minefield Accessors
@subsection Boolean IsMinefieldWeb(Uns16 pID)
@findex IsMinefieldWeb

This function returns True if the given minefield is a web mine, otherwise
it returns False.

@node PutMinefieldUnits, PutMinefieldOwner, IsMinefieldWeb, Minefield Accessors
@subsection void PutMinefieldUnits(Uns16 pID, Uns32 pUnits)
@findex PutMinefieldUnits

This function sets the number of units in the given minefield. If the
number of units is set to 0, the minefield is considered to be gone.

@node PutMinefieldOwner, PutMinefieldPositionX, PutMinefieldUnits, Minefield Accessors
@subsection void PutMinefieldOwner(Uns16 pID, RaceType_Def pRace)
@findex PutMinefieldOwner

This function sets the owner of the minefield to the given race.

@node PutMinefieldPositionX, PutMinefieldPositionY, PutMinefieldOwner, Minefield Accessors
@subsection void PutMinefieldPositionX(Uns16 pID, Uns16 pX)
@findex PutMinefieldPositionX

This function sets the X component of the center of the given minefield.

@node PutMinefieldPositionY, PutMinefieldWeb, PutMinefieldPositionX, Minefield Accessors
@subsection void PutMinefieldPositionY(Uns16 pID, Uns16 pY)
@findex PutMinefieldPositionY

This function sets the Y component of the center of the given minefield.

@node PutMinefieldWeb, CreateMinefield, PutMinefieldPositionY, Minefield Accessors
@subsection void PutMinefieldWeb(Uns16 pID, Boolean pWeb)
@findex PutMinefieldWeb

This function changes minefield pID type. If pWeb is True the minefield is set to
be web minefield, otherwise the minefield set to be a normal minefield.

@node CreateMinefield,  , PutMinefieldWeb, Minefield Accessors
@subsection Uns16 CreateMinefield(Uns16 pXloc, Uns16 pYloc, RaceType_Def pRace, Uns32 pUnits, Boolean pIsWeb)
@findex CreateMinefield

This function creates a new minefield. The (X,Y) components of the
minefield's center must be given, along with the owner race, the initial
number of units in the mine, and a flag indicating whether or not the
minefield is a web mine. The return value is the ID number of the new
minefield, or 0 if all minefield slots are used up and the minefield could
not be created.

@node Wormhole Accessors, Hull Accessors, Minefield Accessors, Function Call Interface
@section Wormhole Accessors

These routines provide an interface to wormholes in PHOST. These routines
have no effect for games using HOST. These routines should not be invoked
unless ReadHostData() has been called.

@example
                     ********** NOTE **********
@end example

All of the wormhole functions are currently UNAVAILABLE in
the Microsoft distribution of the PDK for DOS. The Borland
distribution of the PDK for DOS has these functions, as do
all of the non-DOS distributions.


@menu
* NumWormholes::
* CreateWormhole::
* DeleteWormhole::
* WormholeStabilityCode::
* WormholeStartX::
* WormholeStartY::
* WormholeEndX::
* WormholeEndY::
* WormholeMass::
* WormholeInstability::
* WormholeWaypointStartX::
* WormholeWaypointStartY::
* WormholeWaypointEndX::
* WormholeWaypointEndY::
* PutWormholeStartX::
* PutWormholeStartY::
* PutWormholeEndX::
* PutWormholeEndY::
* PutWormholeMass::
* PutWormholeInstability::
* PutWormholeWaypointStartX::
* PutWormholeWaypointStartY::
* PutWormholeWaypointEndX::
* PutWormholeWaypointEndY::
@end menu


@iftex
Functions in this section:
@itemize @minus
@item NumWormholes
@item CreateWormhole
@item DeleteWormhole
@item WormholeStabilityCode
@item WormholeStartX
@item WormholeStartY
@item WormholeEndX
@item WormholeEndY
@item WormholeMass
@item WormholeInstability
@item WormholeWaypointStartX
@item WormholeWaypointStartY
@item WormholeWaypointEndX
@item WormholeWaypointEndY
@item PutWormholeStartX
@item PutWormholeStartY
@item PutWormholeEndX
@item PutWormholeEndY
@item PutWormholeMass
@item PutWormholeInstability
@item PutWormholeWaypointStartX
@item PutWormholeWaypointStartY
@item PutWormholeWaypointEndX
@item PutWormholeWaypointEndY
@end itemize
@end iftex

@node NumWormholes, CreateWormhole, Wormhole Accessors, Wormhole Accessors
@subsection Uns16 NumWormholes(void)
@findex NumWormholes

This routine returns the number of wormholes in the game.

@node CreateWormhole, DeleteWormhole, NumWormholes, Wormhole Accessors
@subsection Uns16 CreateWormhole(void)
@findex CreateWormhole

This routine creates a new wormhole. If the maximum number of wormholes are
already in use, then this routine returns 0. Otherwise, a wormhole ID
number is returned. All parameters for this wormhole are set to 0.

@node DeleteWormhole, WormholeStabilityCode, CreateWormhole, Wormhole Accessors
@subsection void DeleteWormhole(Uns16 pID)
@findex DeleteWormhole

This routine removes the wormhole with the given ID from play.

@node WormholeStabilityCode, WormholeStartX, DeleteWormhole, Wormhole Accessors
@subsection Uns16 WormholeStabilityCode(Uns16 pID)
@findex WormholeStabilityCode

This routine returns a number in the range 0 through 4 indicating the
stability of the wormhole. The mapping of instability to the stability code
is as follows:
          Instability <= 5:  code 0
          Instability <= 15: code 1
          Instability <= 30: code 2
          Instability <= 50: code 3
          Instability <= 80: code 4

@node WormholeStartX, WormholeStartY, WormholeStabilityCode, Wormhole Accessors
@subsection Uns16 WormholeStartX(Uns16 pID)
@findex WormholeStartX

This routine returns the X-position of a wormhole's starting location.

@node WormholeStartY, WormholeEndX, WormholeStartX, Wormhole Accessors
@subsection Uns16 WormholeStartY(Uns16 pID)
@findex WormholeStartY

This routine returns the Y-position of a wormhole's starting location.

@node WormholeEndX, WormholeEndY, WormholeStartY, Wormhole Accessors
@subsection Uns16 WormholeEndX(Uns16 pID)
@findex WormholeEndX

This routine returns the X-position of a wormhole's ending location.

@node WormholeEndY, WormholeMass, WormholeEndX, Wormhole Accessors
@subsection Uns16 WormholeEndY(Uns16 pID)
@findex WormholeEndY

This routine returns the Y-position of a wormhole's ending location.

@node WormholeMass, WormholeInstability, WormholeEndY, Wormhole Accessors
@subsection Int16 WormholeMass(Uns16 pID)
@findex WormholeMass

This routine returns a wormhole's mass. This quantity may be negative,
indicating that the wormhole is unidirectional (i.e., travel is possible
only from start to end). In any case, the true mass should be computed as
the absolute value of the number returned by this routine.

@node WormholeInstability, WormholeWaypointStartX, WormholeMass, Wormhole Accessors
@subsection float WormholeInstability(Uns16 pID)
@findex WormholeInstability

This routine returns the instability of the given wormhole in the range
[0,100].

@node WormholeWaypointStartX, WormholeWaypointStartY, WormholeInstability, Wormhole Accessors
@subsection Uns16 WormholeWaypointStartX(Uns16 pID)
@findex WormholeWaypointStartX

This routine returns the X-position of a wormhole starting position's
waypoint.

@node WormholeWaypointStartY, WormholeWaypointEndX, WormholeWaypointStartX, Wormhole Accessors
@subsection Uns16 WormholeWaypointStartY(Uns16 pID)
@findex WormholeWaypointStartY

This routine returns the Y-position of a wormhole starting position's
waypoint.

@node WormholeWaypointEndX, WormholeWaypointEndY, WormholeWaypointStartY, Wormhole Accessors
@subsection Uns16 WormholeWaypointEndX(Uns16 pID)
@findex WormholeWaypointEndX

This routine returns the X-position of a wormhole ending position's
waypoint.

@node WormholeWaypointEndY, PutWormholeStartX, WormholeWaypointEndX, Wormhole Accessors
@subsection Uns16 WormholeWaypointEndY(Uns16 pID)
@findex WormholeWaypointEndY

This routine returns the Y-position of a wormhole ending position's
waypoint.

@node PutWormholeStartX, PutWormholeStartY, WormholeWaypointEndY, Wormhole Accessors
@subsection void PutWormholeStartX(Uns16 pID, Uns16 pX)
@findex PutWormholeStartX

This routine changes the X-position of a wormhole's starting location.

@node PutWormholeStartY, PutWormholeEndX, PutWormholeStartX, Wormhole Accessors
@subsection void PutWormholeStartY(Uns16 pID, Uns16 pY)
@findex PutWormholeStartY

This routine changes the Y-position of a wormhole's starting location.

@node PutWormholeEndX, PutWormholeEndY, PutWormholeStartY, Wormhole Accessors
@subsection void PutWormholeEndX(Uns16 pID, Uns16 pX)
@findex PutWormholeEndX

This routine changes the X-position of a wormhole's ending location.

@node PutWormholeEndY, PutWormholeMass, PutWormholeEndX, Wormhole Accessors
@subsection void PutWormholeEndY(Uns16 pID, Uns16 pY)
@findex PutWormholeEndY

This routine changes the Y-position of a wormhole's ending location.

@node PutWormholeMass, PutWormholeInstability, PutWormholeEndY, Wormhole Accessors
@subsection void PutWormholeMass(Uns16 pID, Int16 pMass)
@findex PutWormholeMass

This routine changes a wormhole's mass. If 'pMass' is negative, then the
actual mass is the magnitude of 'pMass', and the wormhole is marked as
being unidirectional (i.e., supports travel from start to end only).

@node PutWormholeInstability, PutWormholeWaypointStartX, PutWormholeMass, Wormhole Accessors
@subsection void PutWormholeInstability(Uns16 pID, float pInstability)
@findex PutWormholeInstability

This routine changes a wormhole's instability. The instability must be in
the range [0,100].

@node PutWormholeWaypointStartX, PutWormholeWaypointStartY, PutWormholeInstability, Wormhole Accessors
@subsection void PutWormholeWaypointStartX(Uns16 pID, Uns16 pX)
@findex PutWormholeWaypointStartX

This routine sets the X-position of a wormhole's starting position
waypoint.

@node PutWormholeWaypointStartY, PutWormholeWaypointEndX, PutWormholeWaypointStartX, Wormhole Accessors
@subsection void PutWormholeWaypointStartY(Uns16 pID, Uns16 pY)
@findex PutWormholeWaypointStartY

This routine sets the Y-position of a wormhole's starting position
waypoint.

@node PutWormholeWaypointEndX, PutWormholeWaypointEndY, PutWormholeWaypointStartY, Wormhole Accessors
@subsection void PutWormholeWaypointEndX(Uns16 pID, Uns16 pX)
@findex PutWormholeWaypointEndX

This routine sets the X-position of a wormhole's ending position waypoint.

@node PutWormholeWaypointEndY,  , PutWormholeWaypointEndX, Wormhole Accessors
@subsection void PutWormholeWaypointEndY(Uns16 pID, Uns16 pY)
@findex PutWormholeWaypointEndY

This routine sets the Y-position of a wormhole's ending position waypoint.


@node Hull Accessors, Engine Accessors, Wormhole Accessors, Function Call Interface
@section Hull Accessors

These routines provide an interface to the hull data stored in the
HULLSPEC.DAT file. These routines should not be invoked unless the
ReadGlobalData() routine has been called. All hull number parameters
specified to these routines must be in the range 1 through HULL_NR.

@menu
* HullPicnumber::
* HullTritCost::
* HullDurCost::
* HullMolyCost::
* HullFuelCapacity::
* HullCrewComplement::
* HullEngineNumber::
* HullMass::
* HullTechLevel::
* HullCargoCapacity::
* HullBays::
* HullTubeNumber::
* HullBeamNumber::
* HullMoneyCost::
* TrueHull::
* HullName::
* PutHullPicnumber::
* PutHullTritCost::
* PutHullDurCost::
* PutHullMolyCost::
* PutHullFuelCapacity::
* PutHullCrewComplement::
* PutHullEngineNumber::
* PutHullMass::
* PutHullTechLevel::
* PutHullCargoCapacity::
* PutHullBays::
* PutHullTubeNumber::
* PutHullBeamNumber::
* PutHullMoneyCost::
* PutTrueHull::
* PutHullName::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item HullPicnumber
@item HullTritCost
@item HullDurCost
@item HullMolyCost
@item HullFuelCapacity
@item HullCrewComplement
@item HullEngineNumber
@item HullMass
@item HullTechLevel
@item HullCargoCapacity
@item HullBays
@item HullTubeNumber
@item HullBeamNumber
@item HullMoneyCost
@item TrueHull
@item HullName
@item PutHullPicnumber
@item PutHullTritCost
@item PutHullDurCost
@item PutHullMolyCost
@item PutHullFuelCapacity
@item PutHullCrewComplement
@item PutHullEngineNumber
@item PutHullMass
@item PutHullTechLevel
@item PutHullCargoCapacity
@item PutHullBays
@item PutHullTubeNumber
@item PutHullBeamNumber
@item PutHullMoneyCost
@item PutTrueHull
@item PutHullName
@end itemize
@end iftex

@node HullPicnumber, HullTritCost, Hull Accessors, Hull Accessors
@subsection Uns16 HullPicnumber(Uns16 pHullNr)
@findex HullPicnumber

This routine returns the bitmap number in the RESOURCE.PLN file
corresponding to the given hull number.

@node HullTritCost, HullDurCost, HullPicnumber, Hull Accessors
@subsection Uns16 HullTritCost(Uns16 pHullNr)
@findex HullTritCost

This routine returns the amount of Tritanium required to build the given
hull.

@node HullDurCost, HullMolyCost, HullTritCost, Hull Accessors
@subsection Uns16 HullDurCost(Uns16 pHullNr)
@findex HullDurCost

This routine returns the amount of Duranium required to build the given
hull.

@node HullMolyCost, HullFuelCapacity, HullDurCost, Hull Accessors
@subsection Uns16 HullMolyCost(Uns16 pHullNr)
@findex HullMolyCost

This routine returns the amount of Molybdenum required to build the given
hull.

@node HullFuelCapacity, HullCrewComplement, HullMolyCost, Hull Accessors
@subsection Uns16 HullFuelCapacity(Uns16 pHullNr)
@findex HullFuelCapacity

This routine returns the size of a given hull's fuel tank.

@node HullCrewComplement, HullEngineNumber, HullFuelCapacity, Hull Accessors
@subsection Uns16 HullCrewComplement(Uns16 pHullNr)
@findex HullCrewComplement

This routine returns the maximum number of crew members that are allowed on
a given hull type.

@node HullEngineNumber, HullMass, HullCrewComplement, Hull Accessors
@subsection Uns16 HullEngineNumber(Uns16 pHullNr)
@findex HullEngineNumber

This routine returns the number of engines required on a given hull.

@node HullMass, HullTechLevel, HullEngineNumber, Hull Accessors
@subsection Uns16 HullMass(Uns16 pHullNr)
@findex HullMass

This routine returns the mass of a given hull.

@node HullTechLevel, HullCargoCapacity, HullMass, Hull Accessors
@subsection Uns16 HullTechLevel(Uns16 pHullNr)
@findex HullTechLevel

This routine returns the tech level required to build a given hull.

@node HullCargoCapacity, HullBays, HullTechLevel, Hull Accessors
@subsection Uns16 HullCargoCapacity(Uns16 pHullNr)
@findex HullCargoCapacity

This routine returns the amount of cargo space available on a given hull.

@node HullBays, HullTubeNumber, HullCargoCapacity, Hull Accessors
@subsection Uns16 HullBays(Uns16 pHullNr)
@findex HullBays

This routine returns the number of fighter bays on a given hull.

@node HullTubeNumber, HullBeamNumber, HullBays, Hull Accessors
@subsection Uns16 HullTubeNumber(Uns16 pHullNr)
@findex HullTubeNumber

This routine returns the maximum number of torpedo tubes that can be
mounted on the given hull.

@node HullBeamNumber, HullMoneyCost, HullTubeNumber, Hull Accessors
@subsection Uns16 HullBeamNumber(Uns16 pHullNr)
@findex HullBeamNumber

This routine returns the maximum number of beam weapons that can be mounted
on the given hull.

@node HullMoneyCost, TrueHull, HullBeamNumber, Hull Accessors
@subsection Uns16 HullMoneyCost(Uns16 pHullNr)
@findex HullMoneyCost

This routine returns the number of megacredits required to build the given
hull.

@node TrueHull, HullName, HullMoneyCost, Hull Accessors
@subsection Uns16 TrueHull(RaceType_Def pRace, Uns16 pHullIndex)
@findex TrueHull

This routine maps a race-specific hull number in the range 1 through
RACEHULLS to a true hull number in the range 1 through HULL_NR. If this
routine returns 0, then the given race hull index is unused for that race.

@node HullName, PutHullPicnumber, TrueHull, Hull Accessors
@subsection const char* HullName(Uns16 pHullNr, char* pBuffer)
@findex HullName

This routine returns the name of a given hull number. If 'pBuffer' is
non-NULL, then it must point to a previously allocated area of at least 31
bytes. The hull name is then stored in this area and the routine returns
'pBuffer'. If 'pBuffer' is NULL, then the hull name is stored in a
temporary area which is overwritten with each call to this routine. The
return value is then a pointer to this temporary area.

@node PutHullPicnumber, PutHullTritCost, HullName, Hull Accessors
@subsection void PutHullPicnumber(Uns16 pHullNr, Uns16 pHullPic)
@findex PutHullPicnumber

This routine sets the bitmap number in the RESOURCE.PLN file
corresponding to the given hull number.

@node PutHullTritCost, PutHullDurCost, PutHullPicnumber, Hull Accessors
@subsection void PutHullTritCost(Uns16 pHullNr, Uns16 pTritCost)
@findex PutHullTritCost

This routine sets the amount of Tritanium required to build the given
hull to pTritCost.

@node PutHullDurCost, PutHullMolyCost, PutHullTritCost, Hull Accessors
@subsection void PutHullDurCost(Uns16 pHullNr, Uns16 pDurCost)
@findex PutHullDurCost

This routine sets the amount of Duranium required to build the given
hull to pDurCost.

@node PutHullMolyCost, PutHullFuelCapacity, PutHullDurCost, Hull Accessors
@subsection void PutHullMolyCost(Uns16 pHullNr, Uns16 pMolyCost)
@findex PutHullMolyCost

This routine sets the amount of Molybdenum required to build the given
hull to pMolyCost.

@node PutHullFuelCapacity, PutHullCrewComplement, PutHullMolyCost, Hull Accessors
@subsection void PutHullFuelCapacity(Uns16 pHullNr, Uns16 pFuelCapacity)
@findex PutHullFuelCapacity

This routine sets the size of a given hull's fuel tank to pFuelCapacity.

@node PutHullCrewComplement, PutHullEngineNumber, PutHullFuelCapacity, Hull Accessors
@subsection void PutHullCrewComplement(Uns16 pHullNr, Uns16 pCrewComplement)
@findex PutHullCrewComplement

This routine sets the maximum number of crew members that are allowed on
a given hull type.

@node PutHullEngineNumber, PutHullMass, PutHullCrewComplement, Hull Accessors
@subsection void PutHullEngineNumber(Uns16 pHullNr, Uns16 pEngineNumber)
@findex PutHullEngineNumber

This routine sets the number of engines required on a given hull to pEngineNumber.

@node PutHullMass, PutHullTechLevel, PutHullEngineNumber, Hull Accessors
@subsection void PutHullMass(Uns16 pHullNr, Uns16 pMass)
@findex PutHullMass

This routine sets the mass of a given hull to pMass.

@node PutHullTechLevel, PutHullCargoCapacity, PutHullMass, Hull Accessors
@subsection void PutHullTechLevel(Uns16 pHullNr, Uns16 pTechLevel)
@findex PutHullTechLevel

This routine sets the tech level required to build a given hull to pTechLevel.

@node PutHullCargoCapacity, PutHullBays, PutHullTechLevel, Hull Accessors
@subsection void PutHullCargoCapacity(Uns16 pHullNr, Uns16 pCargoCapacity)
@findex PutHullCargoCapacity

This routine sets the amount of cargo space available on a given hull to pCargoCapacity.

@node PutHullBays, PutHullTubeNumber, PutHullCargoCapacity, Hull Accessors
@subsection void PutHullBays(Uns16 pHullNr, Uns16 pBays)
@findex PutHullBays

This routine sets the number of fighter bays on a given hull to pBays.

@node PutHullTubeNumber, PutHullBeamNumber, PutHullBays, Hull Accessors
@subsection void PutHullTubeNumber(Uns16 pHullNr, Uns16 pTubeNumber)
@findex PutHullTubeNumber

This routine sets the maximum number of torpedo tubes that can be
mounted on the given hull to pTubeNumber.

@node PutHullBeamNumber, PutHullMoneyCost, PutHullTubeNumber, Hull Accessors
@subsection void PutHullBeamNumber(Uns16 pHullNr, Uns16 pBeamNumber)
@findex PutHullBeamNumber

This routine sets the maximum number of beam weapons that can be mounted
on the given hull to pBeamNumber.

@node PutHullMoneyCost, PutTrueHull, PutHullBeamNumber, Hull Accessors
@subsection PutHullMoneyCost(Uns16 pHullNr, Uns16 pMoneyCost)
@findex PutHullMoneyCost

This routine sets the number of megacredits required to build the given
hull to pMoneyCost.

@node PutTrueHull, PutHullName, PutHullMoneyCost, Hull Accessors
@subsection PutTrueHull(RaceType_Def pRace, Uns16 pHullIndex, Uns16 pHullNr)
@findex PutTrueHull

This routine sets a race-specific hull number pHullIndex from the range
1  through RACEHULLS to a true hull number pHullNr in the range 1 through HULL_NR.
Setting pHullNr to 0, make the given race hull index unused for that race.

@node PutHullName,  , PutTrueHull, Hull Accessors
@subsection PutHullName(Uns16 pHullNr, const char *pName)
@findex PutHullName

This routine sets the name of a given hull to pName. The 'pName'
parameter must point to a null-terminated string. Only the first 30 characters
will be used.

@node Engine Accessors, Torpedo Accessors, Hull Accessors, Function Call Interface
@section Engine Accessors

These routines provide an interface to the engine data stored in the
ENGSPEC.DAT file. These routines should not be invoked unless the
ReadGlobalData() routine has been called. All engine number parameters
specified to these routines must be in the range 1 through ENGINE_NR.

@menu
* EngineName::
* EngMoneyCost::
* EngTritCost::
* EngDurCost::
* EngMolyCost::
* EngTechLevel::
* EngFuelConsumption::
* PutEngineName::
* PutEngMoneyCost::
* PutEngTritCost::
* PutEngDurCost::
* PutEngMolyCost::
* PutEngTechLevel::
* PutEngFuelConsumption::
@end menu


@iftex
Functions in this section:
@itemize @minus
@item EngineName
@item EngMoneyCost
@item EngTritCost
@item EngDurCost
@item EngMolyCost
@item EngTechLevel
@item EngFuelConsumption
@item PutEngineName
@item PutEngMoneyCost
@item PutEngTritCost
@item PutEngDurCost
@item PutEngMolyCost
@item PutEngTechLevel
@item PutEngFuelConsumption
@end itemize
@end iftex

@node EngineName, EngMoneyCost, Engine Accessors, Engine Accessors
@subsection char* EngineName(Uns16 pEngNr, char* pBuffer)
@findex EngineName

This routine returns the name of a given engine number. If 'pBuffer' is
non-NULL, then it must point to a previously allocated area of at least 21
bytes. The engine name is then stored in this area and the routine returns
'pBuffer'. If 'pBuffer' is NULL, then the engine name is stored in a
temporary area which is overwritten with each call to this routine. The
return value is then a pointer to this temporary area.

@node EngMoneyCost, EngTritCost, EngineName, Engine Accessors
@subsection Uns16 EngMoneyCost(Uns16 pEngNr)
@findex EngMoneyCost

This routine returns the number of megacredits required to build one engine
of the given type.

@node EngTritCost, EngDurCost, EngMoneyCost, Engine Accessors
@subsection Uns16 EngTritCost(Uns16 pEngNr)
@findex EngTritCost

This routine returns the amount of Tritanium required to build an engine of
the given type.

@node EngDurCost, EngMolyCost, EngTritCost, Engine Accessors
@subsection Uns16 EngDurCost(Uns16 pEngNr)
@findex EngDurCost

This routine returns the amount of Duranium required to build an engine of
the given type.

@node EngMolyCost, EngTechLevel, EngDurCost, Engine Accessors
@subsection Uns16 EngMolyCost(Uns16 pEngNr)
@findex EngMolyCost

This routine returns the amount of Molybdenum required to build an engine
of the given type.

@node EngTechLevel, EngFuelConsumption, EngMolyCost, Engine Accessors
@subsection Uns16 EngTechLevel(Uns16 pEngNr)
@findex EngTechLevel

This routine returns the minimum tech level required to build engines of
the given type.

@node EngFuelConsumption, PutEngineName, EngTechLevel, Engine Accessors
@subsection Uns32 EngFuelConsumption(Uns16 pEngNr, Uns16 pSpeed)
@findex EngFuelConsumption

This routine returns a quantity that indicates the amount of fuel consumed
by an engine of the given type at the warp speed specified by 'pSpeed'.

@node PutEngineName, PutEngMoneyCost, EngFuelConsumption, Engine Accessors
@subsection void PutEngineName(Uns16 pEngNr, const char *pName)
@findex PutEngineName

This routine sets the name of a given engine to pName. The 'pName'
parameter must point to a null-terminated string. Only the first 20 characters
will be used.

@node PutEngMoneyCost, PutEngTritCost, PutEngineName, Engine Accessors
@subsection void PutEngMoneyCost(Uns16 pEngNr, Uns16 pMoneyCost)
@findex PutEngMoneyCost

This routine sets the number of megacredits required to build one engine
of the given type to pMoneyCost.

@node PutEngTritCost, PutEngDurCost, PutEngMoneyCost, Engine Accessors
@subsection void PutEngTritCost(Uns16 pEngNr, Uns16 pTritCost)
@findex PutEngTritCost

This routine sets the amount of Tritanium required to build an engine of
the given type.

@node PutEngDurCost, PutEngMolyCost, PutEngTritCost, Engine Accessors
@subsection void PutEngDurCost(Uns16 pEngNr, Uns16 pDurCost)
@findex PutEngDurCost

This routine sets the amount of Duranium required to build an engine of
the given type.

@node PutEngMolyCost, PutEngTechLevel, PutEngDurCost, Engine Accessors
@subsection void PutEngMolyCost(Uns16 pEngNr, Uns16 pMolyCost)
@findex PutEngMolyCost

This routine sets the amount of Molybdenum required to build an engine
of the given type.

@node PutEngTechLevel, PutEngFuelConsumption, PutEngMolyCost, Engine Accessors
@subsection void PutEngTechLevel(Uns16 pEngNr, Uns16 pTechLevel)
@findex PutEngTechLevel

This routine sets the minimum tech level required to build engines of
the given type to pTechLevel.

@node PutEngFuelConsumption,  , PutEngTechLevel, Engine Accessors
@subsection void PutEngFuelConsumption(Uns16 pEngNr, Uns16 pSpeed, Uns32 pFuelConsumption)
@findex PutEngFuelConsumption

This routine sets a quantity pFuelConsumption that indicates the amount of fuel consumed
by an engine of the given type at the warp speed specified by 'pSpeed'.


@node Torpedo Accessors, Beam Weapon Accessors, Engine Accessors, Function Call Interface
@section Torpedo Accessors

These routines provide an interface to the torpedo data stored in the
TORPSPEC.DAT file. These routines should not be invoked unless the
ReadGlobalData() routine has been called. All torpedo number parameters
specified to these routines must be in the range 1 through TORP_NR.

@menu
* TorpName::
* TorpTorpCost::
* TorpTubeCost::
* TorpTritCost::
* TorpDurCost::
* TorpMolyCost::
* TorpTubeMass::
* TorpTechLevel::
* TorpKillPower::
* TorpDestructivePower::
* PutTorpName::
* PutTorpTorpCost::
* PutTorpTubeCost::
* PutTorpTritCost::
* PutTorpDurCost::
* PutTorpMolyCost::
* PutTorpTubeMass::
* PutTorpTechLevel::
* PutTorpKillPower::
* PutTorpDestructivePower::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item TorpName
@item TorpTorpCost
@item TorpTubeCost
@item TorpTritCost
@item TorpDurCost
@item TorpMolyCost
@item TorpTubeMass
@item TorpTechLevel
@item TorpKillPower
@item TorpDestructivePower
@item PutTorpName
@item PutTorpTorpCost
@item PutTorpTubeCost
@item PutTorpTritCost
@item PutTorpDurCost
@item PutTorpMolyCost
@item PutTorpTubeMass
@item PutTorpTechLevel
@item PutTorpKillPower
@item PutTorpDestructivePower
@end itemize
@end iftex


@node TorpName, TorpTorpCost, Torpedo Accessors, Torpedo Accessors
@subsection char* TorpName(Uns16 pTorpNr, char* pBuffer)
@findex TorpName

This routine returns the name of a given torpedo number. If 'pBuffer' is
non-NULL, then it must point to a previously allocated area of at least 21
bytes. The torpedo name is then stored in this area and the routine returns
'pBuffer'. If 'pBuffer' is NULL, then the torpedo name is stored in a
temporary area which is overwritten with each call to this routine. The
return value is then a pointer to this temporary area.

@node TorpTorpCost, TorpTubeCost, TorpName, Torpedo Accessors
@subsection Uns16 TorpTorpCost(Uns16 pTorpNr)
@findex TorpTorpCost

This routine returns the number of megacredits required to build one
torpedo of the given type.

@node TorpTubeCost, TorpTritCost, TorpTorpCost, Torpedo Accessors
@subsection Uns16 TorpTubeCost(Uns16 pTorpNr)
@findex TorpTubeCost

This routine returns the number of megacredits required to build one
torpedo launcher tube of the given type.

@node TorpTritCost, TorpDurCost, TorpTubeCost, Torpedo Accessors
@subsection Uns16 TorpTritCost(Uns16 pTorpNr)
@findex TorpTritCost

This routine returns the amount of Tritanium required to build one tube of
the given type.

@node TorpDurCost, TorpMolyCost, TorpTritCost, Torpedo Accessors
@subsection Uns16 TorpDurCost(Uns16 pTorpNr)
@findex TorpDurCost

This routine returns the amount of Duranium required to build one tube of
the given type.

@node TorpMolyCost, TorpTubeMass, TorpDurCost, Torpedo Accessors
@subsection Uns16 TorpMolyCost(Uns16 pTorpNr)
@findex TorpMolyCost

This routine returns the amount of Molybdenum required to build one tube of
the given type.

@node TorpTubeMass, TorpTechLevel, TorpMolyCost, Torpedo Accessors
@subsection Uns16 TorpTubeMass(Uns16 pTorpNr)
@findex TorpTubeMass

This routine returns the mass of one tube of the given type.

@node TorpTechLevel, TorpKillPower, TorpTubeMass, Torpedo Accessors
@subsection Uns16 TorpTechLevel(Uns16 pTorpNr)
@findex TorpTechLevel

This routine returns the minimum tech level required to build torpedoes and
tubes of the given type.

@node TorpKillPower, TorpDestructivePower, TorpTechLevel, Torpedo Accessors
@subsection Uns16 TorpKillPower(Uns16 pTorpNr)
@findex TorpKillPower

This routine returns the amount of life-destroying power of the given
torpedo type.

@node TorpDestructivePower, PutTorpName, TorpKillPower, Torpedo Accessors
@subsection Uns16 TorpDestructivePower(Uns16 pTorpNr)
@findex TorpDestructivePower

This routine returns the amount of structure-destroying power of the given
torpedo type.

@node PutTorpName, PutTorpTorpCost, TorpDestructivePower, Torpedo Accessors
@subsection void PutTorpName(Uns16 pTorpNr, char *pName)
@findex PutTorpName

This routine sets the name of a given torpedo to pName. The 'pName'
parameter must point to a null-terminated string. Only the first 20 characters
will be used.

@node PutTorpTorpCost, PutTorpTubeCost, PutTorpName, Torpedo Accessors
@subsection void PutTorpTorpCost(Uns16 pTorpNr, Uns16 pTorpCost)
@findex PutTorpTorpCost

This routine sets the number of megacredits required to build one
torpedo of the given type.

@node PutTorpTubeCost, PutTorpTritCost, PutTorpTorpCost, Torpedo Accessors
@subsection void PutTorpTubeCost(Uns16 pTorpNr, Uns16 pTubeCost)
@findex PutTorpTubeCost

This routine sets the number of megacredits required to build one
torpedo launcher tube of the given type.

@node PutTorpTritCost, PutTorpDurCost, PutTorpTubeCost, Torpedo Accessors
@subsection void PutTorpTritCost(Uns16 pTorpNr, Uns16 pTubeTritCost)
@findex PutTorpTritCost

This routine sets the amount of Tritanium required to build one tube of
the given type to pTubeTritCost.

@node PutTorpDurCost, PutTorpMolyCost, PutTorpTritCost, Torpedo Accessors
@subsection void PutTorpDurCost(Uns16 pTorpNr, Uns16 pTubeDurCost)
@findex PutTorpDurCost

This routine sets the amount of Duranium required to build one tube of
the given type to pTubeDurCost.

@node PutTorpMolyCost, PutTorpTubeMass, PutTorpDurCost, Torpedo Accessors
@subsection void PutTorpMolyCost(Uns16 pTorpNr, Uns16 pTubeMolyCost)
@findex PutTorpMolyCost

This routine sets the amount of Molybdenum required to build one tube of
the given type to pTubeMolyCost.

@node PutTorpTubeMass, PutTorpTechLevel, PutTorpMolyCost, Torpedo Accessors
@subsection void PutTorpTubeMass(Uns16 pTorpNr, Uns16 pTubeMass)
@findex PutTorpTubeMass

This routine sets the mass of one tube of the given type to pTubeMass.

@node PutTorpTechLevel, PutTorpKillPower, PutTorpTubeMass, Torpedo Accessors
@subsection void PutTorpTechLevel(Uns16 pTorpNr, Uns16 pTechLevel)
@findex PutTorpTechLevel

This routine sets the minimum tech level required to build torpedoes and
tubes of the given type to pTechLevel.

@node PutTorpKillPower, PutTorpDestructivePower, PutTorpTechLevel, Torpedo Accessors
@subsection void PutTorpKillPower(Uns16 pTorpNr, Uns16 pKillPower)
@findex PutTorpKillPower

This routine sets the amount of life-destroying power of the given
torpedo type to pKillPower.

@node PutTorpDestructivePower,  , PutTorpKillPower, Torpedo Accessors
@subsection void PutTorpDestructivePower(Uns16 pTorpNr, Uns16 pDestructivePower)
@findex PutTorpDestructivePower

This routine sets the amount of structure-destroying power of the given
torpedo type to pDestructivePower.

@node Beam Weapon Accessors, Race Name Accessors, Torpedo Accessors, Function Call Interface
@section Beam Weapon Accessors

These routines provide an interface to the beam weapon data stored in the
BEAMSPEC.DAT file. These routines should not be invoked unless the
ReadGlobalData() routine has been called. All beam number parameters
specified to these routines must be in the range 1 through BEAM_NR.

@menu
* BeamName::
* BeamMoneyCost::
* BeamTritCost::
* BeamDurCost::
* BeamMolyCost::
* BeamMass::
* BeamTechLevel::
* BeamKillPower::
* BeamDestructivePower::
* PutBeamName::
* PutBeamMoneyCost::
* PutBeamTritCost::
* PutBeamDurCost::
* PutBeamMolyCost::
* PutBeamMass::
* PutBeamTechLevel::
* PutBeamKillPower::
* PutBeamDestructivePower::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item BeamName
@item BeamMoneyCost
@item BeamTritCost
@item BeamDurCost
@item BeamMolyCost
@item BeamMass
@item BeamTechLevel
@item BeamKillPower
@item BeamDestructivePower
@item PutBeamName
@item PutBeamMoneyCost
@item PutBeamTritCost
@item PutBeamDurCost
@item PutBeamMolyCost
@item PutBeamMass
@item PutBeamTechLevel
@item PutBeamKillPower
@item PutBeamDestructivePower
@end itemize
@end iftex


@node BeamName, BeamMoneyCost, Beam Weapon Accessors, Beam Weapon Accessors
@subsection char* BeamName(Uns16 pBeamNr, char* pBuffer)
@findex BeamName

This routine returns the name of a given beam number. The 'pBuffer' parameter
must be non-NULL and must point to a previously allocated area of at least 21
bytes. The beam name is then stored in this area and the routine returns
'pBuffer'.

@node BeamMoneyCost, BeamTritCost, BeamName, Beam Weapon Accessors
@subsection Uns16 BeamMoneyCost(Uns16 pBeamNr)
@findex BeamMoneyCost

This routine returns the amount of megacredits required to build a beam
weapon of the given type.

@node BeamTritCost, BeamDurCost, BeamMoneyCost, Beam Weapon Accessors
@subsection Uns16 BeamTritCost(Uns16 pBeamNr)
@findex BeamTritCost

This routine returns the amount of Tritanium required to build a beam
weapon of the given type.

@node BeamDurCost, BeamMolyCost, BeamTritCost, Beam Weapon Accessors
@subsection Uns16 BeamDurCost(Uns16 pBeamNr)
@findex BeamDurCost

This routine returns the amount of Duranium required to build a beam weapon
of the given type.

@node BeamMolyCost, BeamMass, BeamDurCost, Beam Weapon Accessors
@subsection Uns16 BeamMolyCost(Uns16 pBeamNr)
@findex BeamMolyCost

This routine returns the amount of Molybdenum required to build a beam
weapon of the given type.

@node BeamMass, BeamTechLevel, BeamMolyCost, Beam Weapon Accessors
@subsection Uns16 BeamMass(Uns16 pBeamNr)
@findex BeamMass

This routine returns the mass of one beam weapon of the given type.

@node BeamTechLevel, BeamKillPower, BeamMass, Beam Weapon Accessors
@subsection Uns16 BeamTechLevel(Uns16 pBeamNr)
@findex BeamTechLevel

This routine returns the minimum tech level required to build a beam weapon
of the given type.

@node BeamKillPower, BeamDestructivePower, BeamTechLevel, Beam Weapon Accessors
@subsection Uns16 BeamKillPower(Uns16 pBeamNr)
@findex BeamKillPower

This routine returns the amount of life-destroying power of the given
beam type.

@node BeamDestructivePower, PutBeamName, BeamKillPower, Beam Weapon Accessors
@subsection Uns16 BeamDestructivePower(Uns16 pBeamNr)
@findex BeamDestructivePower

This routine returns the amount of structure-destroying power of the given
beam type.

@node PutBeamName, PutBeamMoneyCost, BeamDestructivePower, Beam Weapon Accessors
@subsection  void PutBeamName(Uns16 pBeamNr, char *pName)
@findex PutBeamName

This routine sets the name of a given beam to pName. The 'pName'
parameter must point to a null-terminated string. Only the first 20 characters
will be used.

@node PutBeamMoneyCost, PutBeamTritCost, PutBeamName, Beam Weapon Accessors
@subsection  void PutBeamMoneyCost(Uns16 pBeamNr, Uns16 pMoneyCost)
@findex PutBeamMoneyCost

This routine sets the amount of megacredits required to build a beam
weapon of the given type to pMoneyCost.

@node PutBeamTritCost, PutBeamDurCost, PutBeamMoneyCost, Beam Weapon Accessors
@subsection void PutBeamTritCost(Uns16 pBeamNr, Uns16 pTritCost)
@findex PutBeamTritCost

This routine sets the amount of Tritanium required to build a beam
weapon of the given type to pTritCost.

@node PutBeamDurCost, PutBeamMolyCost, PutBeamTritCost, Beam Weapon Accessors
@subsection void PutBeamDurCost(Uns16 pBeamNr, Uns16 pDurCost)
@findex PutBeamDurCost

This routine sets the amount of Duranium required to build a beam weapon
of the given type to pDurCost.

@node PutBeamMolyCost, PutBeamMass, PutBeamDurCost, Beam Weapon Accessors
@subsection void PutBeamMolyCost(Uns16 pBeamNr, Uns16 pMolyCost)
@findex PutBeamMolyCost

This routine sets the amount of Molybdenum required to build a beam
weapon of the given type to pMolyCost.

@node PutBeamMass, PutBeamTechLevel, PutBeamMolyCost, Beam Weapon Accessors
@subsection void PutBeamMass(Uns16 pBeamNr, Uns16 pMass)
@findex PutBeamMass

This routine sets the mass of one beam weapon of the given type to pMass.

@node PutBeamTechLevel, PutBeamKillPower, PutBeamMass, Beam Weapon Accessors
@subsection void PutBeamTechLevel(Uns16 pBeamNr, Uns16 pTechLevel)
@findex PutBeamTechLevel

This routine sets the minimum tech level required to build a beam weapon
of the given type to pTechLevel.

@node PutBeamKillPower, PutBeamDestructivePower, PutBeamTechLevel, Beam Weapon Accessors
@subsection void PutBeamKillPower(Uns16 pBeamNr, Uns16 pKillPower)
@findex PutBeamKillPower

This routine sets the amount of life-destroying power of the given
beam type to pKillPower.

@node PutBeamDestructivePower,  , PutBeamKillPower, Beam Weapon Accessors
@subsection void PutBeamDestructivePower(Uns16 pBeamNr, Uns16 pDestructivePower)
@findex PutBeamDestructivePower

This routine sets the amount of structure-destroying power of the given
beam type to pDestructivePower.


@node Race Name Accessors, Host Run Time Accessors, Beam Weapon Accessors, Function Call Interface
@section Race Name Accessors

These routines provide an interface to the race name data stored in the
RACE.NM file. These routines should not be invoked unless the
ReadGlobalData() routine has been called.

@menu
* RaceLongName::
* RaceShortName::
* RaceNameAdjective::
* PutRaceLongName::
* PutRaceShortName::
* PutRaceNameAdjective::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item RaceLongName
@item RaceShortName
@item RaceNameAdjective
@item PutRaceLongName
@item PutRaceShortName
@item PutRaceNameAdjective
@end itemize
@end iftex


@node RaceLongName, RaceShortName, Race Name Accessors, Race Name Accessors
@subsection const char* RaceLongName(RaceType_Def pRace, char* pBuffer)
@findex RaceLongName

This routine returns the full name of a race. If 'pBuffer' is non-NULL,
then the race name is also copied to this buffer, which must point to an
area at least 31 bytes long.

@node RaceShortName, RaceNameAdjective, RaceLongName, Race Name Accessors
@subsection const char* RaceShortName(RaceType_Def pRace, char *pBuffer)
@findex RaceShortName

This routine returns the short name of a race. If 'pBuffer' is non-NULL,
then the short race name is also copied to this buffer, which must point to
an area at least 21 bytes long.

@node RaceNameAdjective, PutRaceLongName, RaceShortName, Race Name Accessors
@subsection const char* RaceNameAdjective(RaceType_Def pRace, char *pBuffer)
@findex RaceNameAdjective

This routine returns the adjective name of a race. If 'pBuffer' is
non-NULL, then the adjective name is also copied to this buffer, which must
point to an area at least 13 bytes long.

@node PutRaceLongName, PutRaceShortName, RaceNameAdjective, Race Name Accessors
@subsection void PutRaceLongName(RaceType_Def pRace, const char* pBuffer)
@findex PutRaceLongName

This routine modifies the long race name of the given race to the string
pointed to by 'pBuffer'. Only the first 30 characters of the new string are
used.

@node PutRaceShortName, PutRaceNameAdjective, PutRaceLongName, Race Name Accessors
@subsection void PutRaceShortName(RaceType_Def pRace, const char *pBuffer)
@findex PutRaceShortName

This routine modifies the short race name of the given race to the string
pointed to by 'pBuffer'. Only the first 20 characters of the new string are
used.

@node PutRaceNameAdjective,  , PutRaceShortName, Race Name Accessors
@subsection void PutRaceNameAdjective(RaceType_Def pRace, const char *pBuffer)
@findex PutRaceNameAdjective

This routine modifies the race name adjective of the given race to the
string pointed to by 'pBuffer'. Only the first 12 characters of the new
string are used.


@node Host Run Time Accessors, Enumeration Functions, Race Name Accessors, Function Call Interface
@section Host Run Time Accessors

These routines provide an interface to the host run time and host turn
number. These routines should not be invoked unless the ReadHostData()
routine has been called.

@menu
* TurnNumber::
* HostTimeStamp::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item TurnNumber
@item HostTimeStamp
@end itemize
@end iftex

@node TurnNumber, HostTimeStamp, Host Run Time Accessors, Host Run Time Accessors
@subsection Uns16 TurnNumber(void)
@findex TurnNumber

This routine returns the current turn number.

@node HostTimeStamp,  , TurnNumber, Host Run Time Accessors
@subsection char *HostTimeStamp(char *pTimeStamp)
@findex HostTimeStamp

This routine stores the 18-character host run time information in the area
pointed to by 'pTimeStamp' which must be at least 18 characters long. There
is no NULL appended to this data. The return value of this routine is
'pTimeStamp'.


@node Enumeration Functions, External Message Interface, Host Run Time Accessors, Function Call Interface
@section Enumeration Functions

The following functions are provided simply as a service to programmers
because they are routines that are commonly used. All of the routines are
used for finding objects (ships, minefields, etc.). Routines that have a
return type of 'Uns16 *' all return a pointer to a temporary list of
integers, which is terminated by a 0 entry. This list is overwritten with
each call to ANY one of these functions so the values in the list should be
saved if necessary. For example, EnumerateShipsAt() returns a pointer to a
list of ships that all reside at one location in space. If there are 3
ships at this location, then the list will contain 3 Uns16 values
indicating the ship ID numbers, and a 4th value which is 0 (indicating the
end of the list). If there are no objects found, then the routines return a
pointer to a list containing only a single 0; the routines never return
NULL pointers.

Note that all of these routines are "wrap-map aware", meaning they respect
and properly implement the wraparound map feature of PHOST 3. The
gPconfigInfo->AllowWraparoundMap config option is checked so a prior call
to ReadHostData() must have been performed for wraparound map support to be
enabled.

@menu
* EnumerateShipsWithinRadius::
* EnumerateShipsAt::
* EnumerateMinesWithinRadius::
* FindPlanetAtShip::
* FindGravityPlanet::
* EnumeratePlanetsWithin::
* EnumerateShipsAtPlanet::
* EnumerateMinesCovering::
* EnumerateOverlappingMines::
@end menu


@iftex
Functions in this section:
@itemize @minus
@item EnumerateShipsWithinRadius
@item EnumerateShipsAt
@item EnumerateMinesWithinRadius
@item FindPlanetAtShip
@item FindGravityPlanet
@item EnumeratePlanetsWithin
@item EnumerateShipsAtPlanet
@item EnumerateMinesCovering
@item EnumerateOverlappingMines
@end itemize
@end iftex

@node EnumerateShipsWithinRadius, EnumerateShipsAt, Enumeration Functions, Enumeration Functions
@subsection Uns16 *EnumerateShipsWithinRadius(Int16 pX, Int16 pY, double pRadius)
@findex EnumerateShipsWithinRadius

This routine returns a list of all ships that are within a certain radius
of a given (X,Y) location.

@node EnumerateShipsAt, EnumerateMinesWithinRadius, EnumerateShipsWithinRadius, Enumeration Functions
@subsection Uns16 *EnumerateShipsAt(Uns16 pX, Uns16 pY)
@findex EnumerateShipsAt

This routine returns a list of all ships that are located at the given
(X,Y) position.

@node EnumerateMinesWithinRadius, FindPlanetAtShip, EnumerateShipsAt, Enumeration Functions
@subsection Uns16 *EnumerateMinesWithinRadius(Int16 pX, Int16 pY, Uns16 pRadius)
@findex EnumerateMinesWithinRadius

This routine returns a list of all minefields that extend to within a given
radius of a certain (X,Y) location.

@node FindPlanetAtShip, FindGravityPlanet, EnumerateMinesWithinRadius, Enumeration Functions
@subsection Uns16 FindPlanetAtShip(Uns16 lShip)
@findex FindPlanetAtShip

This routine returns a single integer indicating the planet that the given
ship is orbiting. If the given ship is not at a planet, this routine
returns 0.

@node FindGravityPlanet, EnumeratePlanetsWithin, FindPlanetAtShip, Enumeration Functions
@subsection Uns16 FindGravityPlanet(Int16 pX, Int16 pY)
@findex FindGravityPlanet

This routine returns the first planet found that is within gravity well
range of the given (X,Y) co-ordinates.

@node EnumeratePlanetsWithin, EnumerateShipsAtPlanet, FindGravityPlanet, Enumeration Functions
@subsection Uns16 *EnumeratePlanetsWithin(Int16 pX, Int16 pY, Uns16 pRadius)
@findex EnumeratePlanetsWithin

This routine returns a list of all planets that are within the given radius
of a specified (X,Y) location.

@node EnumerateShipsAtPlanet, EnumerateMinesCovering, EnumeratePlanetsWithin, Enumeration Functions
@subsection Uns16 *EnumerateShipsAtPlanet(Uns16 pPlanet)
@findex EnumerateShipsAtPlanet

This routine returns a list of all ships in orbit of the given planet.

@node EnumerateMinesCovering, EnumerateOverlappingMines, EnumerateShipsAtPlanet, Enumeration Functions
@subsection Uns16 *EnumerateMinesCovering(Int16 pX, Int16 pY)
@findex EnumerateMinesCovering

This routine returns a list of all minefields that extend to the given
(X,Y) location.

@node EnumerateOverlappingMines,  , EnumerateMinesCovering, Enumeration Functions
@subsection Uns16 *EnumerateOverlappingMines(Uns16 pMinefield)
@findex EnumerateOverlappingMines

This routine returns a list of all minefields that overlap the specified
minefield number.


@node External Message Interface, AUXHOST Message Interface, Enumeration Functions, Function Call Interface
@section External Message Interface

These routines manipulate the two external message files, MESS.EXT and
MESSPNT.EXT. These files contain messages that are read in by the host
program after the AUXHOST 2 phase. The SENDMESS program, for example, uses
these two files to store host-to-player messages. These routines, then, are
suitable for programs that run BEFORE RST files are generated.

@menu
* WriteExternalMessage::
@end menu

@iftex
Function in this section:
@itemize @minus
@item WriteExternalMessage
@end itemize
@end iftex

@node WriteExternalMessage,  , External Message Interface, External Message Interface
@subsection Boolean WriteExternalMessage(RaceType_Def pRace, const char *pMessage)
@findex WriteExternalMessage

This routine adds a plain text message to the message list for a given
player. The 'pMessage' parameter must point to a null-terminated text
string.


@node AUXHOST Message Interface, RST Message Interface, External Message Interface, Function Call Interface
@section AUXHOST Message Interface

These routines add messages to a player's message list for programs that
execute as AUXHOST programs (that is, in the middle of host execution).
These routines, then, are suitable for programs that run DURING host
processing.

@menu
* WriteAUXHOSTMessage::
@end menu

@iftex
Function in this section:
@itemize @minus
@item WriteAUXHOSTMessage
@end itemize
@end iftex

@node WriteAUXHOSTMessage,  , AUXHOST Message Interface, AUXHOST Message Interface
@subsection Boolean WriteAUXHOSTMessage(RaceType_Def pRace, const char *pMessage)
@findex WriteAUXHOSTMessage

This routine adds a plain text message to the message list for a given
player. The 'pMessage' parameter must point to a null-terminated text
string.


@node RST Message Interface, Build Queue Interface, AUXHOST Message Interface, Function Call Interface
@section RST Message Interface

These routines add messages to a player's message list for programs that
run after the host has completed execution. These routines write their
messages directly to the player's RST files. These routines, then, are
suitable for programs that run AFTER host processing.

@menu
* WriteMessageToRST::
@end menu

@iftex
Function in this section:
@itemize @minus
@item WriteMessageToRST
@end itemize
@end iftex

@node WriteMessageToRST,  , RST Message Interface, RST Message Interface
@subsection Boolean WriteMessageToRST(RaceType_Def pRace, int pNumMsgs, const char *pMessages[])
@findex WriteMessageToRST

This routine adds plain text messages to the message list for a given
player. The 'pNumMsgs' parameter indicates the number of messages to
append, and the 'pMessages' array must contain a list of pointers to the
messages. Each message in this list is assumed to be a plain-text
null-terminated string not exceeding 840 characters (20 lines by 42
characters, with a 0Dh at the end of each line). The messages are written
to the player's RST file, but first a backup copy of the existing RST file
is made to the file 'PLAYERX.BAK'.

This routine may be called as often as necessary but it is a good idea to save
up all messages and only call this routine once as writing messages to an RST
file is a relatively slow operation.

NOTE: Usage of this routine is discouraged. The format of RST files has
been known to change in the past, making existing programs incompatible and
leading to bizarre errors on the player side. It is safest to never modify
RST files.


@node Build Queue Interface, Player Activity Level, RST Message Interface, Function Call Interface
@section Build Queue Interface

These routines are all involved with the PHOST-specific build queue. These
routines should not be called unless an AUXDATA.HST file was read (unless
only additions to the queue are performed). These routines have no effect
on games using HOST.

@menu
* BuildQueuePeek::
* BuildQueuePush::
* BuildQueueInvalidate::
* ShipsInBuildQueue::
* SortBuildQueue::
* BuildQueueBaseID::
* BuildQueuePriority::
* BuildQueueIsCloning::
* BuildQueueShipOwner::
* BuildQueueOwner::
* BuildQueueHullType::
* BuildQueueEngineType::
* BuildQueueBeamType::
* BuildQueueTorpType::
* BuildQueueBeamNumber::
* BuildQueueTorpNumber::
* PutBuildQueuePriority::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item BuildQueuePeek
@item BuildQueuePush
@item BuildQueueInvalidate
@item ShipsInBuildQueue
@item SortBuildQueue
@item BuildQueueBaseID
@item BuildQueuePriority
@item BuildQueueIsCloning
@item BuildQueueShipOwner
@item BuildQueueOwner
@item BuildQueueHullType
@item BuildQueueEngineType
@item BuildQueueBeamType
@item BuildQueueTorpType
@item BuildQueueBeamNumber
@item BuildQueueTorpNumber
@item PutBuildQueuePriority
@end itemize
@end iftex

@node BuildQueuePeek, BuildQueuePush, Build Queue Interface, Build Queue Interface
@subsection Uns16 BuildQueuePeek(BaseOrder_Struct *pOrder)
@findex BuildQueuePeek

This routine allows a look at the first build order in the build queue,
without actually modifying the build queue. The return value is the base ID
of the first build order. The 'pOrder' parameter must point to a previously
allocated area that is to hold the first build order, if any.

@node BuildQueuePush, BuildQueueInvalidate, BuildQueuePeek, Build Queue Interface
@subsection void BuildQueuePush(BaseOrder_Struct *pOrderPtr)
@findex BuildQueuePush

This routine adds a build order to the build queue. If there is no build
order already in the queue for the given base, the given build order is
added at the end. If there is a build order already in the queue for the
given base, then if the new order is the same as the old order, nothing
happens. If the new order is different, the build order is handled
according to the priority build point system described in the BUILDQ.HTM
documentation file that comes with PHOST 3.

@node BuildQueueInvalidate, ShipsInBuildQueue, BuildQueuePush, Build Queue Interface
@subsection void BuildQueueInvalidate(Uns16 pBase)
@findex BuildQueueInvalidate

This routine removes a build order from the queue. The build order at the
specified base ID is removed.

@node ShipsInBuildQueue, SortBuildQueue, BuildQueueInvalidate, Build Queue Interface
@subsection Uns16 ShipsInBuildQueue(void)
@findex ShipsInBuildQueue

This routine returns the number of build orders in the queue.

@node SortBuildQueue, BuildQueueBaseID, ShipsInBuildQueue, Build Queue Interface
@subsection void SortBuildQueue(void)
@findex SortBuildQueue

This routine sorts all of the entries in the build queue in descending
order of priority (in the same way that PHOST 3 does). Note that this
routine does NOT take into account priority overrides via the PBn planetary
friendly codes.

@node BuildQueueBaseID, BuildQueuePriority, SortBuildQueue, Build Queue Interface
@subsection Uns16 BuildQueueBaseID(Uns16 pPosition)
@findex BuildQueueBaseID

This function returns ID of base that placed build order for a given
position in build queue.

@node BuildQueuePriority, BuildQueueIsCloning, BuildQueueBaseID, Build Queue Interface
@subsection Uns32 BuildQueuePriority(Uns16 pPosition)
@findex BuildQueuePriority

This function returns priority of build order for a given position
in build queue.

@node BuildQueueIsCloning, BuildQueueShipOwner, BuildQueuePriority, Build Queue Interface
@subsection Boolean BuildQueueIsCloning(Uns16 pPosition)
@findex BuildQueueIsCloning

This function returns True if build order for given position
in build queue is a cloning. False if it is normal build order.

@node BuildQueueShipOwner, BuildQueueOwner, BuildQueueIsCloning, Build Queue Interface
@subsection RaceType_Def BuildQueueShipOwner(Uns16 pPosition)
@findex BuildQueueShipOwner

This function returns ship owner of cloned ship for given position
in build queue.

@node BuildQueueOwner, BuildQueueHullType, BuildQueueShipOwner, Build Queue Interface
@subsection RaceType_Def BuildQueueOwner(Uns16 pPosition)
@findex BuildQueueOwner

This function returns owner of build order for given position
in build queue.

@node BuildQueueHullType, BuildQueueEngineType, BuildQueueOwner, Build Queue Interface
@subsection Uns16 BuildQueueHullType(Uns16 pPosition)
@findex BuildQueueHullType

This function returns hull type number of build order for given position
in build queue. Returned hull number is in range 1 to HULL_NR.

@node BuildQueueEngineType, BuildQueueBeamType, BuildQueueHullType, Build Queue Interface
@subsection Uns16 BuildQueueEngineType(Uns16 pPosition)
@findex BuildQueueEngineType

This function returns engine type number of build order for given position
in build queue. Returned hull number is in range 1 to ENGINE_NR.

@node BuildQueueBeamType, BuildQueueTorpType, BuildQueueEngineType, Build Queue Interface
@subsection Uns16 BuildQueueBeamType(Uns16 pPosition)
@findex BuildQueueBeamType

This function returns beam type number of build order for given position
in build queue. Returned hull number is in range 1 to BEAM_NR.

@node BuildQueueTorpType, BuildQueueBeamNumber, BuildQueueBeamType, Build Queue Interface
@subsection Uns16 BuildQueueTorpType(Uns16 pPosition)
@findex BuildQueueTorpType

This function returns torpedo type number of build order for given position
in build queue. Returned hull number is in range 1 to TORP_NR.

@node BuildQueueBeamNumber, BuildQueueTorpNumber, BuildQueueTorpType, Build Queue Interface
@subsection Uns16 BuildQueueBeamNumber(Uns16 pPosition)
@findex BuildQueueBeamNumber

This function returns beam number mounted to hull of build order for
given position in build queue.

@node BuildQueueTorpNumber, PutBuildQueuePriority, BuildQueueBeamNumber, Build Queue Interface
@subsection Uns16 BuildQueueTorpNumber(Uns16 pPosition)
@findex BuildQueueTorpNumber

This function returns torpedo launchers number mounted to hull of
build order for given position in build queue.

@node PutBuildQueuePriority,  , BuildQueueTorpNumber, Build Queue Interface
@subsection void PutBuildQueuePriority(Uns16 pPosition, Uns32 pPriority)
@findex PutBuildQueuePriority

This function sets priority of build order for a given position in build queue.

@node Player Activity Level, Alliance Management, Build Queue Interface, Function Call Interface
@section Player Activity Level

The PDK allows access to the player activity level (PAL). Access to turn
activity level (TAL) is possible with PHost 4.0f and later; the PDK
transparently distinguishes both cases.

@emph{PHost 4.0f and later:} Points you add using @code{AddToActivityLevel}
will appear in the PAL status message as new points this turn. Players will
not be able to use them this turn for ship building (PBP queue).

@emph{PHost up to 4.0e, or add-on not running using pcontrol/auxhost:}
Points you add using @code{AddToActivityLevel} will be immediately
visible as PAL. They will be included in the PAL status message as "Old
value". They can be immediately used for ship building with a PBP queue.

@menu
* GetActivityLevel::
* SetActivityLevel::
* AddToActivityLevel::
* GetTotalActivityLevel::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item GetActivityLevel
@item SetActivityLevel
@item AddToActivityLevel
@item GetTotalActivityLevel
@end itemize
@end iftex


@node GetActivityLevel, SetActivityLevel, Player Activity Level, Player Activity Level
@subsection Uns32 GetActivityLevel(Uns16 pRace)
@findex GetActivityLevel

This routine returns the activity level of a player.


@node SetActivityLevel, AddToActivityLevel, GetActivityLevel, Player Activity Level
@subsection void  SetActivityLevel(Uns16 pRace, Uns32 pNewLevel)
@findex SetActivityLevel

This routine sets the activity level of a player.

@node AddToActivityLevel, GetTotalActivityLevel, SetActivityLevel, Player Activity Level
@subsection void AddToActivityLevel(Uns16 pRace, Uns32 pToAdd)
@findex AddToActivityLevel

Adds @code{pToAdd} points to the specified race's activity level. If
possible (add-on running in pcontrol/auxhost of PHost 4.0f or later),
the points are added to the TAL, and will appear as new points in the
report. Otherwise, they will be added to the PAL.

@node GetTotalActivityLevel,  , AddToActivityLevel, Player Activity Level
@subsection Uns32 GetTotalActivityLevel(Uns16 pRace)
@findex GetTotalActivityLevel

Returns the total activity level of the player, consisting of PAL plus
TAL. This is an estimate only, it does not include point decay and
consumption by PBP builds.

@node Alliance Management, Game Status Interface, Player Activity Level, Function Call Interface
@section Alliance Management

These routines are all concerned with PHOST alliances. The PHOST alliance
information is stored in the AUXDATA.HST file, so meaningful information
will only be available if this file has been read. If this file is not
read, then all status functions will return False, and any changes made to
alliance status will not be saved since the AUXDATA.HST file is never
written if it has not been read. In any case, the Write_AuxData_File()
function must be called to save any changes in alliance status.

PHost 4.0h added the @code{enemies} command to set up permanent primary
enemies. These can be accessed from the PDK as well.

@menu
* AllyAddRequest::
* AllyDropRequest::
* PlayerOffersAlliance::
* PlayersAreAllies::
* IsAllyOfferAny::
* IsAllyOfferConditional::
* PlayerAllowsAlly::
* PutPlayerAllowsAlly::
* ShipHasEnemy::
* PlayerHasEnemy::
* PutPlayerHasEnemy::
* IsPlayerEnemyAllowed::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item AllyAddRequest
@item AllyDropRequest
@item PlayerOffersAlliance
@item PlayersAreAllies
@item IsAllyOfferAny
@item IsAllyOfferConditional
@item PlayerAllowsAlly
@item PutPlayerAllowsAlly
@item ShipHasEnemy
@item PlayerHasEnemy
@item PutPlayerHasEnemy
@item IsPlayerEnemyAllowed
@end itemize
@end iftex

@node AllyAddRequest, AllyDropRequest, Alliance Management, Alliance Management
@subsection void AllyAddRequest(RaceType_Def pPlayer, RaceType_Def pRace)
@findex AllyAddRequest

This routine indicates that the player 'pPlayer' is requesting an alliance
with 'pRace'. All alliance levels are disabled.

@node AllyDropRequest, PlayerOffersAlliance, AllyAddRequest, Alliance Management
@subsection void AllyDropRequest(RaceType_Def pPlayer, RaceType_Def pRace)
@findex AllyDropRequest

This routine withdraws the alliance that player 'pPlayer' has offered to
player 'pRace' and removes all levels of alliance.

@node PlayerOffersAlliance, PlayersAreAllies, AllyDropRequest, Alliance Management
@subsection Boolean PlayerOffersAlliance(RaceType_Def pPlayer, RaceType_Def pRace)
@findex PlayerOffersAlliance

This routine returns True if player 'pPlayer' has offered an alliance to
player 'pRace'. This will only be the case if AllyAddRequest() has been
called for these two players (i.e., AllyAddRequest(pPlayer, pRace)). The
specific levels of alliance that have/have-not been offered are not
relevant, it is simply the offer of alliance that is considered.

@node PlayersAreAllies, IsAllyOfferAny, PlayerOffersAlliance, Alliance Management
@subsection Boolean PlayersAreAllies(RaceType_Def pPlayer, RaceType_Def pRace)
@findex PlayersAreAllies

This routine returns True if both player 'pPlayer' and player 'pRace' have
offered alliances to each other. This routine is just a shorthand method of
writing:
                PlayerOffersAlliance(pPlayer, pRace)
             && PlayerOffersAlliance(pRace, pPlayer)

@node IsAllyOfferAny, IsAllyOfferConditional, PlayersAreAllies, Alliance Management
@subsection Boolean IsAllyOfferAny(RaceType_Def pPlayer, RaceType_Def pRace, AllianceLevel_Def pLevel)
@findex IsAllyOfferAny

This routine returns True if player 'pPlayer' has offered the 'pLevel'
level of alliance to player 'pRace', in either the conditional or
unconditional form. The IsAllyOfferConditional() routine (below) can be
called to check on the conditional/unconditional status of the offer.

@node IsAllyOfferConditional, PlayerAllowsAlly, IsAllyOfferAny, Alliance Management
@subsection Boolean IsAllyOfferConditional(RaceType_Def pPlayer, RaceType_Def pRace, AllianceLevel_Def pLevel)
@findex IsAllyOfferConditional

This routine returns True if player 'pPlayer' has offered the 'pLevel'
level of alliance to player 'pRace' and if that offer has been made
conditionally. If either of these two conditions is False, then this
routine returns False.

@node PlayerAllowsAlly, PutPlayerAllowsAlly, IsAllyOfferConditional, Alliance Management
@subsection Boolean PlayerAllowsAlly(RaceType_Def pPlayer, RaceType_Def pRace, AllianceLevel_Def pLevel)
@findex PlayerAllowsAlly

This routine returns True if player 'pPlayer' has offered the 'pLevel' of
alliance to player 'pRace' unconditionally, or if the level has been
offered conditionally and the 'pRace' player has reciprocated. Note that it
is not sufficient to just call this routine in order to grant benefits to
allies, a call to PlayersAreAllies() must also be checked. The
PlayerAllowsAlly() routine may return True but unless the allied player has
also offered an alliance in return, PHOST does not consider the alliance to
be formed.

Note that this routine is just a shorthand method of writing:

@example
          IsAllyOfferAny(pPlayer, pRace, pLevel)
       && (   (! IsAllyOfferConditional(pPlayer, pRace, pLevel))
           || (IsAllyOfferAny(pRace, pPlayer, pLevel))
          )
@end example

@node PutPlayerAllowsAlly, ShipHasEnemy, PlayerAllowsAlly, Alliance Management
@subsection void PutPlayerAllowsAlly(RaceType_Def pPlayer, RaceType_Def pRace, AllianceLevel_Def pLevel, AllianceState_Def pState)
@findex PutPlayerAllowsAlly

This routine indicates that player 'pPlayer' has offered, denied, or
conditionally offered (according to the setting of 'pState') the 'pLevel'
level of alliance to player 'pRace'.

@node ShipHasEnemy, PlayerHasEnemy, PutPlayerAllowsAlly, Alliance Management
@subsection Boolean ShipHasEnemy(Uns16 pShipId, RaceType_Def pEnemy)
@findex ShipHasEnemy

This function checks whether the specified race @code{pEnemy} qualifies
as an enemy of @code{pShipId}. It checks the following properties:
@itemize @minus
@item ship owner. A ship cannot be its own enemy.
@item mission. With Kill, everyone qualifies as enemy.
@item primary enemy. Without primary enemy and Kill, the ship is not
aggressive. Otherwise, the ship is aggressive to the races specified
as permanent primary enemies as well as the race set as PE.
@end itemize

This function does not check alliance relationships. It is possible and
allowed to have an ally as permanent enemy (like it is possible to set a
ship's PE to an ally). Unless the player offers the appropriate alliance
level, the enemy relationship will take effect.

@node PlayerHasEnemy, PutPlayerHasEnemy, ShipHasEnemy, Alliance Management
@subsection Boolean PlayerHasEnemy(RaceType_Def pPlayer, RaceType_Def pEnemy)
@findex PlayerHasEnemy

Checks whether the @code{pPlayer} has set @code{pEnemy} as a permanent
enemy. If the host version in use does not support permanent enemies,
returns @code{False}.

@node PutPlayerHasEnemy, IsPlayerEnemyAllowed, PlayerHasEnemy, Alliance Management
@subsection Boolean PutPlayerHasEnemy(RaceType_Def pPlayer, RaceType_Def pEnemy, Boolean pIsEnemy)
@findex PutPlayerHasEnemy

Sets @code{pEnemy} as permanent enemy of @code{pPlayer} if
@code{pIsEnemy} is True, removes the permanent enemy if @code{pIsEnemy}
is False.

This function returns true if the operation succeeds, false if it fails.
It can fail if the parameters are out of range, or the host version in
use does not support permanent enemies.

@node IsPlayerEnemyAllowed,  , PutPlayerHasEnemy, Alliance Management
@subsection Boolean IsPlayerEnemyAllowed(void)
@findex IsPlayerEnemyAllowed

Returns true iff the host version in use supports permanent enemies,
i.e. the @ref{PutPlayerHasEnemy} call.

PHost version 4.0h and later supports that feature, older ones don't.

@c ----------------------------------------------------------------------

@node Game Status Interface, File Utility Functions, Alliance Management, Function Call Interface
@section Game Status Interface

These routines return information about the game data itself.

@menu
* GameFilesVersion::
* SetNewMajorVersion::
@end menu

@iftex
Function in this section:
@itemize @minus
@item GameFilesVersion
@item SetNewMajorVersion
@end itemize
@end iftex

@node GameFilesVersion, SetNewMajorVersion, Game Status Interface, Game Status Interface
@subsection Boolean GameFilesVersion(Uns16 *pMajor, Uns16 *pMinor)
@findex GameFilesVersion

This routine returns the version number of the PHOST program that last
updated the game data files. The 'pMajor' and 'pMinor' parameters must
point to pre-allocated areas that will hold the major version and minor
version information, respectively. This routine can also be used to aid in
the determination of whether the game is being hosted with HOST or PHOST.

The validity of the information returned by this routine is conditional
upon the existence of an AUXDATA.HST file. Here are the various return
values that can occur and their dependence upon the AUXDATA.HST file:

@itemize @bullet

@item If there is no attempt made to read the AUXDATA.HST file (by calling
ReadHostData()) then this routine returns True and the major and minor versions
are both reported as being 0.

@item If there is an attempt to read the AUXDATA.HST file (by calling
ReadHostData()) but no AUXDATA.HST file exists then this routine returns False
and no version information is provided.

Thus, this routine returns False for games being hosted with HOST. Note,
however, that the routine may also return False for PHOST games in which the
AUXDATA.HST file has been deleted.

@item If there is an attempt to read the AUXDATA.HST file and the file exists
(and is valid) then this routine returns True and version information is
provided.

@end itemize

@node SetNewMajorVersion,  , GameFilesVersion, Game Status Interface
@subsection void SetNewMajorVersion(int pVersion)
@findex SetNewMajorVersion

When configured for PHost 4 compatibility, the PDK will transparently
handle both PHost 3.x and PHost 4.x data files, and rewrite them in the
same format it read.

When the PDK is used to create new data files (a ``Master'' type program
maybe), this call can be used to choose the format you want. The
pVersion parameter is either 3 or 4: the desired major version number.
When you call this function, you must do so before calling any other
function.

Instead of this function, the PDK also evaluates the PHOST_VERSION
environment variable. Hence, you do not even need to call this function
and your programs are still fully flexible.

When the user didn't set a PHOST_VERSION variable, and your program
doesn't call this function, and the PDK did not load existing game data,
new game data will be written in the most recent (i.e. 4.x) file format.

@node File Utility Functions, Memory Management, Game Status Interface, Function Call Interface
@section File Utility Functions

These functions are not directly related to host processing but instead are
utility functions that programmers may find useful in managing game files.

@menu
* OpenInputFile::
* OpenOutputFile::
* OpenUpdateFile::
* RemoveGameFile::
* CopyFileToFile::
* CopyGameFile::
* RenameGameFile::
* FileLength::
@end menu


@iftex
Functions in this section:
@itemize @minus
@item OpenInputFile
@item OpenOutputFile
@item OpenUpdateFile
@item RemoveGameFile
@item CopyFileToFile
@item CopyGameFile
@item RenameGameFile
@item FileLength
@end itemize
@end iftex


@node OpenInputFile, OpenOutputFile, File Utility Functions, File Utility Functions
@subsection FILE *OpenInputFile(const char *pName, int pLocation)
@findex OpenInputFile

This routine attempts to open a file in either the game or root directory.
If the file cannot be found, the program is terminated with an error
message (unless the 'pLocation' parameter contains the NO_MISSING_ERROR
flag, see below for more details). The 'pName' argument should contain a
simple filename (i.e., no pathname information). The location where the
filename is sought (game directory, root directory, or both) should be
specified by the 'pLocation' parameter. This parameter can consist of one
or more of the following constants OR'ed together:

@multitable @columnfractions .30 .70
@item GAME_DIR_ONLY --
@tab  This flag indicates that the file must be located only in the game directory.
The root directory is not searched. The value of the 'gGameDirectory' global
variable is used to find the game directory.
@item ROOT_DIR_ONLY --
@tab This flag indicates that the file must be located only in the root
directory. The game directory is not searched. The value of the 'gRootDirectory'
global variable is used to find the root directory.
@item GAME_OR_ROOT_DIR --
@tab This flag indicates that the file will be sought first in the game
directory, and then, if not found, the root directory.
@item TEXT_MODE --
@tab This flag indicates that the file is to be opened as a text file, rather
than a binary file (which is the default) on operating systems that make a
distinction (i.e., DOS).
@item NO_MISSING_ERROR --
@tab This flag indicates that OpenInputFile() should not exit with an error if
the file cannot be found. The routine simply returns NULL in this case.
@end multitable


@node OpenOutputFile, OpenUpdateFile, OpenInputFile, File Utility Functions
@subsection FILE *OpenOutputFile(const char *pName, int pLocation)
@findex OpenOutputFile

This routine attempts to create a file in either the game or root
directory. All of the flags used for OpenInputFile() have the same meaning
here but there are some differences:

@multitable @columnfractions .30 .70
@item GAME_OR_ROOT_DIR --
@tab This flag may not be specified
@item APPEND_MODE --
@tab This flag indicates that the file is to be opened in append mode, adding to
the end of any existing file. By default, the file is opened in write mode,
overwriting any existing file.
@end multitable

@node OpenUpdateFile, RemoveGameFile, OpenOutputFile, File Utility Functions
@subsection FILE *OpenUpdateFile(const char *pName, int pLocation)
@findex OpenUpdateFile

This routine attempts to open a file for both reading and writing (i.e.,
update) in either the game or root directory. All of the flags mentioned
above are applicable with the following differences:

@multitable @columnfractions .30 .70
@item GAME_OR_ROOT_DIR --
@tab This flag may not be specified
@item REWRITE_MODE --
@tab This flag indicates that the file is to be opened for rewriting (i.e.,
reading and writing at any position). By default, the file is opened for reading
and writing only at the end of any existing file.
@end multitable

@node RemoveGameFile, CopyFileToFile, OpenUpdateFile, File Utility Functions
@subsection Boolean RemoveGameFile(const char *pName)
@findex RemoveGameFile

This routine attempts to remove the file with the given name in the game
directory only. If the file cannot be found or cannot be deleted, the
routine returns False.


@node CopyFileToFile, CopyGameFile, RemoveGameFile, File Utility Functions
@subsection Boolean CopyFileToFile(FILE *pSrc, FILE *pDst, Uns32 pSize)
@findex CopyFileToFile

This routine copies data from one open file to another. The number of bytes
to copy is given by the 'pSize' parameter. This routine returns True if
successful, otherwise it prints an error message and returns False.

@node CopyGameFile, RenameGameFile, CopyFileToFile, File Utility Functions
@subsection Boolean CopyGameFile(const char *pSrcName, const char *pDstName)
@findex CopyGameFile

This routine attempts to make a copy of a file in the game directory. The
'pSrcName' parameter gives the name of the existing file and 'pDstName'
gives the name of the file that is to receive the copy. The routine returns
True if the copy was successful, False otherwise.

@node RenameGameFile, FileLength, CopyGameFile, File Utility Functions
@subsection Boolean RenameGameFile(const char *OldName, const char *NewName)
@findex RenameGameFile

This routine attempts to rename a game file from the name 'OldName' to the
name 'NewName'. The routine returns True if successful, False otherwise.

@node FileLength,  , RenameGameFile, File Utility Functions
@subsection Uns32 FileLength(FILE *lFile)
@findex FileLength

This routine returns the length of a file in bytes.

@node Memory Management, Messaging and Logging, File Utility Functions, Function Call Interface
@section Memory Management

These routines are not directly related to host processing but are provided
for convenience.

@menu
* MemAlloc::
* MemCalloc::
* MemRealloc::
* MemFree::
@end menu


@iftex
Functions in this section:
@itemize @minus
@item MemAlloc
@item MemCalloc
@item MemRealloc
@item MemFree
@end itemize
@end iftex


@node MemAlloc, MemCalloc, Memory Management, Memory Management
@subsection void *MemAlloc(size_t pAmount)
@findex MemAlloc

This routine allocates the specified number of bytes from the pool of
available memory. If the required memory cannot be allocated, the program
is terminated with an error message. Thus, there is no reason to check the
return value from this routine for NULL.

@node MemCalloc, MemRealloc, MemAlloc, Memory Management
@subsection void *MemCalloc(size_t pNumber, size_t pSize)
@findex MemCalloc

This routine allocates 'pNumber' elements of 'pSize' bytes each from the
pool of available memory. The allocated memory is set to all 0's. If the
required memory cannot be allocated, t t program is terminated with an
error message.

@node MemRealloc, MemFree, MemCalloc, Memory Management
@subsection void *MemRealloc(void *pPtr, size_t pAmount)
@findex MemRealloc

This routine resizes a previously allocated area (pointed to by 'pPtr') to
the number of bytes indicated by 'pAmount'. If the required memory cannot
be allocated, the program is terminated with an error message.

@node MemFree,  , MemRealloc, Memory Management
@subsection void  MemFree(void *pPtr)
@findex MemFree

This routine deallocates a block of memory that was previously allocated
with MemAlloc() or MemCalloc(). If 'pPtr' is NULL, then nothing happens.


@node Messaging and Logging, Random Number Generation, Memory Management, Function Call Interface
@section Messaging and Logging

The following routines are not directly related to host processing but are
provided for convenience. These routines display messages to the user and
also log the messages to a log file, if enabled. By default, the messages
are sent to the standard output (stdout). If the 'gLogFile' global variable
points to a valid file, then the same message is also sent to this file.

@menu
* Error::
* VError::
* ErrorExit::
* VErrorExit::
* Warning::
* VWarning::
* Info::
* VInfo::
* passert::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item Error
@item VError
@item ErrorExit
@item VErrorExit
@item Warning
@item VWarning
@item Info
@item VInfo
@item passert
@end itemize
@end iftex


@node Error, VError, Messaging and Logging, Messaging and Logging
@subsection void Error(const char *pStr, ...)
@findex Error

This routine generates a message preceded by the string "Error: ". The
'pStr' string may contain printf-style format specifiers and a variable
number of arguments may follow 'pStr' to match these specifiers. For
example, "Error("bad parameter at line %u", lineNumber)" will generate the
message "Error: bad parameter at line 10" if 'lineNumber' is 10.

@node VError, ErrorExit, Error, Messaging and Logging
@subsection void VError(const char *pStr, va_list pAP)
@findex VError

This routine is the same as Error() except that the variable argument list
is replaced with a va_list (stdarg.h usage).

@node ErrorExit, VErrorExit, VError, Messaging and Logging
@subsection void ErrorExit(const char *pStr, ...)
@findex ErrorExit

This routine is the same as Error() except that the program is terminated
after the error message is displayed. The program exit code is set to -1.

@node VErrorExit, Warning, ErrorExit, Messaging and Logging
@subsection void VErrorExit(const char *pStr, va_list pAP)
@findex VErrorExit

This routine is the same as VError() except that the program is terminated
after the error message is displayed. The program exit code is set to -1.

@node Warning, VWarning, VErrorExit, Messaging and Logging
@subsection void Warning(const char *pStr, ...)
@findex Warning

This routine is the same as Error() except that the string "Warning: " is
prepended to the output rather than "Error: ".

@node VWarning, Info, Warning, Messaging and Logging
@subsection void VWarning(const char *pStr, va_list pAP)
@findex VWarning

This routine is the same as Warning() except that the variable argument
list is replaced with a va_list (stdarg.h usage).

@node Info, VInfo, VWarning, Messaging and Logging
@subsection void Info(const char *pStr, ...)
@findex Info

This routine is the same as Error() except that there is no string
prepended to the output message.

@node VInfo, passert, Info, Messaging and Logging
@subsection void VInfo(const char *pStr, va_list pAP)
@findex VInfo

This routine is the same as Info() except that the variable argument list
is replaced with a va_list (stdarg.h usage).

@node passert,  , VInfo, Messaging and Logging
@subsection void passert(Boolean pExpr)
@findex passert

This routine is a replacement for the standard 'assert' function. If
'pExpr' is False, then ErrorExit() is called with an error message
indicating the file and line number of the statement. If the program has
been compiled with the constant NDEBUG defined to the preprocessor, then
'passert' does nothing, regardless of the value of 'pExpr'. This routine is
preferred over 'assert' because 'assert' usually calls 'abort' which does
not perform an orderly cleanup of the program.


@node Random Number Generation, Cross-Platform Portability, Messaging and Logging, Function Call Interface
@section Random Number Generation

These routines are not directly related to host processing but are provided
for convenience. These routines allow for the portable generation of random
numbers. Since the range of native random number generators on different
platforms varies, these routines allow the same code to work on all
platforms. Furthermore, the underlying mechanisms of random number
generation are different on various platforms, but the following routines
all behave the same way on all platforms. Thus, the same pseudo-random
sequence will be obtained from a given starting seed regardless of which
platform is being used.

@menu
* SetRandomSeed::
* RandomRange::
* RandomReal::
@end menu


@iftex
Functions in this section:
@itemize @minus
@item SetRandomSeed
@item RandomRange
@item RandomReal
@end itemize
@end iftex


@node SetRandomSeed, RandomRange, Random Number Generation, Random Number Generation
@subsection void SetRandomSeed(Uns16 seed)
@findex SetRandomSeed

This routine sets the random number generator's seed to a specified value.

@node RandomRange, RandomReal, SetRandomSeed, Random Number Generation
@subsection RandType_Def RandomRange(RandType_Def pRange)
@findex RandomRange

This routine returns a pseudo-random integer in the range 0 through
(pRange-1) inclusive. The pRange parameter must be in the range [1,32767].

@node RandomReal,  , RandomRange, Random Number Generation
@subsection double RandomReal(void)  (UNAVAILABLE in Microsoft-DOS)
@findex RandomReal

This routine returns a floating-point random number in the range [0,1).
That is, 0 may be returned, but 1 may not.


@node Cross-Platform Portability, Cross-Platform Portability Part II, Random Number Generation, Function Call Interface
@section Cross-Platform Portability

These routines are not directly related to host processing but are provided
for convenience. These routines are meant to aid in writing portable
programs.

@menu
* WordSwapLong::
* WordSwapShort::
* DOSRead16::
* DOSRead32::
* DOSWrite16::
* DOSWrite32::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item WordSwapLong
@item WordSwapShort
@item DOSRead16
@item DOSRead32
@item DOSWrite16
@item DOSWrite32
@end itemize
@end iftex

@node WordSwapLong, WordSwapShort, Cross-Platform Portability, Cross-Platform Portability
@subsection void WordSwapLong(void *pData, Uns16 pNumWords)
@findex WordSwapLong

This routine switches the byte order of 32-bit words if the system on which
the program is running is big-endian. On little-endian systems, this
routine does nothing. The 'pData' parameter points to the memory that is to
be swapped, and 'pNumWords' indicates the number of 32-bit words at this
memory location that are to be swapped. This routine is provided for making
programs endian-aware. When data is received from or sent to a DOS
platform, it must be in little-endian format. However, some platforms are
big-endian. Thus, this routine can be used to swap the byte order to or
from little-endian format before or after processing.

@node WordSwapShort, DOSRead16, WordSwapLong, Cross-Platform Portability
@subsection void WordSwapShort(void* pData, Uns16 pNumWords)
@findex WordSwapShort

This routine switches the byte order of 16-bit words if the system on which
the program is running is big-endian. On little-endian systems, this
routine does nothing. The 'pNumWords' parameter indicates the number of
16-bit words which are to be byte-swapped.

@node DOSRead16, DOSRead32, WordSwapShort, Cross-Platform Portability
@subsection Boolean DOSRead16(Uns16 *pData, Uns16 pNum, FILE *pInFile)
@findex DOSRead16

This routine reads 'pNum' 16-bit words from the file 'pInFile' and stores
them in the area pointed to by 'pData', which must have been previously
allocated. The data is assumed to have been generated on a DOS (i.e., IBM
PC compatible) machine. The data is byte-swapped if necessary before the
routine returns, so that the data may be accessed in the native mode of the
machine on which the program is running. This routine returns True if
successful, False otherwise.

@node DOSRead32, DOSWrite16, DOSRead16, Cross-Platform Portability
@subsection Boolean DOSRead32(Uns32 *pData, Uns16 pNum, FILE *pInFile)
@findex DOSRead32

This routine reads 'pNum' 32-bit words from the file 'pInFile' and stores
them in the area pointed to by 'pData', which must have been previously
allocated. The data is assumed to have been generated on a DOS (i.e., IBM
PC compatible) machine. The data is byte-swapped if necessary before the
routine returns, so that the data may be accessed in the native mode of the
machine on which the program is running. This routine returns True if
successful, False otherwise.

@node DOSWrite16, DOSWrite32, DOSRead32, Cross-Platform Portability
@subsection Boolean DOSWrite16(Uns16 *pData, Uns16 pNum, FILE *pOutFile)
@findex DOSWrite16

This routine writes 'pNum' 16-bit words to the file 'pOutFile' from the
area pointed to by 'pData'. The data is written out in a format expected by
DOS (i.e., IBM PC compatible) machines. The data is byte-swapped if
necessary prior to writing to 'pOutFile', then byte-swapped again to return
the data to the native format of the machine. Thus, the contents of 'pData'
remain unchanged. The routine returns True if successful, False otherwise.

@node DOSWrite32,  , DOSWrite16, Cross-Platform Portability
@subsection Boolean DOSWrite32(Uns32 *pData, Uns16 pNum, FILE *pOutFile)
@findex DOSWrite32

This routine writes 'pNum' 32-bit words to the file 'pOutFile' from the
area pointed to by 'pData'. The data is written out in a format expected by
DOS (i.e., IBM PC compatible) machines. The data is byte-swapped if
necessary prior to writing to 'pOutFile', then byte-swapped again to return
the data to the native format of the machine. Thus, the contents of 'pData'
remain unchanged. The routine returns True if successful, False otherwise.


@node Cross-Platform Portability Part II, Command-Line Option Processing, Cross-Platform Portability, Function Call Interface
@section Cross-Platform Portability Part II (new - 4.2)

The following structures and functions are available by including
<doscvt.h>.

When you want to read or write a data structure in DOS format,
you first have to define its layout. For each structure, there
must be an array of DOSConvertElement items:

@example
           typedef struct DOSConvertElement @{
             size_t mOffset;
             Uns16 mSize;                  /* for char arguments */
             DOSCVT_Def mType;
           @} DOSConvertElement;
@end example

@itemize @minus
@item mType is the type of this member; one of DOSCVT_char (array of char),
DOSCVT_Uns16 (2 bytes, little endian), DOSCVT_Int16 (2 bytes, little endian),
DOSCVT_Uns32 (4 bytes, little endian), DOSCVT_Int32 (4 bytes, little endian),
DOSCVT_enum (any enum), DOSCVT_Boolean.
@item mOffset is the offset of the structure member in the C structure,
usually `offsetof(MyStructure, mMyMember)'
@item mSize is the number of items, for char arrays only.
@end itemize

For example, the layout of an XYPLAN.DAT entry could be defined as

@example
           typedef struct @{
               Uns16 mX, mY;
               Uns16 mOwner;
           @} XYPlan_Entry;
           DOSConvertElement XYPlan_Convert[] = @{
               @{ offsetof(XYPlan_Entry, mX), 1, DOSCVT_Uns16 @},
               @{ offsetof(XYPlan_Entry, mY), 1, DOSCVT_Uns16 @},
               @{ offsetof(XYPlan_Entry, mOwner), 1, DOSCVT_Uns16 @}
           @};
@end example

You can also abbreviate this by using the supplied macros:

@example
           #define DOSCVT_NAME XYPlan_Entry
           DOSConvertElement XYPlan_Convert[] = @{
               DOSCVT(Uns16, mX, 1),
               DOSCVT(Uns16, mY, 1),
               DOSCVT(Uns16, mOwner, 1)
           @};
@end example

The following are the functions you can now use:

@menu
* DOSWriteStruct::
* DOSReadStruct::
* DOSStructSize::
* DOSStructConvert::
* UnixConvertStruct::
* ReadDOSUns16::
* ReadDOSUns32::
* WriteDOSUns16::
* WriteDOSUns32::
@end menu

@iftex
@itemize @minus
@item DOSWriteStruct
@item DOSReadStruct
@item DOSStructSize
@item DOSStructConvert
@item UnixConvertStruct
@item ReadDOSUns16
@item ReadDOSUns32
@item WriteDOSUns16
@item WriteDOSUns32
@end itemize
@end iftex

@node DOSWriteStruct, DOSReadStruct, Cross-Platform Portability Part II, Cross-Platform Portability Part II
@subsection Boolean DOSWriteStruct(const DOSConvertElement * pStruct, Uns16 pNumElements, const void *pData, FILE * pOutFile)
@findex DOSWriteStruct

Write the structure pointed to by 'pData' to file 'pOutFile'.
'pStruct' points to the DOSConvertElement array, 'pNumElements' is the
number of items in the array. The above structure could be written by

@example
    XYPlan_Entry lEntry;
    FILE* lFile;
    /* ... */
    DOSWriteStruct(XYPlan_Convert, 3, &lEntry, lFile);
@end example

'DOSWriteStruct' returns True if everything went OK, False otherwise.

@node DOSReadStruct, DOSStructSize, DOSWriteStruct, Cross-Platform Portability Part II
@subsection Boolean DOSReadStruct(const DOSConvertElement * pStruct, Uns16 pNumElements, void *pData, FILE * pInFile)
@findex DOSReadStruct

Reads the structure pointed to by 'pData' from 'pInFile'. 'pStruct'
and 'pNumElements' define the conversion. Returns True if everything
went OK, False otherwise.

@node DOSStructSize, DOSStructConvert, DOSReadStruct, Cross-Platform Portability Part II
@subsection Uns16 DOSStructSize(const DOSConvertElement *pStruct, Uns16 pNumElem)
@findex DOSStructSize

Computes the size of the structure defined by 'pStruct' and 'pNumElem'.
For example, for the above definition,

@example
    DOSStructSize(XYPlan_Convert, 3)
@end example

would return 6.

@node DOSStructConvert, UnixConvertStruct, DOSStructSize, Cross-Platform Portability Part II
@subsection Boolean DOSStructConvert(const DOSConvertElement *pStruct, Uns16 pNumElements, const void *pSrc, void *pDst)
@findex DOSStructConvert

'pSrc' points to a char array containing a DOS structure. This
function will unpack the structure into the C structure 'pDst', using
the conversion information from 'pStruct' and 'pNumElements'. The array
'pSrc' points to must be 'DOSStructSize(pStruct, pNumElements)' bytes
in size. Returns True.

@node UnixConvertStruct, ReadDOSUns16, DOSStructConvert, Cross-Platform Portability Part II
@subsection void UnixConvertStruct(const DOSConvertElement *pStruct, Uns16 pNumElements, const void *pData, void *pDst)
@findex UnixConvertStruct

This does the reverse operation as 'DOSStructConvert'. It converts
the C structure pointed to by 'pData' to DOS format. 'pDst' must
point to 'DOSStructSize(pStruct, pNumElements)' bytes of memory.
The conversion is defined by 'pStruct' and 'pNumElements'.

@node ReadDOSUns16, ReadDOSUns32, UnixConvertStruct, Cross-Platform Portability Part II
@subsection Uns16 ReadDOSUns16(const void *pVal)
@findex ReadDOSUns16

Fetch the 16 quantity pointed to by 'pVal'.

@node ReadDOSUns32, WriteDOSUns16, ReadDOSUns16, Cross-Platform Portability Part II
@subsection Uns32 ReadDOSUns32(const void *pVal)
@findex ReadDOSUns32

Fetch the 32 quantity pointed to by 'pVal'.

@node WriteDOSUns16, WriteDOSUns32, ReadDOSUns32, Cross-Platform Portability Part II
@subsection void WriteDOSUns16(void* pData, Uns16 pVal)
@findex WriteDOSUns16

Stores the 16-bit quantity @code{pVal} in the two bytes pointed to by
@code{pData}.

@node WriteDOSUns32,  , WriteDOSUns16, Cross-Platform Portability Part II
@subsection void WriteDOSUns32(void* pData, Uns32 pVal)
@findex WriteDOSUns32

Stores the 32-bit quantity @code{pVal} in the four bytes pointed to by
@code{pData}.

@node Command-Line Option Processing, Combat Interface, Cross-Platform Portability Part II, Function Call Interface
@section Command-Line Option Processing

@menu
* pgetopt::
@end menu

@iftex
Function in this section:
@itemize @minus
@item pgetopt
@end itemize
@end iftex

@node pgetopt,  , Command-Line Option Processing, Command-Line Option Processing
@subsection int pgetopt(int argc, char *argv[], char *optstring)
@findex pgetopt

Users familiar with the common 'getopt()' routine found on many systems
will find this routine to be very similar. This routine is provided so that
programs can be portable to all platforms, rather than just the ones on
which 'getopt()' exists (which are fewer than one would hope).

This routine can be used to simplify the processing of command-line
options. The 'argc' and 'argv' parameters are simply the same as the ones
presented to the 'main()' function of the program. The 'optstring'
parameter indicates which command-line options are valid. This string
consists of characters that indicate valid options. Option characters are
case sensitive.

Each call to this routine returns one of the following:

@itemize @minus

@item a character found in 'optstring'. This means that the next command line
option is the character itself.

@item the special character '?'. This means that the next command line option is
a character not found in 'optstring'. An error message has already been
displayed in this case.

@item EOF. This means that there are no more command line options.

@end itemize

After each call to 'pgetopt()', the global variable 'poptind' is an index
into 'argv' indicating the current command line parameter. After
'pgetopt()' returns EOF, 'poptind' points to the first non-option parameter
on the command line. That is, 'argv[poptind]' is the first parameter that
is not a command-line option.

There is one provision for command-line options that take parameters. If a
character in the 'optstring' string is followed by ':', then this option
requires a parameter. In this case, when 'pgetopt()' is processing this
option, the global variable 'poptarg' points to the command-line parameter
that is the argument of the option.

Here is a brief example on 'pgetopt()' usage. For better examples, please
see the EX*.C files (for example, EX6.C).

@example
------------------------------------------------------------------------
        int c;

        // Command line usage is:
        //                    program [options] gamedir @{rootdir@}
        // options:     -h OR -H   -- get help
        //              -v         -- print version
        //              -n N       -- specify number N (parameter)
        //              -x         -- specify option X
        while ((c = pgetopt(argc, argv, "hHvn:x")) != EOF) @{
            switch (c) @{
             case 'h': case 'H': case '?': default:
                  printHelpText();
                  exit(0);

             case 'v':
                  printVersionInfo();
                  break;

             case 'n':
                  Number = atoi(poptarg);
                  break;

             case 'x':
                  OptionX = 1;
                  break;
            @}
        @}
        if (poptind < argc) @{
            gGameDirectory = argv[poptind++];
        @} else ErrorExit("Must specify game directory");

        if (poptind < argc) @{
           gRootDirectory = argv[poptind++];
        @} else return;

        if (poptind < argc) @{
           ErrorExit("Too many parameters on command line");
        @}
------------------------------------------------------------------------
@end example


@node Combat Interface, Remote Control Interface, Command-Line Option Processing, Function Call Interface
@section Combat Interface

The PDK library contains a 'combat module' which implements combat in
exactly the same way as PHOST. Any code that calls the Combat() API routine
(see below) automatically links in this combat module. By linking in the
combat module, however, the PDK expects the user code to define several
functions that take action depending upon certain combat events. The
example source file EX6.C is a good introduction to interfacing with the
combat module.

@menu
* Combat::
* DrawInitBeams::
* DrawInitTubes::
* DrawBeamRecharge::
* DrawTubeRecharge::
* DrawBayRecharge::
* DrawFighterAttack::
* DrawEraseFighterAttack::
* DrawFighterReturn::
* DrawEraseFighterReturn::
* DrawShipShields::
* DrawShipDamage::
* DrawShipCaptured::
* DrawShipDestroyed::
* DrawStalemateResult::
* DrawShipCrew::
* DrawTorpNumber::
* DrawFighterNumber::
* DrawFighterHit::
* DrawFighterHitFighter::
* DrawTorpHit::
* DrawTorpMiss::
* DrawBeamHitFighter::
* DrawBeamMissedFighter::
* DrawBeamHitShip::
* DrawBeamMissedShip::
* DrawShip::
* DrawEraseShip::
* DrawDistance::
@end menu


@iftex
Functions in this section:
@itemize @minus
@item Combat
@item DrawInitBeams
@item DrawInitTubes
@item DrawBeamRecharge
@item DrawTubeRecharge
@item DrawBayRecharge
@item DrawFighterAttack
@item DrawEraseFighterAttack
@item DrawFighterReturn
@item DrawEraseFighterReturn
@item DrawShipShields
@item DrawShipDamage
@item DrawShipCaptured
@item DrawShipDestroyed
@item DrawStalemateResult
@item DrawShipCrew
@item DrawTorpNumber
@item DrawFighterNumber
@item DrawFighterHit
@item DrawFighterHitFighter
@item DrawTorpHit
@item DrawTorpMiss
@item DrawBeamHitFighter
@item DrawBeamMissedFighter
@item DrawBeamHitShip
@item DrawBeamMissedShip
@item DrawShip
@item DrawEraseShip
@item DrawDistance
@end itemize
@end iftex


@node Combat, DrawInitBeams, Combat Interface, Combat Interface
@subsection void Combat(Combat_Struct *pShip1, Combat_Struct *pShip2)
@findex Combat

The Combat() routine is the main component of the combat module. It
performs a battle between two ships or between a ship and planet (in which
case the planet must always be represented by the second parameter to this
routine, 'pship2'). Prior to calling Combat(), the calling code must fill
in the values of two Combat_Struct structures (see PHOSTPDK.H for more info
on the contents of these structures).

Combat() has no return value but the outcome of the battle for each
ship/planet is stored in the 'Outcome' field of the corresponding
Combat_Struct structure.

Combat() correctly handles the 3X kill bonus of the Privateers and the 150%
damage limit for the Lizards, but other factors that affect pre-combat
conditions (such as the Fed crew bonus effect on mass, shields, etc.) are
not considered. These effects must be computed and reflected in the values
passed to Combat() via the Combat_Struct structures.

@example
                       *** NOTE ***
@end example

A prior call to ReadGlobalData() and ReadHostData()
must be performed prior to calling Combat().


The following routines are not included in the PDK. Rather, they define
routines that the user must provide in any code that uses the combat module
(in Windows parlance, they are "callback" routines). If only the results of
combat are of interest, then these routines can all be defined to do
nothing; Combat() does not require these routines to do anything. The EX6.C
example program shows how to define these routines to display a textual
commentary on a running battle, for example.

The following conventions apply to the following routines:

@itemize @bullet

@item The 'pShip' parameter is either 0 or 1. The value 0 represents the ship
described by the first parameter to Combat(), while the value 1 represents the
ship or planet described by the second parameter to Combat().

@item Distance and positions of objects is measured in meters. Ship 0 (i.e., the
ship described by the first parameter to Combat()) begins battle at the position -
29000 meters while ship 1 begins battle at position 29000. If ship 1 is actually
a planet, it does not move from its initial position, of course. Distance is
always a positive 32-bit measure, but position may be positive or negative (also
a 32-bit measure).

@item The word 'ship' can just as easily mean 'planet' or 'base' in the
subsequent descriptions. The single word 'ship' is used for brevity.

@item All indices are 0-based. For example, the 'pBeam' parameter in some
routines is in the range [0,NumBeams-1].

@end itemize

@node DrawInitBeams, DrawInitTubes, Combat, Combat Interface
@subsection void DrawInitBeams(Uns16 pShip, Uns16 pNumBeams, Uns16 pCharge)
@findex DrawInitBeams

This routine is called by Combat() before combat begins to indicate the
charge status of a ship's beams. The 'pNumBeams' parameter indicates the
number of beams, the 'pCharge' parameter indicates the initial charge (0
means fully discharged, 100 means fully charged).

@node DrawInitTubes, DrawBeamRecharge, DrawInitBeams, Combat Interface
@subsection void DrawInitTubes(Uns16 pShip, Uns16 pNumTubes, Uns16 pCharge)
@findex DrawInitTubes

This routine is called by Combat() before combat begins to indicate the
charge status of a ship's torpedo tubes. The 'pNumTubes' parameter
indicates the number of tubes, the 'pCharge' parameter indicates the
initial charge (0 means fully discharged, 100 means fully charged).

@node DrawBeamRecharge, DrawTubeRecharge, DrawInitTubes, Combat Interface
@subsection void DrawBeamRecharge(Uns16 pShip, Uns16 pBeam, Uns16 pCharge)
@findex DrawBeamRecharge

This routine is called by Combat() during a battle to indicate a new charge
level for a given beam 'pBeam'. The new charge level is in the range 0
(fully discharged) to 100 (fully charged). This routine is called very
often; optimizing the code in this routine is highly recommended.

@node DrawTubeRecharge, DrawBayRecharge, DrawBeamRecharge, Combat Interface
@subsection void DrawTubeRecharge(Uns16 pShip, Uns16 pTube, Uns16 pCharge)
@findex DrawTubeRecharge

This routine is called by Combat() during a battle to indicate a new charge
level for a given torpedo tube 'pTube'. The new charge level is in the
range 0 (fully discharged) to 100 (fully charged). This routine is called
very often; optimizing the code in this routine is highly recommended.

@node DrawBayRecharge, DrawFighterAttack, DrawTubeRecharge, Combat Interface
@subsection void DrawBayRecharge(Uns16 pShip, Uns16 pBay, Uns16 pCharge)
@findex DrawBayRecharge

This routine is called by Combat() during a battle to indicate a new charge
level for a given fighter bay 'pBay'. The new charge level is in the range
0 (fully discharged) to 100 (fully charged). This routine is called very
often; optimizing the code in this routine is highly recommended.

@node DrawFighterAttack, DrawEraseFighterAttack, DrawBayRecharge, Combat Interface
@subsection void DrawFighterAttack(Uns16 pShip, Uns16 pFighter, Int32 pPos)
@findex DrawFighterAttack

This routine is called by Combat() to indicate that fighter 'pFighter'
belonging to ship 'pShip' has advanced to position 'pPos'. A fighter is
"attacking" when it is moving towards the enemy. This means that attacking
fighters move in different directions depending upon which ship they belong
to (attacking fighters belonging to ship 0 move towards more positive
positions, attacking fighters belonging to ship 1 move towards more
negative positions). This routine is called very often; optimizing the code
in this routine is highly recommended.

@node DrawEraseFighterAttack, DrawFighterReturn, DrawFighterAttack, Combat Interface
@subsection void DrawEraseFighterAttack(Uns16 pShip, Uns16 pFighter, Int32 pPos)
@findex DrawEraseFighterAttack

This routine is called by Combat() to indicate that fighter 'pFighter'
belonging to ship 'pShip' is no longer at the given position. The fighter
is still "attacking" however (see DrawFighterAttack() above). Combat()
moves a fighter by repeatedly calling DrawEraseFighterAttack() with its old
position followed by DrawFighterAttack() with its new position. This
routine is called very often; optimizing the code in this routine is highly
recommended.

@node DrawFighterReturn, DrawEraseFighterReturn, DrawEraseFighterAttack, Combat Interface
@subsection void DrawFighterReturn(Uns16 pShip, Uns16 pFighter, Int32 pPos)
@findex DrawFighterReturn

This routine is called by Combat() to indicate that fighter 'pFighter'
belonging to ship 'pShip' has advanced to position 'pPos'. A fighter is
"returning" when it is moving away from the enemy and back to the owner
ship. This means that returning fighters move in different directions
depending upon which ship they belong to (returning fighters belonging to
ship 0 move towards more negative positions, returning fighters belonging
to ship 1 move towards more positive positions). This routine is called
very often; optimizing the code in this routine is highly recommended.

@node DrawEraseFighterReturn, DrawShipShields, DrawFighterReturn, Combat Interface
@subsection void DrawEraseFighterReturn(Uns16 pShip, Uns16 pFighter, Int32 pPos)
@findex DrawEraseFighterReturn

This routine is called by Combat() to indicate that fighter 'pFighter'
belonging to ship 'pShip' is no longer at the given position. The fighter
is still "returning" however (see DrawFighterReturn() above). Combat()
moves a fighter by repeatedly calling DrawEraseFighterReturn() with its old
position followed by DrawFighterReturn() with its new position. This
routine is called very often; optimizing the code in this routine is highly
recommended.

@node DrawShipShields, DrawShipDamage, DrawEraseFighterReturn, Combat Interface
@subsection void DrawShipShields(Uns16 pShip, Int32 pPos, double pShields)
@findex DrawShipShields

This routine is called by Combat() when a ship's shield level has changed.
The 'pPos' parameter indicates the current ship's position, while
'pShields' indicates the new shield level.

@node DrawShipDamage, DrawShipCaptured, DrawShipShields, Combat Interface
@subsection void DrawShipDamage(Uns16 pShip, double pDamage)
@findex DrawShipDamage

This routine is called by Combat() when a ship's damage level has changed.
The 'pPos' parameter indicates the current ship's position, while 'pDamage'
indicates the new damage level.

@node DrawShipCaptured, DrawShipDestroyed, DrawShipDamage, Combat Interface
@subsection void DrawShipCaptured(Uns16 pShip)
@findex DrawShipCaptured

This routine is called by Combat() when a ship's crew has fallen to 0 and
the battle ends since the given ship has been captured.

@node DrawShipDestroyed, DrawStalemateResult, DrawShipCaptured, Combat Interface
@subsection void DrawShipDestroyed(Uns16 pShip, Int32 pPos, Boolean pIsPlanet)
@findex DrawShipDestroyed

This routine is called by Combat() when a ship's damage level is
sufficiently high so that the ship explodes.

@node DrawStalemateResult, DrawShipCrew, DrawShipDestroyed, Combat Interface
@subsection void DrawStalemateResult(Boolean pIsPlanet2)
@findex DrawStalemateResult

This routine is called by Combat() when both ships have run out of
ammunition (i.e., both ships have no beams, no torpedoes, and no fighters
left).

@node DrawShipCrew, DrawTorpNumber, DrawStalemateResult, Combat Interface
@subsection void DrawShipCrew(Uns16 pShip, double pCrew)
@findex DrawShipCrew

This routine is called by Combat() when a ship's crew count has changed.

@node DrawTorpNumber, DrawFighterNumber, DrawShipCrew, Combat Interface
@subsection void DrawTorpNumber(Uns16 pShip, Uns16 pTorps)
@findex DrawTorpNumber

This routine is called by Combat() when the number of torpedoes on a ship
changes.

@node DrawFighterNumber, DrawFighterHit, DrawTorpNumber, Combat Interface
@subsection void DrawFighterNumber(Uns16 pShip, Uns16 pFighters)
@findex DrawFighterNumber

This routine is called by Combat() when the number of fighters on a ship
changes.

@node DrawFighterHit, DrawFighterHitFighter, DrawFighterNumber, Combat Interface
@subsection void DrawFighterHit(Uns16 pShip, Uns16 pFighter, Int32 pPos, Int32 pEnemyPos)
@findex DrawFighterHit

This routine is called by Combat() when a fighter belonging to ship 'pShip'
scores a hit on the enemy ship. The fighter itself is at position 'pPos',
the enemy ship is at position 'pEnemyPos'. The fighter number is given by
'pFighter'.

@node DrawFighterHitFighter, DrawTorpHit, DrawFighterHit, Combat Interface
@subsection void DrawFighterHitFighter(Int32 pPos, Uns16 pFighter1, Uns16 pFighter2)
@findex DrawFighterHitFighter

This routine is called by Combat() when a fighter destroys another (enemy)
fighter. The two fighters are both at or near position 'pPos'. The fighter
that is destroyed is given by 'pFighter2', while 'pFighter1' gives the
fighter that has destroyed the other. A call to DrawEraseFighter...() will
follow this call to remove the destroyed fighter from the display.

@node DrawTorpHit, DrawTorpMiss, DrawFighterHitFighter, Combat Interface
@subsection void DrawTorpHit(Uns16 pShip, Int32 pPos, Int32 pEnemyPos)
@findex DrawTorpHit

This routine is called when ship 'pShip' at position 'pPos' scores a
torpedo hit on the enemy at position 'pEnemyPos'.

@node DrawTorpMiss, DrawBeamHitFighter, DrawTorpHit, Combat Interface
@subsection void DrawTorpMiss(Uns16 pShip, Int32 pPos, Int32 pEnemyPos)
@findex DrawTorpMiss

This routine is called when ship 'pShip' at position 'pPos' launches a
torpedo on the enemy at position 'pEnemyPos' but the torpedo misses.

@node DrawBeamHitFighter, DrawBeamMissedFighter, DrawTorpMiss, Combat Interface
@subsection void DrawBeamHitFighter(Uns16 pShip, Uns16 pBeam, Int32 pPos, Uns16 pFighter, Int32 pEnemyFighterPos)
@findex DrawBeamHitFighter

This routine is called when ship 'pShip' at position 'pPos' fires beam
number 'pBeam' to destroy the enemy fighter 'pFighter' at position
'pEnemyFighterPos'. A call to DrawEraseFighter...() will follow this call
to remove the destroyed fighter from the display.

@node DrawBeamMissedFighter, DrawBeamHitShip, DrawBeamHitFighter, Combat Interface
@subsection void DrawBeamMissedFighter(Uns16 pShip, Uns16 pBeam, Int32 pPos, Uns16 pFighter, Int32 pEnemyFighterPos)
@findex DrawBeamMissedFighter

This routine is called when ship 'pShip' at position 'pPos' fires beam
number 'pBeam' towards the enemy fighter 'pFighter' at position
'pEnemyFighterPos' but the beam weapon misses.

@node DrawBeamHitShip, DrawBeamMissedShip, DrawBeamMissedFighter, Combat Interface
@subsection void DrawBeamHitShip(Uns16 pShip, Int32 pPos, Int32 pEnemyPos)
@findex DrawBeamHitShip

This routine is called when ship 'pShip' at position 'pPos' fires and hits
the enemy ship at position 'pEnemyPos'.

@node DrawBeamMissedShip, DrawShip, DrawBeamHitShip, Combat Interface
@subsection void DrawBeamMissedShip(Uns16 pShip, Int32 pPos, Int32 pEnemyPos)
@findex DrawBeamMissedShip

This routine is called when ship 'pShip' at position 'pPos' fires and
misses the enemy ship at position 'pEnemyPos'.

@node DrawShip, DrawEraseShip, DrawBeamMissedShip, Combat Interface
@subsection void DrawShip(Uns16 pShip, Int32 pPos)
@findex DrawShip

This routine is called to draw the given ship at the given position. The
ship is moved on the battlefield by repeatedly calling DrawEraseShip() (see
below) with the ship's old position followed by DrawShip() with the new
position.

@node DrawEraseShip, DrawDistance, DrawShip, Combat Interface
@subsection void DrawEraseShip(Uns16 pShip, Int32 pPos)
@findex DrawEraseShip

This routine is called to erase the given ship at the given position. The
ship is moved on the battlefield by repeatedly calling DrawEraseShip() with
the ship's old position followed by DrawShip() with the new position.

@node DrawDistance,  , DrawEraseShip, Combat Interface
@subsection void DrawDistance(Int32 pDist)
@findex DrawDistance

This routine is called to update the display of distance between the two
ships.

@node Remote Control Interface, Config File Reader Interface, Combat Interface, Function Call Interface
@section Remote Control Interface

The remote control interface functions give the application access to PHOST
3's remote control features. For more details, please see the REMOTE.HTM
documentation file that comes with PHOST 3.

@menu
* BeginShipRemoteControl::
* EndShipRemoteControl::
* IsShipRemoteControlled::
* IsShipRemoteForbidden::
* ResetShipRemoteControl::
* AssignDefaultForbidState::
* AllowShipRemoteControl::
* ForbidShipRemoteControl::
* ShipRemoteController::
* ShipRemoteOwner::
* SetDefaultRemoteState::
* DefaultRemoteState::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item BeginShipRemoteControl
@item EndShipRemoteControl
@item IsShipRemoteControlled
@item IsShipRemoteForbidden
@item ResetShipRemoteControl
@item AssignDefaultForbidState
@item AllowShipRemoteControl
@item ForbidShipRemoteControl
@item ShipRemoteController
@item ShipRemoteOwner
@item SetDefaultRemoteState
@item DefaultRemoteState
@end itemize
@end iftex


@node BeginShipRemoteControl, EndShipRemoteControl, Remote Control Interface, Remote Control Interface
@subsection Boolean BeginShipRemoteControl(Uns16 pShipID, Uns16 pRemoteOwner)

@findex BeginShipRemoteControl
This function initiates a remote control on a given ship. The
'pRemoteOwner' parameter indicates the player number of the remote
controller. This function returns True if successful, or False if the
remote control operation failed for any one of the following reasons:
@itemize @minus
@item The original ship owner has forbidden remote control
@item The remote controller is the same as the ship's owner
@item The required levels of alliance are not satisfied
@end itemize

@node EndShipRemoteControl, IsShipRemoteControlled, BeginShipRemoteControl, Remote Control Interface
@subsection Boolean EndShipRemoteControl(Uns16 pShipID, Uns16 pRemoteOwner)

@findex EndShipRemoteControl
This function terminates a previously-established remote control on a given
ship. The 'pRemoteOwner' parameter indicates the number of the player
initiating the request to terminate the remote control. This must match the
current remote control player else the function fails (and returns False).
If the function succeeds it returns True.

@node IsShipRemoteControlled, IsShipRemoteForbidden, EndShipRemoteControl, Remote Control Interface
@subsection Boolean IsShipRemoteControlled(Uns16 pShip)
@findex IsShipRemoteControlled

This function returns True if the given ship number is under remote
control.

@node IsShipRemoteForbidden, ResetShipRemoteControl, IsShipRemoteControlled, Remote Control Interface
@subsection Boolean IsShipRemoteForbidden(Uns16 pShip)
@findex IsShipRemoteForbidden

This function returns True if the given ship is forbidden from being
controlled.

@node ResetShipRemoteControl, AssignDefaultForbidState, IsShipRemoteForbidden, Remote Control Interface
@subsection void    ResetShipRemoteControl(Uns16 pShip)
@findex ResetShipRemoteControl

This function removes all remote-control information about a ship (its
original owner, whether remote control is forbidden, etc.) Calling this
function is appropriate when a ship is destroyed, when a new ship is
created, etc.

@node AssignDefaultForbidState, AllowShipRemoteControl, ResetShipRemoteControl, Remote Control Interface
@subsection void    AssignDefaultForbidState(Uns16 pShip)
@findex AssignDefaultForbidState

This function assigns the default remote control state (as chosen by the
player with the "remote...default" command) to ship pShip.

@node AllowShipRemoteControl, ForbidShipRemoteControl, AssignDefaultForbidState, Remote Control Interface
@subsection Boolean AllowShipRemoteControl(Uns16 pShipId, Uns16 pOrigOwner)
@findex AllowShipRemoteControl

This function enables remote control on a ship, resetting any previous
forbid order. The 'pOrigOwner' parameter is the number of the player
initiating this request and must match the original ship's owner for the
function to succeed. If the function succeeds, it returns True.

@node ForbidShipRemoteControl, ShipRemoteController, AllowShipRemoteControl, Remote Control Interface
@subsection Boolean ForbidShipRemoteControl(Uns16 pShipID, Uns16 pOrigOwner)
@findex ForbidShipRemoteControl

This function forbids remote control on a ship. The 'pOrigOwner' parameter
is the number of the player initiating this request and must match the
original ship's owner for the function to succeed. If the function
succeeds, it returns True.

@node ShipRemoteController, ShipRemoteOwner, ForbidShipRemoteControl, Remote Control Interface
@subsection Uns16   ShipRemoteController(Uns16 pShipID)
@findex ShipRemoteController

This function returns the number of the player currently possessing remote
control of a ship, or 0 if the ship is not under remote control.

@node ShipRemoteOwner, SetDefaultRemoteState, ShipRemoteController, Remote Control Interface
@subsection Uns16   ShipRemoteOwner(Uns16 pShipID)
@findex ShipRemoteOwner

This function returns the original owner of a ship that is currently under
remote control.

@node SetDefaultRemoteState, DefaultRemoteState, ShipRemoteOwner, Remote Control Interface
@subsection void SetDefaultRemoteState(RaceType_Def pRace, Boolean pForbid)
@findex SetDefaultRemoteState

This function changes the default remote control status for player
@code{pRace}. This is the same function as the "remote..default" command
processor command.

When the second parameter is True, remote control will be forbidden by
default; when it is False, control will be enabled.

@node DefaultRemoteState,  , SetDefaultRemoteState, Remote Control Interface
@subsection Boolean DefaultRemoteState(RaceType_Def pRace)
@findex DefaultRemoteState

This function returns the default remote control status for race
@code{pRace}. If it returns False, this player's ships will be
remote-controllable by default, otherwise they won't.

@node Config File Reader Interface, Special Ship Function Accessors, Remote Control Interface, Function Call Interface
@section Config File Reader Interface

The config file reader interface allows application programs to parse
configuration files of the same structure as PCONFIG.SRC with a minimum of
effort. This frees programmers from having to "reinvent the wheel" and
incorporate a text-file parser into every new application.

@menu
* ConfigFileReaderEx::
* ConfigFileReader::
@end menu

@iftex
Function in this section:
@itemize @minus
@item ConfigFileReaderEx
@item ConfigFileReader
@end itemize
@end iftex


@node ConfigFileReaderEx, ConfigFileReader, Config File Reader Interface, Config File Reader Interface
@subsection void ConfigFileReaderEx(FILE *pInFile, const char *pFileName, const char *pSection, Boolean pUseDefaultSection, configAssignment_Func pAssignFunc, configError_Func pError, Boolean pContinue)
@findex ConfigFileReaderEx

This function implements a config file reader. The 'pInFile' argument
is a handle to previously-opened text file. The 'pFileName' argument gives
the name of this text file and is used only for error reporting. The
'pSection' argument is a string indicating the section name that your
program is looking for. This indicates a line of the form:

           % MYNAME

in the config file that indicates the beginning of configuration
information relevant to your program. For example, PHOST uses a name of
"PHOST" for the main config data in PCONFIG.SRC and "PCONTROL" for the
fine-grain hosting control config data.

The 'pUseDefaultSection' indicates whether or not the section name in
'pSection' is required to be found in the config file or whether a config
file without any section information will apply to your program. For
example, PHOST sets 'pUseDefauauSection' to True so that even if '% PHOST'
does not appear in the config file, the config file reader assumes the
config data applies to PHOST. If you expect your config data to reside in
the PCONFIG.SRC file, you must set 'pUseDefaultSection' to False. If you
will read a different config file, specific to your application, you may
set 'pUseDefaultSection' to True.

The 'pAssignFunc' parameter is a pointer to an assignment function with the
following prototype (defined in PHOSTPDK.H):

       Boolean AssignFunc(const char *lhs, char *rhs, const char *lInputLine)

The name 'AssignFunc' should be replaced with a function name of your own
choosing. This function should work as follows:

@itemize @bullet

@item When 'lhs' and 'rhs' are both 0 (i.e., NULL), this indicates that the
config file reader has encountered a blank line, a comment line (line beginning
with '#'), or a section line (line beginning with '%'). A copy of the input line
is given in the 'lInputLine' parameter. The assignment function is not required
to do anything (but it may, for example, copy the input line to a backup file).
For this case, the return value of the assignment function is not used.

@item When 'lhs' and 'rhs' are not 0, then 'lhs' is a pointer to string
describing the left-hand-side of an assignment and 'rhs' is a pointer
to the string describing the right-hand-side of an assignment. Once
again, 'lInputLine' is a copy of the entire input line. The return
value of the assignment function should be True if the parameters
indicate a valid assignment or False if there is an error. In the
latter case, the config file reader calls the error function 'pError'
with the name of the input file (given by 'pFileName') and the line
number at which the error occurred. The assignment function should
indicate more specific error information prior to returning False.
@end itemize

The 'pError' parameter is the name of a function with the following
prototype:

@example
    void Error(const char* format, ...)
@end example

As you see, this is just the prototype of our 'Error', 'Warning' and
'Info' functions. The 'pError' function should print an appropriate
message and return to the caller.

The 'pContinue' parameter says what to do after an error, i.e., after
the assignment function returned False. When this parameter is True,
ConfigFileReaderEx will continue parsing the file; when it is False,
it will exit by returning IO_FAILURE to the caller.

@node ConfigFileReader,  , ConfigFileReaderEx, Config File Reader Interface
@subsection void ConfigFileReader(FILE *pInFile, const char *pFileName, const char *pSection, Boolean pUseDefaultSection, configAssignment_Func pAssignFunc)
@findex ConfigFileReader

This function is available for backward compatibility and is
equivalent to calling ConfigFileReaderEx with 'Error' and 'True' in the
last two parameters.

@node Special Ship Function Accessors, Wraparound Map Functions, Config File Reader Interface, Function Call Interface
@section Special Ship Function Accessors

These functions indicate whether a given ship is capable of a special
function, such as alchemy or terraforming.

These functions come in two flavors.
@itemize @bullet
@item ShipDoesXXX(pShipId) returns true if the ship can perform the
  special function. These functions also handle hull functions assigned
  to individual ships in PHost 4.x.
@item HullDoesXXX(pHullId, pPlayerNumber) returns true if a ship of
  the given type and owner can perform the special function. This does
  not handle functions assigned to individual ships, nor does it handle
  @code{AssignTo=Ship} functions.
@end itemize
This manual only documents the ShipDoesXXX versions, the HullDoesXXX
versions are obtained by replacing @code{Ship} by @code{Hull} and using
two parameters instead of one.

@menu
* Special Ship Function Notes::
* ShipDoesAlchemy::
* ShipDoesRefinery::
* ShipHeatsTo50::
* ShipCoolsTo50::
* ShipHeatsTo100::
* ShipHeats::
* ShipCools::
* ShipCanHyperwarp::
* ShipIsGravitonic::
* ShipScansAllWormholes::
* ShipCanCloak::
* ShipDoesAdvancedRefinery::
* ShipIsGamblingShip::
* ShipIsAntiCloaking::
* ShipDoesImperialAssault::
* ShipDoesChunneling::
* ShipHasRamScoop::
* ShipDoesBioscan::
* ShipDoesFullBioscan::
* ShipHasAdvancedCloak::
* ShipHasGloryDevice::
* ShipHasHEGloryDevice::
* ShipIsUnclonable::
* ShipIsCloneableOnce::
* ShipIsUngiveable::
* ShipIsGiveableOnce::
* ShipHasLevel2Tow::
* ShipCanTow::
* ShipCanChunnelItself::
* ShipCanChunnelOthers::
* ShipCanBeChunnelMate::
* ShipIsImmuneToPlanetAttacks::
* ShipIsOreCondenser::
* ShipCanBoard::
* ShipIsImmuneToAntiCloak::
* ShipIsCrewAcademy::
* ShipCanRepairOthers::
* ShipHasFullWeaponry::
* ShipHasHardenedEngines::
* ShipIsCommander::
* ShipHasIonShield::
* ShipHasHardenedCloak::
* ShipHasAdvancedAntiCloak::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item ShipDoesAlchemy
@item ShipDoesRefinery
@item ShipHeatsTo50
@item ShipCoolsTo50
@item ShipHeatsTo100
@item ShipHeats
@item ShipCools
@item ShipCanHyperwarp
@item ShipIsGravitonic
@item ShipScansAllWormholes
@item ShipCanCloak
@item ShipDoesAdvancedRefinery
@item ShipIsGamblingShip
@item ShipIsAntiCloaking
@item ShipDoesImperialAssault
@item ShipDoesChunneling
@item ShipHasRamScoop
@item ShipDoesBioscan
@item ShipDoesFullBioscan
@item ShipHasAdvancedCloak
@item ShipHasGloryDevice
@item ShipHasHEGloryDevice
@item ShipIsUnclonable
@item ShipIsCloneableOnce
@item ShipIsUngiveable
@item ShipIsGiveableOnce
@item ShipHasLevel2Tow
@item ShipCanTow
@item ShipCanChunnelItself
@item ShipCanChunnelOthers
@item ShipCanBeChunnelMate
@item ShipIsImmuneToPlanetAttacks
@item ShipIsOreCondenser
@item ShipCanBoard
@item ShipIsImmuneToAntiCloak
@item ShipIsCrewAcademy
@item ShipCanRepairOthers
@item ShipHasFullWeaponry
@item ShipHasHardenedEngines
@item ShipIsCommander
@item ShipHasIonShield
@item ShipHasHardenedCloak
@item ShipHasAdvancedAntiCloak
@end itemize
@end iftex


@node Special Ship Function Notes, ShipDoesAlchemy, Special Ship Function Accessors, Special Ship Function Accessors
@subsection Special Ship Function Notes

The current (21/May/2005) behaviour of special ship function handling
deserves some notes.

The PDK aims to work with any (P)Host version. Recent changes in PHost
make this task a bit harder than before.

PHost 4.0i introduces a few new hull functions, many of which replace
old ship abilities that were derived otherwise. The PDK comes with the
same defaults as PHost 4.0i, i.e. the Super Star Destroyer will be
immune to planet attacks by default. If your @code{hullfunc.txt} gave
the Imperial Assault ability to other ships, those will not be
considered immune to planet attacks, even if you use a PHost version
(3.x, or earlier 4.x) which considers them immune.

That PHost version also introduced new syntax for @code{Hull} and
@code{RacesAllowed} / @code{PlayersAllowed} lines. For example, the
"Allowed" directives are now cumulative. The PDK uses the new
definition.

Despite these differences, it is expected that the PDK works correctly
with all current ship lists. A version dependency could probably be
implemented, but so far has been left out for simplicity.

Another limitation is that the PDK cannot currently modify per-ship
functions or add new level-limited functions. This would in theory be
possible, but so far has not been implemented yet. PHost has an
interface for AUXHOST1 addons to add/remove functions, which should
suffice for most cases (read @code{hullfunc.html} about the file
@code{auxcmds.txt} and the Host-Only Commands).

@node ShipDoesAlchemy, ShipDoesRefinery, Special Ship Function Notes, Special Ship Function Accessors
@subsection Boolean ShipDoesAlchemy(Uns16 pShipNr)
@findex ShipDoesAlchemy
@findex HullDoesAlchemy

This routine returns True if the given ship is an alchemy ship, i.e. has
the @code{Alchemy} function.

@node ShipDoesRefinery, ShipHeatsTo50, ShipDoesAlchemy, Special Ship Function Accessors
@subsection Boolean ShipDoesRefinery(Uns16 pShipNr)
@findex ShipDoesRefinery
@findex HullDoesRefinery

This routine returns True if the given ship is a neutronic refinery
ship, i.e. has the @code{Refinery} function.

@node ShipHeatsTo50, ShipCoolsTo50, ShipDoesRefinery, Special Ship Function Accessors
@subsection Boolean ShipHeatsTo50(Uns16 pShipNr)
@findex ShipHeatsTo50
@findex HullHeatsTo50

This routine returns True if the given ship is a terraformer that warms
planets to 50 degrees, i.e. has the @code{HeatsTo50} function.

@node ShipCoolsTo50, ShipHeatsTo100, ShipHeatsTo50, Special Ship Function Accessors
@subsection Boolean ShipCoolsTo50(Uns16 pShipNr)
@findex ShipCoolsTo50
@findex HullCoolsTo50

This routine returns True if the given ship is a terraformer that cools
planets to 50 degrees, i.e. has the @code{CoolsTo50} function.

@node ShipHeatsTo100, ShipHeats, ShipCoolsTo50, Special Ship Function Accessors
@subsection Boolean ShipHeatsTo100(Uns16 pShipNr)
@findex ShipHeatsTo100
@findex HullHeatsTo100

This routine returns True if the given ship is a terraformer that heats
planets to 100 degrees, i.e. has the @code{HeatsTo100} function.

@node ShipHeats, ShipCools, ShipHeatsTo100, Special Ship Function Accessors
@subsection Boolean ShipHeats(Uns16 pShipNr)
@findex ShipHeats
@findex HullHeats

This routine returns True if the given ship is a terraformer that warms
planets, i.e. has the @code{HeatsTo50} or @code{HeatsTo100} function.

@node ShipCools, ShipCanHyperwarp, ShipHeats, Special Ship Function Accessors
@subsection Boolean ShipCools(Uns16 pShipNr)
@findex ShipCools
@findex HullCools

This routine returns True if the given ship is a terraformer that cools
planets, i.e. has the @code{CoolsTo50} function.

@node ShipCanHyperwarp, ShipIsGravitonic, ShipCools, Special Ship Function Accessors
@subsection Boolean ShipCanHyperwarp(Uns16 pShipNr)
@findex ShipCanHyperwarp
@findex HullCanHyperwarp

This routine returns True if the given ship has hyperwarp capability
(@code{Hyperdrive}).

@node ShipIsGravitonic, ShipScansAllWormholes, ShipCanHyperwarp, Special Ship Function Accessors
@subsection Boolean ShipIsGravitonic(Uns16 pShipNr)
@findex ShipIsGravitonic
@findex HullIsGravitonic

This routine returns True if the given ship has gravitonic capability
(@code{Gravitonic}).

@node ShipScansAllWormholes, ShipCanCloak, ShipIsGravitonic, Special Ship Function Accessors
@subsection Boolean ShipScansAllWormholes(Uns16 pShipNr)
@findex ShipScansAllWormholes
@findex HullScansAllWormholes

This routine returns True if the given ship has advanced wormhole scanning
equipment and can scan all detectable wormholes in a single turn, i.e. the
@code{ScansAllWormholes} function.

@node ShipCanCloak, ShipDoesAdvancedRefinery, ShipScansAllWormholes, Special Ship Function Accessors
@subsection Boolean ShipCanCloak(Uns16 pShipNr)
@findex ShipCanCloak
@findex HullCanCloak

This routine returns True if the given ship is capable of cloaking, i.e.
has the @code{Cloak}, @code{AdvancedCloak}, or @code{HardenedCloak} ability.

@node ShipDoesAdvancedRefinery, ShipIsGamblingShip, ShipCanCloak, Special Ship Function Accessors
@subsection Boolean ShipDoesAdvancedRefinery(Uns16 pShipNr)
@findex ShipDoesAdvancedRefinery
@findex HullDoesAdvancedRefinery

This routine returns True if the given ship is capable of advanced
refinery (such as for the Aries Class ship), i.e. it has the
@code{AdvancedRefinery} function.

@node ShipIsGamblingShip, ShipIsAntiCloaking, ShipDoesAdvancedRefinery, Special Ship Function Accessors
@subsection Boolean ShipIsGamblingShip(Uns16 pShipNr)
@findex ShipIsGamblingShip
@findex HullIsGamblingShip

This routine returns True if the given ship is capable of generating
megacredits for clans that are on board (from gambling revenue), i.e.
the @code{Gambling} ability.

@node ShipIsAntiCloaking, ShipDoesImperialAssault, ShipIsGamblingShip, Special Ship Function Accessors
@subsection Boolean ShipIsAntiCloaking(Uns16 pShipNr)
@findex ShipIsAntiCloaking
@findex HullIsAntiCloaking

This routine returns True if the given ship emits tachyon pulses that
uncloak nearby ships, i.e. it has the @code{AntiCloak} or
@code{AdvancedAntiCloak} ability.

@node ShipDoesImperialAssault, ShipDoesChunneling, ShipIsAntiCloaking, Special Ship Function Accessors
@subsection Boolean ShipDoesImperialAssault(Uns16 pShipNr)
@findex ShipDoesImperialAssault
@findex HullDoesImperialAssault

This routine returns True if the given ship is capable of performing the
Imperial Assault mission, i.e. it has the @code{ImperialAssault}
function.

@node ShipDoesChunneling, ShipHasRamScoop, ShipDoesImperialAssault, Special Ship Function Accessors
@subsection Boolean ShipDoesChunneling(Uns16 pShipNr)
@findex ShipDoesChunneling
@findex HullDoesChunneling

This routine returns True if the given ship is able to perform
chunneling, i.e. it has the @code{Chunneling} ability.

@node ShipHasRamScoop, ShipDoesBioscan, ShipDoesChunneling, Special Ship Function Accessors
@subsection Boolean ShipHasRamScoop(Uns16 pShipNr)
@findex ShipHasRamScoop
@findex HullHasRamScoop

This routine returns True if the given ship is outfitted with a fuel
ramscoop and can create fuel as it travels through space, i.e. it has
the @code{Ramscoop} function.

@node ShipDoesBioscan, ShipDoesFullBioscan, ShipHasRamScoop, Special Ship Function Accessors
@subsection Boolean ShipDoesBioscan(Uns16 pShipNr)
@findex ShipDoesBioscan
@findex HullDoesBioscan

This routine returns True if the given ship is able to perform
Bioscanning (@code{Bioscan} or @code{FullBioscan} function).

@node ShipDoesFullBioscan, ShipHasAdvancedCloak, ShipDoesBioscan, Special Ship Function Accessors
@subsection Boolean ShipDoesFullBioscan(Uns16 pShipNr)
@findex ShipDoesFullBioscan
@findex HullDoesFullBioscan

This routine returns True if the given ship can Bioscan all planets within
range, i.e. it has the @code{FullBioscan} function.

@node ShipHasAdvancedCloak, ShipHasGloryDevice, ShipDoesFullBioscan, Special Ship Function Accessors
@subsection Boolean ShipHasAdvancedCloak(Uns16 pShipNr)
@findex ShipHasAdvancedCloak
@findex HullHasAdvancedCloak

This routine returns True if the given ship has a cloaking device that
requires no fuel to operate, i.e. it has the @code{AdvancedCloak} function.

@node ShipHasGloryDevice, ShipHasHEGloryDevice, ShipHasAdvancedCloak, Special Ship Function Accessors
@subsection Boolean ShipHasGloryDevice(Uns16 pShipNr)
@findex ShipHasGloryDevice
@findex HullHasGloryDevice

This routine returns True if the given ship has a "low-energy" glory
device that causes 10% of damage to own-player ships, i.e. the
@code{GloryDeviceLowDamage} function (the damage done to enemy ships is
the same as for the "high-energy" device).

@node ShipHasHEGloryDevice, ShipIsUnclonable, ShipHasGloryDevice, Special Ship Function Accessors
@subsection Boolean ShipHasHEGloryDevice(Uns16 pShipNr)
@findex ShipHasHEGloryDevice
@findex HullHasHEGloryDevice

This routine returns True if the given ship has a "high-energy" glory
device that causes 20% of damage to own-player ships, i.e. the
@code{GloryDeviceHighDamage} function (the damage done to enemy ships is
the same as for the "low-energy" device).

@node ShipIsUnclonable, ShipIsCloneableOnce, ShipHasHEGloryDevice, Special Ship Function Accessors
@subsection Boolean ShipIsUnclonable(Uns16 pShipNr)
@findex ShipIsUnclonable
@findex HullIsUnclonable

This routine returns True if the given ship is forbidden from being
cloned, i.e. it has the @code{Unclonable} ability.

@node ShipIsCloneableOnce, ShipIsUngiveable, ShipIsUnclonable, Special Ship Function Accessors
@subsection Boolean ShipIsCloneableOnce(Uns16 pShipNr)
@findex ShipIsCloneableOnce
@findex HullIsCloneableOnce

This routine returns True if the given ship is restricted to being
cloned at most once, i.e. it has the @code{CloneOnce} ability.

@node ShipIsUngiveable, ShipIsGiveableOnce, ShipIsCloneableOnce, Special Ship Function Accessors
@subsection Boolean ShipIsUngiveable(Uns16 pShipNr)
@findex ShipIsUngiveable
@findex HullIsUngiveable

This routine returns True if the given ship is forbidden from being
traded, i.e. it has the @code{Ungiveable} ability.

@node ShipIsGiveableOnce, ShipHasLevel2Tow, ShipIsUngiveable, Special Ship Function Accessors
@subsection Boolean ShipIsGiveableOnce(Uns16 pShipNr)
@findex ShipIsGiveableOnce
@findex HullIsGiveableOnce

This routine returns True if the given ship is restricted to being
traded at most once, i.e. it has the @code{GiveOnce} ability.

@node ShipHasLevel2Tow, ShipCanTow, ShipIsGiveableOnce, Special Ship Function Accessors
@subsection Boolean ShipHasLevel2Tow(Uns16 pShipNr)
@findex ShipHasLevel2Tow
@findex HullHasLevel2Tow

This routine returns True if the given ship has a "level 2" tractor
beam, i.e. the @code{Level2Tow} function.

@node ShipCanTow, ShipCanChunnelItself, ShipHasLevel2Tow, Special Ship Function Accessors
@subsection Boolean ShipCanTow(Uns16 pShip)
@findex ShipCanTow
@findex HullCanTow

This routine returns True if the given ship can tow other ships, i.e. it
has the @code{Tow} or @code{Level2Tow} function.

@node ShipCanChunnelItself, ShipCanChunnelOthers, ShipCanTow, Special Ship Function Accessors
@subsection Boolean ShipCanChunnelItself(Uns16 pShip)
@findex ShipCanChunnelItself
@findex HullCanChunnelItself

Returns True if the given ship can initiate a chunnel to move itself
elsewhere, i.e. it has the @code{ChunnelSelf} or @code{Chunneling}
ability.

@node ShipCanChunnelOthers, ShipCanBeChunnelMate, ShipCanChunnelItself, Special Ship Function Accessors
@subsection Boolean ShipCanChunnelOthers(Uns16 pShip)
@findex ShipCanChunnelOthers
@findex HullCanChunnelOthers

Returns True if the given ship can initiate a chunnel to move all ships
at this location elsewhere, i.e. it has the @code{ChunnelOthers} or
@code{Chunneling} ability.

@node ShipCanBeChunnelMate, ShipIsImmuneToPlanetAttacks, ShipCanChunnelOthers, Special Ship Function Accessors
@subsection Boolean ShipCanBeChunnelMate(Uns16 pShip)
@findex ShipCanBeChunnelMate
@findex HullCanBeChunnelMate

Returns True if the given ship can operate as a chunnel mate for another
ship initiating a chunnel, i.e. it has the @code{ChunnelTarget} or
@code{Chunneling} ability.

@node ShipIsImmuneToPlanetAttacks, ShipIsOreCondenser, ShipCanBeChunnelMate, Special Ship Function Accessors
@subsection Boolean ShipIsImmuneToPlanetAttacks(Uns16 pShip)
@findex ShipIsImmuneToPlanetAttacks
@findex HullIsImmuneToPlanetAttacks

Returns True if the given ship is immune to planets that try to attack
it using @code{ATT} or @code{NUK} (@code{PlanetImmunity} ability).

@node ShipIsOreCondenser, ShipCanBoard, ShipIsImmuneToPlanetAttacks, Special Ship Function Accessors
@subsection Boolean ShipIsOreCondenser(Uns16 pShip)
@findex ShipIsOreCondenser
@findex HullIsOreCondenser

Returns True if the given ship can increase a planet's ore density
(@code{OreCondenser} ability).

@node ShipCanBoard, ShipIsImmuneToAntiCloak, ShipIsOreCondenser, Special Ship Function Accessors
@subsection Boolean ShipCanBoard(Uns16 pShip)
@findex ShipCanBoard
@findex HullCanBoard

Returns True if the given ship can board ("tow-capture") other ships,
i.e. it has the @code{Boarding} ability.

@node ShipIsImmuneToAntiCloak, ShipIsCrewAcademy, ShipCanBoard, Special Ship Function Accessors
@subsection Boolean ShipIsImmuneToAntiCloak(Uns16 pShip)
@findex ShipIsImmuneToAntiCloak
@findex HullIsImmuneToAntiCloak

Returns True if the given ship is not de-cloaked by AntiCloak ships,
i.e. it has the @code{AntiCloakImmunity} ability.

@node ShipIsCrewAcademy, ShipCanRepairOthers, ShipIsImmuneToAntiCloak, Special Ship Function Accessors
@subsection Boolean ShipIsCrewAcademy(Uns16 pShip)
@findex ShipIsCrewAcademy
@findex HullIsCrewAcademy

Returns True if the given ship can educate crew and give it to other
ships, i.e. it has the @code{Academy} ability.

@node ShipCanRepairOthers, ShipHasFullWeaponry, ShipIsCrewAcademy, Special Ship Function Accessors
@subsection Boolean ShipCanRepairOthers(Uns16 pShip)
@findex ShipCanRepairOthers
@findex HullCanRepairOthers

Returns True if the given ship can repair other ships using the "Repair"
mission, i.e. it has the @code{Repairs} hull function.

@node ShipHasFullWeaponry, ShipHasHardenedEngines, ShipCanRepairOthers, Special Ship Function Accessors
@subsection Boolean ShipHasFullWeaponry(Uns16 pShip)
@findex ShipHasFullWeaponry
@findex HullHasFullWeaponry

Returns True if the given ship can use its full weaponry even if it is
damaged (@code{FullWeaponry} ability).

@node ShipHasHardenedEngines, ShipIsCommander, ShipHasFullWeaponry, Special Ship Function Accessors
@subsection Boolean ShipHasHardenedEngines(Uns16 pShip)
@findex ShipHasHardenedEngines
@findex HullHasHardenedEngines

Returns True if the ship has hardened engines that do not slow down when
damaged (@code{HardenedEngines} ability).

@node ShipIsCommander, ShipHasIonShield, ShipHasHardenedEngines, Special Ship Function Accessors
@subsection Boolean ShipIsCommander(Uns16 pShip)
@findex ShipIsCommander
@findex HullIsCommander

Returns true if the ship is a Commander ship.

@node ShipHasIonShield, ShipHasHardenedCloak, ShipIsCommander, Special Ship Function Accessors
@subsection Boolean ShipHasIonShield(Uns16 pShip)
@findex ShipHasIonShield
@findex HullHasIonShield

Returns true if the ship has an ion shield that protects it from ion storms.

@node ShipHasHardenedCloak, ShipHasAdvancedAntiCloak, ShipHasIonShield, Special Ship Function Accessors
@subsection Boolean ShipHasHardenedCloak(Uns16 pShip)
@findex ShipHasHardenedCloak
@findex HullHasHardenedCloak

Returns true if the ship has a hardened cloaking device that doesn't fail when
it gets damaged.

@node ShipHasAdvancedAntiCloak,  , ShipHasHardenedCloak, Special Ship Function Accessors
@subsection Boolean ShipHasAdvancedAntiCloak(Uns16 pShip)
@findex ShipHasAdvancedAntiCloak
@findex HullHasAdvancedAntiCloak

Returns true if the ship has an advanced Anti-Cloak ability, which also
detects ships that are immune to the normal Anti-Cloak.

@node Wraparound Map Functions, UTILx.DAT Functions, Special Ship Function Accessors, Function Call Interface
@section Wraparound Map Functions

The following functions support the wraparound map feature of PHOST 3. They
are intended to simplify distance and position calculations in your own
program when a wraparound map is in effect. Note that all of these routines
depend upon the gPconfigInfo->AllowWraparoundMap setting hence a prior call
to ReadHostData() must have been performed.

@menu
* DistanceSquared::
* Distance::
* IsDistanceLTRadius::
* WrapMapX::
* WrapMapY::
* WrapDistX::
* WrapDistY::
* IsPointOnWrapMap::
* RewrapShipsAndMines::
@end menu

@iftex
Functions in this section:
@itemize @minus
@item DistanceSquared
@item Distance
@item IsDistanceLTRadius
@item WrapMapX
@item WrapMapY
@item WrapDistX
@item WrapDistY
@item IsPointOnWrapMap
@item RewrapShipsAndMines
@end itemize
@end iftex

@node DistanceSquared, Distance, Wraparound Map Functions, Wraparound Map Functions
@subsection Int32 DistanceSquared(Int16 pX1, Int16 pY1, Int16 pX2, Int16 pY2)
@findex DistanceSquared

This functions returns the squared distance between the points (pX1,pY1)
and (pX2,pY2). The wraparound region is taken into account. For example, if
the wraparound region is the usual square universe (1000,1000)-(3000,3000)
then DistanceSquared(1001,1001,2999,2999) is 8. If the AllowWraparoundMap
config setting is False, then this routine would return 7,984,008.

@node Distance, IsDistanceLTRadius, DistanceSquared, Wraparound Map Functions
@subsection double Distance(Int16 pX1, Int16 pY1, Int16 pX2, Int16 pY2)
@findex Distance

This function simply returns the square root of DistanceSquared() as a
floating point quantity.

@node IsDistanceLTRadius, WrapMapX, Distance, Wraparound Map Functions
@subsection Boolean IsDistanceLTRadius(Int16 pX1, Int16 pY1, Int16 pX2, Int16 pY2, Uns32 pRadius)
@findex IsDistanceLTRadius

This function can be used to test whether two objects are within a certain
distance of each other without the floating-point overhead of the
Distance() function. The function returns True if the distance between
points (pX1,pY1) and (pX2,pY2) is less than or equal to the value of
'pRadius'. No floating point math is used. Once again, the wraparound map
is taken into account.

@node WrapMapX, WrapMapY, IsDistanceLTRadius, Wraparound Map Functions
@subsection Int16 WrapMapX(Int16 pX)
@findex WrapMapX

This function returns the wrapped value of the X-coordinate given by 'pX'.
For example, if the wraparound region is the usual square universe
(1000,1000)-(3000,3000) then WrapMapX(3005) would return 1005. If 'pX' is
already in the wraparound region (or wraparound maps are not in effect),
then WrapMapX simply returns 'pX' itself.

@node WrapMapY, WrapDistX, WrapMapX, Wraparound Map Functions
@subsection Int16 WrapMapY(Int16 pY)
@findex WrapMapY

This function returns the wrapped value of the Y-coordinate given by 'pY'.

@node WrapDistX, WrapDistY, WrapMapY, Wraparound Map Functions
@subsection Int16 WrapDistX(Int16 pX)
@findex WrapDistX

This function return the wrapped value of the horizontal distance given by
'pX'. For example, if the wraparound region is the usual square universe
(1000,1000)-(3000,3000) then WrapDistX(2500) would return -500. In other
words, it is shorter to go 500 LY to the left than 2500 LY to the right on
this wraparound map.

@node WrapDistY, IsPointOnWrapMap, WrapDistX, Wraparound Map Functions
@subsection Int16 WrapDistY(Int16 pY)
@findex WrapDistY

This function returns the wrapped value of the vertical distance given by
'pY'.

@node IsPointOnWrapMap, RewrapShipsAndMines, WrapDistY, Wraparound Map Functions
@subsection Boolean IsPointOnWrapMap(Int16 pX, Int16 pY)
@findex IsPointOnWrapMap

This function returns True if the point (pX,pY) is inside the wraparound
region, or False otherwise. This function always returns True if wraparound
maps are not enabled.

@node RewrapShipsAndMines,  , IsPointOnWrapMap, Wraparound Map Functions
@subsection void RewrapShipsAndMines(void)
@findex RewrapShipsAndMines

This function iterates over all ships and minefields in the game and
adjusts their position (if necessary) so that they lie inside the
wraparound region. This function may be useful if your program moves the
position of ships and/or mines to locations possibly outside the wraparound
region. Note that PHOST automatically calls an equivalent function any time
an external (AUXHOST) program returns control to PHOST.

@node UTILx.DAT Functions, Score Functions, Wraparound Map Functions, Function Call Interface
@section UTILx.DAT Functions (new - 4.2)

The following functions allow programs to write UTILx.DAT records.

@menu
* SetUtilMode::
* PutUtilRecordSimple::
* PutUtilRecordStruct::
* PutUtilRecord::
* PutUtilFileTransfer::
* PutUtilExplosion::            new - 4.5
* PutExplosion::                new - 4.5
@end menu

@iftex
@itemize @minus
@item SetUtilMode
@item PutUtilRecordSimple
@item PutUtilRecordStruct
@item PutUtilRecord
@item PutUtilFileTransfer
@item PutUtilExplosion (new - 4.5)
@item PutUtilExplosionAllPlayers (new - 4.5)
@item PutExplosion (new - 4.5)
@end itemize
@end iftex

@node SetUtilMode, PutUtilRecordSimple, UTILx.DAT Functions, UTILx.DAT Functions
@subsection void SetUtilMode(UtilMode_Def pDat)
@findex SetUtilMode

Defines the mode of operation for the following functions.

@itemize @minus
@item pDat = UTIL_Ext: write to UTILx.EXT. This is intended for all
add-ons that run before the host has completed (AUXHOST, PCONTROL).
This mode is the default.
@item pDat = UTIL_Dat: write to UTILx.DAT. This is used when your program
runs after the host has completed. Basically, when you use
WriteMessageToRST function, you should also use the UTIL_Dat mode,
otherwise use UTIL_Ext.
@item pDat = UTIL_Tmp: write to UTIL.TMP. This is to be used for add-ons
that replace PCONTROL stages. For example, when you write an add-on
that replaces the whole mine laying stage, the mine laying reports
should come out at the same place where PHost would have put them,
to not confuse clients. This is only supported with PHost 3.4 and
later, for older hosts, it is automatically "downgraded" to UTIL_Ext.
Please use this @emph{only} for the described scenario.
@end itemize

@node PutUtilRecordSimple, PutUtilRecordStruct, SetUtilMode, UTILx.DAT Functions
@subsection Boolean PutUtilRecordSimple(RaceType_Def pRace, Uns16 pRecordId, Uns16 pSize, void* pData)
@findex PutUtilRecordSimple

Write UTIL record, simple version. Sends a record of type 'pRecordId',
size 'pSize' to player 'pRace'. 'pData' points to the raw data.
Returns True on success, False on error.

@node PutUtilRecordStruct, PutUtilRecord, PutUtilRecordSimple, UTILx.DAT Functions
@subsection Boolean PutUtilRecordStruct(RaceType_Def pRace, Uns16 pRecordId, void* pData, const DOSConvertElement *pStruct, Uns16 pNumElements)
@findex PutUtilRecordStruct

Write UTIL record, as defined by a structure. 'pData' points to a C
structure whose layout is defined by 'pStruct' and 'pNumElements'
(see "Cross-Platform Portability, Part II"). Otherwise, behaves like
'PutUtilRecordSimple'.

@node PutUtilRecord, PutUtilFileTransfer, PutUtilRecordStruct, UTILx.DAT Functions
@subsection Boolean PutUtilRecord(RaceType_Def pRace, Uns16 pRecordId, Uns16 pCount, Uns16* pSizes, void** pData);
@findex PutUtilRecord

Write UTIL record. Like 'PutUtilRecordSimple', but this one can gather
data from multiple places. 'pSizes' points to an array of sizes,
'pData' points to an array of data pointers. For example, to write
a record that consists of two blocks, you can do:

@example
     Uns16 lSizes[2] = @{ size1, size2 @};
     void* lData[2] = @{ &data1, &data2 @};
     PutUtilRecord(pRace, pRecordId, 2, lSizes, lData);
@end example

@node PutUtilFileTransfer, PutUtilExplosion, PutUtilRecord, UTILx.DAT Functions
@subsection Boolean PutUtilFileTransfer(RaceType_Def pRace, const char* pName, Boolean pText, Uns16 pSize, void* pData);
@findex PutUtilFileTransfer

Write UTIL file transfer. This writes a type 34 record (file transfer).
'pName' is the name of the file as it will be embedded in the UTIL.DAT
file. 'pText' is True if this is a text file, False for binary files.
'pSize' and 'pData' define the file contents.

Note that this function will not attempt to open the file 'pName': this
is just the name the client will see. You have to read the file and
supply its data and size to this function.

@node PutUtilExplosion, PutExplosion, PutUtilFileTransfer, UTILx.DAT Functions
@subsection Boolean PutUtilExplosion(RaceType_Def pRace, Uns16 pX, Uns16 pY, const char* pName, Uns16 pId);
@findex PutUtilExplosion
@findex PutUtilExplosionAllPlayers

Writes a explosion record into the specified player's util.dat file.
@code{PutUtilExplosionAllPlayers} will write into all active players'
files.

The parameters @code{pX}, @code{pY} and @code{pId} are mandatory.
@code{pName} is the name of the ship which exploded. This parameter can
be null; in this case, the util.dat record is written without the Name
field (pre-3.4 format).

You should also use @ref{PutExplosion} to place an explosion marker in
Winplan's starchart.

@node PutExplosion,  , PutUtilExplosion, UTILx.DAT Functions
@subsection Boolean PutExplosion(Uns16 pX, Uns16 pY)
@findex PutExplosion

This function places an explosion marker at @code{pX,pY} on all players'
starcharts. PHost itself uses this function for mine explosions and
ships blown up in combat.

@itemize @minus
@item This function only works with PHost 4.0k and later. Previous
versions do not have a possibility to add these markers from the outside.
@item Only Winplan players will receive these markers with their result.
There is space for 50 markers, excess markers will be ignored.
@item This marker will always be sent to all players.
@end itemize

To address the above shortcomings, you should always send a regular
message (@ref{WriteAUXHOSTMessage}) and a util.dat record
(@ref{PutUtilExplosion}) as well.

This function returns @code{True} if it successfully delivered the
explosion into the @code{auxdata.hst} file (first two conditions from
above). It returns @code{False} if the PHost version in use does not
support this feature, or if all slots have been used up.

@node Score Functions, FCode Functions, UTILx.DAT Functions, Function Call Interface
@section Score Functions (new - 4.3)

The following functions allow programs to evaluate scores for
ships, planets, bases and mines. Default settings are compatible
with PTSCORE v1.4 program. THost scores can be evaluated too.
Basic global count functions are implemented.

@menu
* PointsFor::
* PutPointsFor::
* PointsForFighter::
* PointsForBaseDefensePost::
* PointsForMineralMine::
* PointsForFactory::
* PointsForDefencePost::
* PointsForBaseOnPlanet::
* PointsForHull::
* PointsForEngine::
* PointsForBeam::
* PointsForTube::
* PointsForTorpedo::
* PointsForShipParts::
* PointsForShipCargo::
* PointsForShipAmmo::
* PointsForPlanetStructures::
* PointsForPlanetMinerals::
* PointsForBaseTechLevels::
* PointsForBaseDefense::
* PointsForBaseStorage::
* PointsForBaseTorpedos::
* PointsForShip::
* PointsForPlanet::
* PointsForBase::
* PointsForMinefield::
* RaceScoreForShips::
* RaceScoreForPlanets::
* RaceScoreForBases::
* RaceScoreForMinefields::
* RaceShipsNumber::
* RacePlanetsNumber::
* RaceBasesNumber::
* RaceFightersNumber::
* RaceTorpedosNumber::
* RaceBeamsNumber::
* RaceFactoriesNumber::
* RaceMineralMinesNumber::
* RaceDefencePostsNumber::
* RaceBaseDefenceNumber::
* RaceCargoNumber::
* RaceMinefieldUnitsNumber::
* MineralsForFighter::
* MineralsForBaseDefensePost::
* MineralsForMineralMine::
* MineralsForFactory::
* MineralsForDefencePost::
* MineralsForBaseOnPlanet::
* MineralsForHull::
* MineralsForEngine::
* MineralsForBeam::
* MineralsForTube::
* MineralsForTorpedo::
* MineralsForShipParts::
* MineralsForShipCargo::
* MineralsForShipAmmo::
* MineralsForPlanetStructures::
* MineralsForPlanetMinerals::
* MineralsForBaseTechLevels::
* MineralsForBaseDefense::
* MineralsForBaseStorage::
* MineralsForBaseTorpedos::
* MineralsForShip::
* MineralsForPlanet::
* MineralsForBase::
* MineralsForMinefield::
* RaceMineralsForShips::
* RaceMineralsForPlanets::
* RaceMineralsForBases::
* RaceMineralsForMinefields::
@end menu

@iftex
@itemize @minus
@item PointsFor
@item PutPointsFor
@item PointsForFighter
@item PointsForBaseDefensePost
@item PointsForMineralMine
@item PointsForFactory
@item PointsForDefencePost
@item PointsForBaseOnPlanet
@item PointsForHull
@item PointsForEngine
@item PointsForBeam
@item PointsForTube
@item PointsForTorpedo
@item PointsForShipParts
@item PointsForShipCargo
@item PointsForShipAmmo
@item PointsForPlanetStructures
@item PointsForPlanetMinerals
@item PointsForBaseTechLevels
@item PointsForBaseDefense
@item PointsForBaseStorage
@item PointsForBaseTorpedos
@item PointsForShip
@item PointsForPlanet
@item PointsForBase
@item PointsForMinefield
@item RaceScoreForShips
@item RaceScoreForPlanets
@item RaceScoreForBases
@item RaceScoreForMinefields
@item RaceShipsNumber
@item RacePlanetsNumber
@item RaceBasesNumber
@item RaceFightersNumber
@item RaceTorpedosNumber
@item RaceBeamsNumber
@item RaceFactoriesNumber
@item RaceMineralMinesNumber
@item RaceDefencePostsNumber
@item RaceBaseDefenceNumber
@item RaceCargoNumber
@item RaceMinefieldUnitsNumber
@item MineralsForFighter
@item MineralsForBaseDefensePost
@item MineralsForMineralMine
@item MineralsForFactory
@item MineralsForDefencePost
@item MineralsForBaseOnPlanet
@item MineralsForHull
@item MineralsForEngine
@item MineralsForBeam
@item MineralsForTube
@item MineralsForTorpedo
@item MineralsForShipParts
@item MineralsForShipCargo
@item MineralsForShipAmmo
@item MineralsForPlanetStructures
@item MineralsForPlanetMinerals
@item MineralsForBaseTechLevels
@item MineralsForBaseDefense
@item MineralsForBaseStorage
@item MineralsForBaseTorpedos
@item MineralsForShip
@item MineralsForPlanet
@item MineralsForBase
@item MineralsForMinefield
@item RaceMineralsForShips
@item RaceMineralsForPlanets
@item RaceMineralsForBases
@item RaceMineralsForMinefields
@end itemize
@end iftex

@node PointsFor, PutPointsFor, Score Functions, Score Functions
@subsection Uns32 PointsFor(CargoType_Def lCargo)
@findex PointsFor

This function returns points for given material.

@node PutPointsFor, PointsForFighter, PointsFor, Score Functions
@subsection void PutPointsFor(CargoType_Def lCargo, Uns16 lPoints)
@findex PutPointsFor

This function sets points for given material.

@node PointsForFighter, PointsForBaseDefensePost, PutPointsFor, Score Functions
@subsection Uns32 PointsForFighter(void)
@findex PointsForFighter

This function returns points for one fighter, assuming fighter cost is
3 tritanium, 2 duranium and 5 supplies.

@node PointsForBaseDefensePost, PointsForMineralMine, PointsForFighter, Score Functions
@subsection Uns32 PointsForBaseDefensePost(void)
@findex PointsForBaseDefensePost

This function returns points for one base defense, assuming base defense cost is
1 duranium and 10 credits.

@node PointsForMineralMine, PointsForFactory, PointsForBaseDefensePost, Score Functions
@subsection Uns32 PointsForMineralMine(void)
@findex PointsForMineralMine

This function returns points for one mineral mine, assuming mineral mine cost is
1 supply and 4 credits.

@node PointsForFactory, PointsForDefencePost, PointsForMineralMine, Score Functions
@subsection Uns32 PointsForFactory(void)
@findex PointsForFactory

This function returns points for one factory, assuming factory cost is
1 supply and 3 credits.

@node PointsForDefencePost, PointsForBaseOnPlanet, PointsForFactory, Score Functions
@subsection Uns32 PointsForDefencePost(void)
@findex PointsForDefencePost

This function returns points for one planetary defense post, assuming defense post cost is
1 supply and 10 credits.

@node PointsForBaseOnPlanet, PointsForHull, PointsForDefencePost, Score Functions
@subsection Uns32 PointsForBaseOnPlanet(void)
@findex PointsForBaseOnPlanet

This function returns points for base on planet, assuming base build cost is
402 tritanium, 120 duranium, 340 molybdenum and 900 credits.

@node PointsForHull, PointsForEngine, PointsForBaseOnPlanet, Score Functions
@subsection Uns32 PointsForHull(Uns16 lHullNr)
@findex PointsForHull

This function returns points for hull, assuming normal materials and credits build cost
for a given hull. The lHullNr parameter should be in range 1 to HULL_NR.

@node PointsForEngine, PointsForBeam, PointsForHull, Score Functions
@subsection Uns32 PointsForEngine(Uns16 lEngNr)
@findex PointsForEngine

This function returns points for one engine, assuming normal materials and credits build cost
for a given engine. The lEngNr parameter should be in range 1 to ENGINE_NR.

@node PointsForBeam, PointsForTube, PointsForEngine, Score Functions
@subsection Uns32 PointsForBeam(Uns16 lBeamNr)
@findex PointsForBeam

This function returns points for one beam, assuming normal materials and credits build cost
for a given beam. The lBeamNr parameter should be in range 1 to BEAM_NR.

@node PointsForTube, PointsForTorpedo, PointsForBeam, Score Functions
@subsection Uns32 PointsForTube(Uns16 lTorpNr)
@findex PointsForTube

This function returns points for one torpedo tube, assuming normal materials and
credits build cost for a given tube. The lTorpNr parameter should be in range 1 to TORP_NR.

@node PointsForTorpedo, PointsForShipParts, PointsForTube, Score Functions
@subsection Uns32 PointsForTorpedo(Uns16 lTorpNr)
@findex PointsForTorpedo

This function returns points for one torpedo, assuming normal materials and
credits build cost for a given torpedo. The lTorpNr parameter should be in range 1 to TORP_NR.

@node PointsForShipParts, PointsForShipCargo, PointsForTorpedo, Score Functions
@subsection Uns32 PointsForShipParts(Uns16 sID)
@findex PointsForShipParts

This function returns points for ship, assuming normal build costs for
all ship equipment and hull. Hull, engines, beams and torpedo launchers costs
are summed.

@node PointsForShipCargo, PointsForShipAmmo, PointsForShipParts, Score Functions
@subsection Uns32 PointsForShipCargo(Uns16 sID)
@findex PointsForShipCargo

This function returns points for ship cargo.

@node PointsForShipAmmo, PointsForPlanetStructures, PointsForShipCargo, Score Functions
@subsection Uns32 PointsForShipAmmo(Uns16 sID)
@findex PointsForShipAmmo

This function returns points for ship ammunition. If ship carries fighters,
fighters are counted. For ships having torpedo tubes, torpedos are counted.

@node PointsForPlanetStructures, PointsForPlanetMinerals, PointsForShipAmmo, Score Functions
@subsection Uns32 PointsForPlanetStructures(Uns16 pID)
@findex PointsForPlanetStructures

This function returns points for given planet structures. All mineral mines,
factories and defense posts are counted.

@node PointsForPlanetMinerals, PointsForBaseTechLevels, PointsForPlanetStructures, Score Functions
@subsection Uns32 PointsForPlanetMinerals(Uns16 pID)
@findex PointsForPlanetMinerals

This function returns points for given planet minerals on surface.
Scores for supplies and cash on planet are added too.

@node PointsForBaseTechLevels, PointsForBaseDefense, PointsForPlanetMinerals, Score Functions
@subsection Uns32 PointsForBaseTechLevels(Uns16 bID)
@findex PointsForBaseTechLevels

This function returns points for given base tech levels.

@node PointsForBaseDefense, PointsForBaseStorage, PointsForBaseTechLevels, Score Functions
@subsection Uns32 PointsForBaseDefense(Uns16 bID)
@findex PointsForBaseDefense

This function returns points for given base defense posts and fighters.

@node PointsForBaseStorage, PointsForBaseTorpedos, PointsForBaseDefense, Score Functions
@subsection Uns32 PointsForBaseStorage(Uns16 bID)
@findex PointsForBaseStorage

This function returns points for given base stored equipment. All hulls,
engines, beams and torpedo tubes are counted.

@node PointsForBaseTorpedos, PointsForShip, PointsForBaseStorage, Score Functions
@subsection Uns32 PointsForBaseTorpedos(Uns16 bID)
@findex PointsForBaseTorpedos

This function returns points for given base stored torpedos.

@node PointsForShip, PointsForPlanet, PointsForBaseTorpedos, Score Functions
@subsection Uns32 PointsForShip(Uns16 sID, PointsType_Def CountType)
@findex PointsForShip

This function returns points for given ship. Setting CountType to USED_POINTS
makes procedure counts points only for ship parts and torpedos
(PointsForShipParts and PointsForShipTorpedos are called).
Setting CountType to UNUSED_POINTS counts only ship cargo
(PointsForShipCargo is called). ALL_POINTS sums all points.

@node PointsForPlanet, PointsForBase, PointsForShip, Score Functions
@subsection Uns32 PointsForPlanet(Uns16 pID, PointsType_Def CountType)
@findex PointsForPlanet

This function returns points for given planet. Setting CountType to USED_POINTS
makes procedure counts points only for planet structures (PointsForPlanetStructures is called).
Setting CountType to UNUSED_POINTS counts only planet cargo
(PointsForPlanetMinerals is called). ALL_POINTS sums all points.

@node PointsForBase, PointsForMinefield, PointsForPlanet, Score Functions
@subsection Uns32 PointsForBase(Uns16 bID, PointsType_Def CountType)
@findex PointsForBase

This function returns points for given base. Setting CountType to USED_POINTS
makes procedure counts points for base build cost, torpedos stored in base,
base defense system and base tech levels (PointsForBaseOnPlanet, PointsForBaseTorpedos,
PointsForBaseDefense and PointsForBaseTechLevels are called).
Setting CountType to UNUSED_POINTS counts base stored equipment. All hulls,
engines, beams and torpedo tubes are counted (PointsForBaseStorage is called).
ALL_POINTS sums all points.

@node PointsForMinefield, RaceScoreForShips, PointsForBase, Score Functions
@subsection Uns32 PointsForMinefield(Uns16 mID, PointsType_Def CountType)
@findex PointsForMinefield

This function returns points for given minefield. Setting CountType to USED_POINTS
or to ALL_POINTS gives points for minefield mID assuming that minefield was laid
using the most cheapest, in points, torpedos. Setting CountType to UNUSED_POINTS
make procedure to return zero. No race specific corrections are made.

@node RaceScoreForShips, RaceScoreForPlanets, PointsForMinefield, Score Functions
@subsection Uns32 RaceScoreForShips( RaceType_Def Race, PointsType_Def CountType, ShipsType_Def ShipsType)
@findex RaceScoreForShips

This function returns points for given race ships. Points type are controlled
by CountType parameter. ShipsType parameter can filter counted ships, so only
war ships are scored (WAR_SHIPS), freighters (FREIGHTER_SHIPS) or there is no filtering
at all (ALL_SHIPS).

@node RaceScoreForPlanets, RaceScoreForBases, RaceScoreForShips, Score Functions
@subsection Uns32 RaceScoreForPlanets( RaceType_Def Race, PointsType_Def CountType)
@findex RaceScoreForPlanets

This function returns points for given race planets. Points type are controlled
by CountType parameter.

@node RaceScoreForBases, RaceScoreForMinefields, RaceScoreForPlanets, Score Functions
@subsection Uns32 RaceScoreForBases( RaceType_Def Race, PointsType_Def CountType)
@findex RaceScoreForBases

This function returns points for given race bases. Points type are controlled
by CountType parameter.

@node RaceScoreForMinefields, RaceShipsNumber, RaceScoreForBases, Score Functions
@subsection Uns32 RaceScoreForMinefields( RaceType_Def Race, PointsType_Def CountType, Boolean RaceModify)
@findex RaceScoreForMinefields

This function returns points for given race minefields. Points type are controlled
by CountType parameter. Setting RaceModify to True makes points to be corrected by
race UnitsPerTorpRate PConfig.src parameter, so real torpedo laying costs are counted.
Making RaceModify False gives no such correction.

@node RaceShipsNumber, RacePlanetsNumber, RaceScoreForMinefields, Score Functions
@subsection Uns32 RaceShipsNumber( RaceType_Def Race, ShipsType_Def ShipsType)
@findex RaceShipsNumber

This function returns number of ships for a given race.

@node RacePlanetsNumber, RaceBasesNumber, RaceShipsNumber, Score Functions
@subsection Uns32 RacePlanetsNumber(RaceType_Def Race)
@findex RacePlanetsNumber

This function returns number of planet for a given race.

@node RaceBasesNumber, RaceFightersNumber, RacePlanetsNumber, Score Functions
@subsection Uns32 RaceBasesNumber( RaceType_Def Race)
@findex RaceBasesNumber

This function returns number of bases for a given race.

@node RaceFightersNumber, RaceTorpedosNumber, RaceBasesNumber, Score Functions
@subsection Uns32 RaceFightersNumber(RaceType_Def Race)
@findex RaceFightersNumber

This function returns total number of fighters for a given race. Fighters
from bases and ships are counted.

@node RaceTorpedosNumber, RaceBeamsNumber, RaceFightersNumber, Score Functions
@subsection Uns32 RaceTorpedosNumber(RaceType_Def Race, Uns16 TorpType)
@findex RaceTorpedosNumber

This function returns total number of torpedos of a given type for a given race.
Torpedos from bases and ships are counted.

@node RaceBeamsNumber, RaceFactoriesNumber, RaceTorpedosNumber, Score Functions
@subsection Uns32 RaceBeamsNumber(RaceType_Def Race, Uns16 BeamType)
@findex RaceBeamsNumber

This function returns total number of beams of a given type for a given race.
Beams from bases storage and beams mounted on ships are counted.

@node RaceFactoriesNumber, RaceMineralMinesNumber, RaceBeamsNumber, Score Functions
@subsection Uns32 RaceFactoriesNumber(RaceType_Def Race)
@findex RaceFactoriesNumber

This function returns total number of factories for a given race.

@node RaceMineralMinesNumber, RaceDefencePostsNumber, RaceFactoriesNumber, Score Functions
@subsection Uns32 RaceMineralMinesNumber(RaceType_Def Race)
@findex RaceMineralMinesNumber

This function returns total number of mineral mines for a given race.

@node RaceDefencePostsNumber, RaceBaseDefenceNumber, RaceMineralMinesNumber, Score Functions
@subsection Uns32 RaceDefencePostsNumber(RaceType_Def Race)
@findex RaceDefencePostsNumber

This function returns total number of planetary defense posts for a given race.

@node RaceBaseDefenceNumber, RaceCargoNumber, RaceDefencePostsNumber, Score Functions
@subsection Uns32 RaceBaseDefenceNumber(RaceType_Def Race)
@findex RaceBaseDefenceNumber

This function returns total number of base defense posts for a given race.

@node RaceCargoNumber, RaceMinefieldUnitsNumber, RaceBaseDefenceNumber, Score Functions
@subsection Uns32 RaceCargoNumber(RaceType_Def Race,CargoType_Def CargoType)
@findex RaceCargoNumber

This function returns total number of cargo of a given type for a given race.
Cargo from planets and ships are counted.

@node RaceMinefieldUnitsNumber, MineralsForFighter, RaceCargoNumber, Score Functions
@subsection Uns32 RaceMinefieldUnitsNumber(RaceType_Def Race)
@findex RaceMinefieldUnitsNumber

This function returns total number of laid minefields units for a given race.
No race specific correction are made.

@node MineralsForFighter, MineralsForBaseDefensePost, RaceMinefieldUnitsNumber, Score Functions
@subsection Uns32 MineralsForFighter(CargoType_Def CargoType)
@findex MineralsForFighter

This function returns minerals for one fighter, assuming fighter cost is
3 tritanium, 2 duranium and 5 supplies.

@node MineralsForBaseDefensePost, MineralsForMineralMine, MineralsForFighter, Score Functions
@subsection Uns32 MineralsForBaseDefensePost(CargoType_Def CargoType)
@findex MineralsForBaseDefensePost

This function returns minerals for one base defense, assuming base defense cost is
1 duranium and 10 credits.

@node MineralsForMineralMine, MineralsForFactory, MineralsForBaseDefensePost, Score Functions
@subsection Uns32 MineralsForMineralMine(CargoType_Def CargoType)
@findex MineralsForMineralMine

This function returns minerals for one mineral mine, assuming mineral mine cost is
1 supply and 4 credits.

@node MineralsForFactory, MineralsForDefencePost, MineralsForMineralMine, Score Functions
@subsection Uns32 MineralsForFactory(CargoType_Def CargoType)
@findex MineralsForFactory

This function returns minerals for one factory, assuming factory cost is
1 supply and 3 credits.

@node MineralsForDefencePost, MineralsForBaseOnPlanet, MineralsForFactory, Score Functions
@subsection Uns32 MineralsForDefencePost(CargoType_Def CargoType)
@findex MineralsForDefencePost

This function returns minerals for one planetary defense post, assuming defense post cost is
1 supply and 10 credits.

@node MineralsForBaseOnPlanet, MineralsForHull, MineralsForDefencePost, Score Functions
@subsection Uns32 MineralsForBaseOnPlanet(CargoType_Def CargoType)
@findex MineralsForBaseOnPlanet

This function returns minerals for base on planet, assuming base build cost is
402 tritanium, 120 duranium, 340 molybdenum and 900 credits.

@node MineralsForHull, MineralsForEngine, MineralsForBaseOnPlanet, Score Functions
@subsection Uns32 MineralsForHull(Uns16 lHullNr, CargoType_Def CargoType)
@findex MineralsForHull

This function returns minerals for hull, assuming normal materials and credits build cost
for a given hull. The lHullNr parameter should be in range 1 to HULL_NR.

@node MineralsForEngine, MineralsForBeam, MineralsForHull, Score Functions
@subsection Uns32 MineralsForEngine(Uns16 lEngNr, CargoType_Def CargoType)
@findex MineralsForEngine

This function returns minerals for one engine, assuming normal materials and credits build cost
for a given engine. The lEngNr parameter should be in range 1 to ENGINE_NR.

@node MineralsForBeam, MineralsForTube, MineralsForEngine, Score Functions
@subsection Uns32 MineralsForBeam(Uns16 lBeamNr, CargoType_Def CargoType)
@findex MineralsForBeam

This function returns minerals for one beam, assuming normal materials and credits build cost
for a given beam. The lBeamNr parameter should be in range 1 to BEAM_NR.

@node MineralsForTube, MineralsForTorpedo, MineralsForBeam, Score Functions
@subsection Uns32 MineralsForTube(Uns16 lTorpNr, CargoType_Def CargoType)
@findex MineralsForTube

This function returns minerals for one torpedo tube, assuming normal materials and
credits build cost for a given tube. The lTorpNr parameter should be in range 1 to TORP_NR.

@node MineralsForTorpedo, MineralsForShipParts, MineralsForTube, Score Functions
@subsection Uns32 MineralsForTorpedo(Uns16 lTorpNr, CargoType_Def CargoType)
@findex MineralsForTorpedo

This function returns minerals for one torpedo, assuming normal materials and
credits build cost for a given torpedo. The lTorpNr parameter should be in range 1 to TORP_NR.

@node MineralsForShipParts, MineralsForShipCargo, MineralsForTorpedo, Score Functions
@subsection Uns32 MineralsForShipParts(Uns16 sID, CargoType_Def CargoType)
@findex MineralsForShipParts

This function returns minerals for ship, assuming normal build costs for
all ship equipment and hull. Hull, engines, beams and torpedo launchers costs
are summed.

@node MineralsForShipCargo, MineralsForShipAmmo, MineralsForShipParts, Score Functions
@subsection Uns32 MineralsForShipCargo(Uns16 sID, CargoType_Def CargoType)
@findex MineralsForShipCargo

This function returns minerals for ship cargo.

@node MineralsForShipAmmo, MineralsForPlanetStructures, MineralsForShipCargo, Score Functions
@subsection Uns32 MineralsForShipAmmo(Uns16 sID, CargoType_Def CargoType)
@findex MineralsForShipAmmo

This function returns minerals for ship ammunition. If ship carries fighters,
fighters are counted. For ships having torpedo tubes, torpedos are counted.

@node MineralsForPlanetStructures, MineralsForPlanetMinerals, MineralsForShipAmmo, Score Functions
@subsection Uns32 MineralsForPlanetStructures(Uns16 pID, CargoType_Def CargoType)
@findex MineralsForPlanetStructures

This function returns minerals for given planet structures. All mineral mines,
factories and defense posts are counted.

@node MineralsForPlanetMinerals, MineralsForBaseTechLevels, MineralsForPlanetStructures, Score Functions
@subsection Uns32 MineralsForPlanetMinerals(Uns16 pID, CargoType_Def CargoType)
@findex MineralsForPlanetMinerals

This function returns minerals for given planet laying on it's surface.

@node MineralsForBaseTechLevels, MineralsForBaseDefense, MineralsForPlanetMinerals, Score Functions
@subsection Uns32 MineralsForBaseTechLevels(Uns16 bID, CargoType_Def CargoType)
@findex MineralsForBaseTechLevels

This function returns minerals for given base tech levels.

@node MineralsForBaseDefense, MineralsForBaseStorage, MineralsForBaseTechLevels, Score Functions
@subsection Uns32 MineralsForBaseDefense(Uns16 bID, CargoType_Def CargoType)
@findex MineralsForBaseDefense

This function returns minerals for given base defense posts and fighters.

@node MineralsForBaseStorage, MineralsForBaseTorpedos, MineralsForBaseDefense, Score Functions
@subsection Uns32 MineralsForBaseStorage(Uns16 bID, CargoType_Def CargoType)
@findex MineralsForBaseStorage

This function returns minerals for given base stored equipment. All hulls,
engines, beams and torpedo tubes are counted.

@node MineralsForBaseTorpedos, MineralsForShip, MineralsForBaseStorage, Score Functions
@subsection Uns32 MineralsForBaseTorpedos(Uns16 bID, CargoType_Def CargoType)
@findex MineralsForBaseTorpedos

This function returns minerals for given base stored torpedos.

@node MineralsForShip, MineralsForPlanet, MineralsForBaseTorpedos, Score Functions
@subsection Uns32 MineralsForShip(Uns16 sID, PointsType_Def CountType, CargoType_Def CargoType)
@findex MineralsForShip

This function returns minerals for given ship. Setting CountType to USED_POINTS
makes procedure counts minerals only for ship parts and torpedos
(MineralsForShipParts and MineralsForShipTorpedos are called).
Setting CountType to UNUSED_POINTS counts only ship cargo
(MineralsForShipCargo is called). ALL_POINTS sums all minerals.

@node MineralsForPlanet, MineralsForBase, MineralsForShip, Score Functions
@subsection Uns32 MineralsForPlanet(Uns16 pID, PointsType_Def CountType, CargoType_Def CargoType)
@findex MineralsForPlanet

This function returns minerals for given planet. Setting CountType to USED_POINTS
makes procedure counts minerals only for planet structures (MineralsForPlanetStructures is called).
Setting CountType to UNUSED_POINTS counts only planet cargo
(MineralsForPlanetMinerals is called). ALL_POINTS sums all minerals.

@node MineralsForBase, MineralsForMinefield, MineralsForPlanet, Score Functions
@subsection Uns32 MineralsForBase(Uns16 bID, PointsType_Def CountType, CargoType_Def CargoType)
@findex MineralsForBase

This function returns minerals for given base. Setting CountType to USED_POINTS
makes procedure counts minerals for base build cost, torpedos stored in base,
base defense system and base tech levels (MineralsForBaseOnPlanet, MineralsForBaseTorpedos,
MineralsForBaseDefense and MineralsForBaseTechLevels are called).
Setting CountType to UNUSED_POINTS counts base stored equipment. All hulls,
engines, beams and torpedo tubes are counted (MineralsForBaseStorage is called).
ALL_POINTS sums all minerals.

@node MineralsForMinefield, RaceMineralsForShips, MineralsForBase, Score Functions
@subsection Uns32 MineralsForMinefield(Uns16 mID, PointsType_Def CountType, CargoType_Def CargoType)
@findex MineralsForMinefield

This function returns minerals for given minefield. Setting CountType to USED_POINTS
or to ALL_POINTS gives minerals for minefield mID assuming that minefield was laid
using the most cheapest, in minerals, torpedos. Setting CountType to UNUSED_POINTS
make procedure to return zero. No race specific corrections are made.

@node RaceMineralsForShips, RaceMineralsForPlanets, MineralsForMinefield, Score Functions
@subsection Uns32 RaceMineralsForShips( RaceType_Def Race, PointsType_Def CountType, ShipsType_Def ShipsType)
@findex RaceMineralsForShips

This function returns minerals for given race ships. Count type is controlled
by CountType parameter. ShipsType parameter can filter counted ships, so only
war ships are scored (WAR_SHIPS), freighters (FREIGHTER_SHIPS) or there is no filtering
at all (ALL_SHIPS).

@node RaceMineralsForPlanets, RaceMineralsForBases, RaceMineralsForShips, Score Functions
@subsection Uns32 RaceMineralsForPlanets( RaceType_Def Race, PointsType_Def CountType, CargoType_Def CargoType)
@findex RaceMineralsForPlanets

This function returns minerals for given race planets. Count type is controlled
by CountType parameter.

@node RaceMineralsForBases, RaceMineralsForMinefields, RaceMineralsForPlanets, Score Functions
@subsection Uns32 RaceMineralsForBases( RaceType_Def Race, PointsType_Def CountType, CargoType_Def CargoType)
@findex RaceMineralsForBases

This function returns minerals for given race bases. Count type is controlled
by CountType parameter.

@node RaceMineralsForMinefields,  , RaceMineralsForBases, Score Functions
@subsection Uns32 RaceMineralsForMinefields( RaceType_Def Race, PointsType_Def CountType, Boolean RaceModify, CargoType_Def CargoType)
@findex RaceMineralsForMinefields

This function returns minerals for given race minefields. Count type is controlled
by CountType parameter. Setting RaceModify to True makes minerals to be corrected by
race UnitsPerTorpRate PConfig.src parameter, so real torpedo laying costs are counted.
Making RaceModify False gives no such correction.

@node FCode Functions, Command Message Functions, Score Functions, Function Call Interface
@section Friendly Code Functions (new - 4.3)

Friendly code checking is completely based upon the XTRFCODE.TXT file.
To check whether a friendly code is special, the PDK checks the file
according to the usual rules. The "well-known" special codes (lfm,
mkt, etc.) are automatically considered, when the PDK rewrites that
file, it will include the well-known codes (like PHost 3.4 does).
Special friendly codes are considered special everywhere, that is,
"NUK" is special for ships, and "mkt" is special for planets, like in
PHost.

@menu
* InitFCodes::
* ShutdownFCodes::
* DumpExtraFCodes::
* DefineSpecialFCode::
* IsFCodeSpecial::
* IsShipFCodeSpecial::
* IsPlanetFCodeSpecial::
* IsFCodeMatch::
@end menu

@iftex
@itemize @minus
@item InitFCodes
@item ShutdownFCodes
@item DumpExtraFCodes
@item DefineSpecialFCode
@item IsFCodeSpecial
@item IsShipFCodeSpecial
@item IsPlanetFCodeSpecial
@item IsFCodeMatch
@end itemize
@end iftex

@node InitFCodes, ShutdownFCodes, FCode Functions, FCode Functions
@subsection void InitFCodes(void)
@findex InitFCodes

Initialize the friendly code module. This loads XTRFCODE.TXT file.
This function is called automatically when needed.

@node ShutdownFCodes, DumpExtraFCodes, InitFCodes, FCode Functions
@subsection void ShutdownFCodes(void)
@findex ShutdownFCodes

Shut down the friendly code module. This function is called automatically
when needed. This will update (=rewrite) the XTRFCODE.TXT file. Currently,
there is no way to prevent this from happening.

@node DumpExtraFCodes, DefineSpecialFCode, ShutdownFCodes, FCode Functions
@subsection void DumpExtraFCodes(FILE *pFile)
@findex DumpExtraFCodes

List all special friendly codes in file pFile, one entry per line.

@node DefineSpecialFCode, IsFCodeSpecial, DumpExtraFCodes, FCode Functions
@subsection Boolean DefineSpecialFCode(const char* pCode)
@findex DefineSpecialFCode

Declares a special friendly code. This adds the code to XTRFCODE.TXT.
If your add-on has a special friendly code "foo", you can call
`DefineSpecialFCode("foo")' to let everyone, including PHOST, know
about it. Note that, currently, changes to XTRFCODE.TXT while PHost is
running do not take effect immediately.

@node IsFCodeSpecial, IsShipFCodeSpecial, DefineSpecialFCode, FCode Functions
@subsection Boolean IsFCodeSpecial(const char* pFCode)
@findex IsFCodeSpecial

True iff the specified friendly code is special.

@node IsShipFCodeSpecial, IsPlanetFCodeSpecial, IsFCodeSpecial, FCode Functions
@subsection Boolean IsShipFCodeSpecial(Uns16 pShip)
@findex IsShipFCodeSpecial
@findex IsShipFCSpecial

True iff the friendly code on ship pShip is special. This is just a
small wrapper around @xref{IsFCodeSpecial, IsFCodeSpecial()}.

This function is also available under the name @code{IsShipFCSpecial}.

@node IsPlanetFCodeSpecial, IsFCodeMatch, IsShipFCodeSpecial, FCode Functions
@subsection Boolean IsPlanetFCodeSpecial(Uns16 pPlanet)
@findex IsPlanetFCodeSpecial
@findex IsPlanetFCSpecial

True iff the friendly code on planet pPlanet is special. This is just a
small wrapper around @xref{IsFCodeSpecial, IsFCodeSpecial()}.

This function is also available under the name @code{IsPlanetFCSpecial}.

@node IsFCodeMatch,  , IsPlanetFCodeSpecial, FCode Functions
@subsection Boolean IsFCodeMatch(const char* p1, const char* p2)
@findex IsFCodeMatch

True iff the friendly codes p1 and p2 are to be considered matching.
Two friendly codes match when they are the same (of course), but not
special. That is, "moo" and "moo" match, but "NUK" and "NUK" don't.

@c ----------------------------------------------------------------------

@node Command Message Functions, Auxiliary Data & Experience, FCode Functions, Function Call Interface
@section Command Message Functions

The PDK includes functions to simplify reading command messages ("x
commands", @code{xterncmd.ext}). It will do all file reading and error
handling, all you have to do is to implement the actual functionality.

@menu
* Command Message Concepts::
* CommandReader_Func::
* CommandComplain_Func::
* CommandFileReader::
* CommandFileReaderFP::
* GetToken::
@end menu

@node Command Message Concepts, CommandReader_Func, Command Message Functions, Command Message Functions
@subsection Command Message Concepts

Programs have a @emph{name} which is a single word, for example "mfq".

Commands can be @emph{addressed} to a particular add-on. This is done by
prefixing them with the add-on name followed by a colon: "mfq:". For
example, to send a command "keep 3" to mfq, player 9 could send a
command message
@example
   x mfq: keep 3
@end example
In PHost 3.4b and later, the "x" can be omitted:
@example
   mfq: keep 3
@end example
Both end up in PHost writing
@example
   9: mfq: keep 3
@end example
into @code{xterncmd.ext}.

Programs can support @emph{auxiliary command files}. These are files
which players submit along with their turn files, which the host must
copy into the game directory. For example, mfq accepts @code{mfqX.txt}
files. Those contain commands as well. For example, player 9 could send
a file @code{mfq9.txt} with contents
@example
   keep 3
@end example
to achieve the same effect as the above command messages. The advantage
of auxiliary command files is that they're easier to edit than command
messages, and that you can include comments (starting with a "#" sign).
The disadvantage is that hosting systems must explicitly allow players
to upload the auxiliary files along with their turns.

All these three possibilities will end up in calling your parser
function with
@example
   Race      = 9
   Command   = "keep"
   Arguments = "3"
@end example

For @emph{backward compatibility}, commands are also accepted with just
the program name (and no colon), or even without addressing, i.e. the
following command messages would have the same effect at first glance:
@example
   x keep 3
   x mfq keep 3
@end example
However, because we don't specifically know that the message was
addressed to us, we can't detect errors here. If mfq would not know a
command @code{keep}, it could not tell the player, because another
program could probably handle the command. One reason why this (at least
the first possibility) is still useful is that it allows "catch-all"
commands:
@example
   x help
@end example
would cause every program which understands the @code{help} command to
send a help message.

@node CommandReader_Func, CommandComplain_Func, Command Message Concepts, Command Message Functions
@subsection CommandReader_Func
@findex CommandReader_Func

@example
  typedef Boolean (*CommandReader_Func) (Uns16 pRace,
                                         const char* pCommand,
                                         const char* pArgs,
                                         const char* pWholeLine,
                                         void* pData);
@end example

A function with this signature is passed to @code{CommandFileReader()}
to process the commands @xref{CommandFileReader}.

@itemize @minus
@item pRace
The race for which this command is valid (1..11).
@item pCommand
The command verb (the first word of the command).
@item pArgs
The command arguments (all but the first word of the command).
@item pWholeLine
The whole command line as read from @code{xterncmd.ext} or the auxiliary
command file.
@item pData
The @code{pData} argument as passed to @code{CommandFileReader}.
@end itemize

@emph{Error handling:} when this function does not understand the command
verb, it must return @code{False}. The caller will generate an error
message (@pxref{CommandComplain_Func}).
If it understands the command verb, but the rest of the syntax is wrong,
this function should generate an error message and return True (that is,
the command was processed unsuccessfully). If the command was understood
and performed correctly, the return value is True, too.

@node CommandComplain_Func, CommandFileReader, CommandReader_Func, Command Message Functions
@subsection CommandComplain_Func
@findex CommandComplain_Func
@findex ComplainWithWarningMessage
@findex ComplainWithSubspaceMessage

@example
  typedef void (*CommandComplain_Func) (Uns16 pRace,
                                        const char* pLine,
                                        const char* pReason,
                                        void* pData);
@end example

A function with this signature is passed to @ref{CommandFileReader}
and is called when the @ref{CommandReader_Func} returns False.

Its parameters are the race number, the offending line, the reason of
the failure and the data parameter passed to
@ref{CommandFileReader}. The race number will be zero
if @code{xterncmd.ext} contains a command which can't be assigned to a race
(syntax error maybe).

The PDK includes two default implementations which you can use:
@code{ComplainWithWarningMessage} will show a message on standard output
(using @ref{Warning}), @code{ComplainWithSubspaceMessage}
will send a subspace message to the sender of the command
(using @ref{WriteAUXHOSTMessage}). You can also
write your own versions.

@node CommandFileReader, CommandFileReaderFP, CommandComplain_Func, Command Message Functions
@subsection void CommandFileReader(...)
@findex CommandFileReader

This is the main entry point.
@example
  void CommandFileReader(Uns16 pRace, CommandReader_Func pFunc,
                         CommandComplain_Func pComplain, const char* pProgName,
                         const char* pPrivateFile, void* pData);
@end example

The parameters are as follows:
@itemize @minus
@item @code{pRace}
which race's commands we're interested in (1..11). Zero if you want all
race's commands. If possible, you should use that latter possibility, so
you only have to call this function once (so that @code{xterncmd.ext} is
only read once).
@item @code{pFunc}
the function to call for each command, see
@xref{CommandReader_Func, CommandReader_Func}.
@item @code{pComplain}
the function to invoke when your function returns an error, see
@xref{CommandComplain_Func, CommandComplain_Func}. If NULL, uses
the default of @code{ComplainWithWarningMessage}.
@item @code{pProgName}
the name of your program. Can be NULL or "" to accept all lines,
unfiltered (i.e. behaves as if all commands were addressed to us).
@item @code{pPrivateFile}
the name of the auxiliary command file. This should be a @code{sprintf}
string with exactly one @code{%d} placeholder; it must not exceed 100
characters when expanded.
@item @code{pData}
this pointer is passed uninterpreted, verbatim to the @code{pFunc} and
@code{pComplain}. Use this to pass additional information to these
functions.
@end itemize

@node CommandFileReaderFP, GetToken, CommandFileReader, Command Message Functions
@subsection void CommandFileReaderFP(...)
@findex CommandFileReaderFP

This is the back-end to @xref{CommandFileReader, CommandFileReader()}.

@example
void CommandFileReaderFP(Uns16 pRace, Uns16 pFileIsFor,
                         CommandReader_Func pFunc,
                         CommandComplain_Func pComplain, const char* pProgName,
                         FILE* pFile, void* pData);
@end example
@itemize @minus
@item @code{pRace}
which race's commands we're interested in (race number, or 0 for all races).
@item @code{pFileIsFor}
what race this file is for. Either a race number when we're reading that
race's auxiliary command file, or zero when we're reading
@code{xterncmd.ext}.
@item @code{pFunc}
the function to call for each command, see
@ref{CommandReader_Func}.
@item @code{pComplain}
the function to invoke when your function returns an error, see
@ref{CommandComplain_Func}. If NULL, uses
the default of @code{ComplainWithWarningMessage}.
@item @code{pProgName}
program name; only commands addressed to that program are handed to
pFunc. This value can be NULL when we're reading the auxiliary command file
(i.e. all commands are for us, errors call pComplain), "" to accept all
commands but don't generate errors.
@item @code{pFile}
command file, open for reading
@item @code{pData}
this pointer is passed uninterpreted, verbatim to the @code{pFunc} and
@code{pComplain}. Use this to pass additional information to these
functions.
@end itemize

@node GetToken,  , CommandFileReaderFP, Command Message Functions
@subsection char* GetToken(const char** pString, char* pDelim)
@findex GetToken

This function is a replacement for @code{strtok}. It finds the first
token of @code{*pString} (a token consists of characters not listed in
@code{pDelim}), and returns a @code{MemAlloc'd} copy of that token
@xref{MemAlloc}. @code{*pString} is advanced accordingly. When the
string contains no more tokens, returns NULL.

For example,
@example
  char *string = "  PDK makes add-ons easy!", *tok;
  while ((tok = GetToken(&string, " ")) != 0) @{
    puts(tok);
    MemFree(tok);
  @}
@end example
will print
@example
  PDK
  makes
  add-ons
  easy!
@end example
and @code{string} will point to the terminating null of the character
literal afterwards.

@c -----------------------------------------------------------------------------

@node Auxiliary Data & Experience, Tons, Command Message Functions, Function Call Interface
@section Auxiliary Data & Experience

The following functions access the new auxiliary data introduced with
PHost 4. They are only dummies in PHost 3.x mode.

@menu
* Auxdata Chunk Functions::
* Experience Functions::
@end menu

@node Auxdata Chunk Functions, Experience Functions, Auxiliary Data & Experience, Auxiliary Data & Experience
@subsection Auxdata Chunk Functions
@findex GetAuxdataChunkById
@findex AuxdataChunkSize
@findex AuxdataChunkData

These functions are the low-level primitives upon which the other
functions in this module are built. You usually do not need to use them.

@itemize
@item A chunk is addressed by an opaque handle of type
@code{struct Auxdata_Chunk*}.
@item @code{struct Auxdata_Chunk* GetAuxdataChunkById(int pId)}

This function returns an opaque handle of type @code{struct
Auxdata_Chunk*} which corresponds to the @code{auxdata.hst} chunk with
Id number @code{pId}. Blocks with Id numbers below 6 are not accessible
this way. If the block does not exist, or the game is not a PHost 4.x
game, this function returns NULL.
@item @code{size_t AuxdataChunkSize(struct Auxdata_Chunk* pChunk)}

Returns the size (in bytes) of the data contained in the specified
chunk. If given a NULL argument, returns 0.
@item @code{void* AuxdataChunkData(struct Auxdata_Chunk* pChunk)}

Returns a pointer to the data contained in the specified chunk. If given
a NULL argument, returns 0.

You are permitted to modify the data pointed to by this function. It is
not possible to change the size of the data block, though. The rationale
is that PHost already has chosen the right size for the game.
@end itemize

@node Experience Functions,  , Auxdata Chunk Functions, Auxiliary Data & Experience
@subsection Experience Functions
@findex ShipExperience
@findex PlanetExperience
@findex ExperienceLevel
@findex AddToExperience
@findex ExperiencePoints
@findex PutExperiencePoints
@findex NewExperiencePoints

To deal with experience, you first have to obtain an opaque handle of
type @code{Exp_Handle}. Although the C language requires type to be
exposed in @file{phostpdk.h}, do not look into it other than with the
provided accessor functions.

Experience points are accumulated through the turn, and get effective at
the end, during the @code{Experience} pcontrol stage. Therefore, while
PHost is running, experience you add using @code{AddToExperience(X,N)}
will not immediately show up in @code{ExperiencePoints(X)}. Experience
added from "outside" PHost (i.e. before a host run) will be added
immediately (and possible cause the unit to advance a
level).@footnote{PHost versions below 4.0d are broken in this respect.
Here, added experience will always immediately show up, but bugs in the
PHost core make add-ons break the internal experience system}.

@itemize
@item @code{Exp_Handle ShipExperience(Uns16 pShipId)}

Obtain a handle to deal with the experience of ship @code{pShipId}. You
@emph{can} obtain handles to non-existent or out-of-range ships; those
will return 0 experience and will not react on modificators. The same
happens if the game is not using experience.

@item @code{Exp_Handle PlanetExperience(Uns16 pPlanetId)}

Obtain a handle to deal with the experience of planet @code{pPlanetId}.
Everything said for ships also applies here.

@item @code{int ExperienceLevel(Exp_Handle pH)}

Returns the experience level of the specified object (an integer in the
range from 0 up to and including
@code{gPconfigInfo->NumExperienceLevels}). This is the same value which
the player knows.

@item @code{void AddToExperience(Exp_Handle pH, Uns32 pNumber)}

Increase the experience of the specified unit by @code{pNumber}.

@item @code{Uns32 ExperiencePoints(Exp_Handle pH)}

Returns the exact number of experience points this unit has. This does
not include the points earned this turn.

@item @code{void PutExperiencePoints(Exp_Handle pH, Uns32 pPoints)}

Change the number of experience points this unit has. This will forget
all the points earned so far.

Therefore,
@example
  PutExperiencePoints(h, ExperiencePoints(h));
@end example
will forget all the points earned this turn. In contrast,
@example
  Uns32 lNewPts = NewExperiencePoints(h);
  PutExperiencePoints(h, ExperiencePoints(h));
  AddToExperience(h, lNewPts);
@end example
is an expensive null operation.

@item @code{Uns32 NewExperiencePoints(Exp_Handle pH)}

Returns the number of points earned this turn.
@end itemize

@c -----------------------------------------------------------------------------

@node Tons,  , Auxiliary Data & Experience, Function Call Interface
@section Tons

HOST and PHost keep a running total of ship tons sunk during the game.
These functions are used to access this score, which is stored in
@file{tons.hst}.

HOST and older versions of PHost only store the number of tons destroyed
by a race. PHost since 3.4b also stores the number of tons lost by a
race. This module always writes out ``new-style'' @file{tons.hst}; it is
expected that this file can be read by all programs.

You should only be using the @ref{AddToTonsScore} and @ref{GetTons}
functions, the others are available for special-purpose programs and are
generally not needed.

@menu
* AddToTonsScore::
* GetTons::
* PutTons::
* ClearThisTurnTons::
@end menu

@node AddToTonsScore, GetTons, Tons, Tons
@subsection void AddToTonsScore(RaceType_Def pWinner, RaceType_Def pLoser, Uns32 pTonnage)
@findex AddToTonsScore

Registers that @code{pWinner} has destroyed @code{pTonnage} kt of battle
mass owned by @code{pLoser}. This will increment @code{pWinner}'s Tons
Destroyed scores as well as @code{pLoser}'s Tons Lost score. Both the
this-turn values as well as the all-time totals are updated.

It is safe to pass a value outside the valid range for any of the races.

@node GetTons, PutTons, AddToTonsScore, Tons
@subsection Uns32 GetTons(enum Tons pWhich, RaceType_Def pPlayer)
@findex GetTons
@vindex Tons_Destroyed
@vindex Tons_DestroyedThisTurn
@vindex Tons_Lost
@vindex Tons_LostThisTurn

Use this function to inquire the tons score. @code{pWhich} is taken from
the following enumeration:
@itemize @minus
@item @code{Tons_Destroyed}
tons destroyed by @code{pPlayer} during the whole game so far
@item @code{Tons_DestroyedThisTurn}
tons destroyed by @code{pPlayer} this turn
@item @code{Tons_Lost}
tons lost by @code{pPlayer} during the whole game so far, if the host
program supports this
@item @code{Tons_LostThisTurn}
tons lost by @code{pPlayer} this turn, if the host program supports this
@end itemize

@node PutTons, ClearThisTurnTons, GetTons, Tons
@subsection void PutTons(enum Tons pWhich, RaceType_Def pPlayer, Uns32 pValue)
@findex PutTons

This function modifies the specified part of the tons score directly
(see @ref{GetTons}).

Generally, you do not use this function directly; use
@ref{AddToTonsScore} instead which automatically ensures consistency.

@node ClearThisTurnTons,  , PutTons, Tons
@subsection void ClearThisTurnTons(void)
@findex ClearThisTurnTons

This function clears the ``this turn'' part of the tons score. It does
not affect the all-time totals. Normally, the host program does this
once per turn when it advances the turn number.

@c -----------------------------------------------------------------------------

@node Variables Index, Functions Index, Function Call Interface, Top
@unnumbered Variables Index
@printindex vr

@node Functions Index,  , Variables Index, Top
@unnumbered Functions Index
@printindex fn

@contents

@bye

