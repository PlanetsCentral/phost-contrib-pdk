                     THE PORTABLE HOST DEVELOPMENT KIT
                Application Programming Interface Reference
                             Version 3.2.4.1

This document outlines the usage of the PDK for writing programs. A good
understanding of the ANSI C language is assumed. The entire API is declared
in the include file PHOSTPDK.H. When reading through the following
documentation, the contents of the PHOSTPDK.H file should be inspected for
clarification.

This document is meant mainly as a reference guide, not as a tutorial on
how to use the PDK. The best way to learn about PDK programming is to study
the example source files that come with the PDK.

This file is divided into several sections. The function call interface
section is further subdivided into logical functional groups. The sections
in this file are as follows:

   * Manifest Constants
   * Common Types
   * Data Structures
   * Global Variables
   * Function Call Interface
    - PDK Initialization and Cleanup
    - Data File Input/Output
    - Data File Mastering
    - Player Status
    - Ship Accessors
    - Planet Accessors
    - Starbase Accessors
    - Minefield Accessors
    - Wormhole Accessors
    - Hull Accessors
    - Engine Accessors
    - Torpedo Accessors
    - Beam Weapon Accessors
    - Race Name Accessors
    - Host Run Time Accessors
    - Enumeration Functions
    - External Message Interface
    - AUXHOST Message Interface
    - RST Message Interface
    - Build Queue Interface
    - Alliance Management
    - Game Status Interface
    - File Utility Functions
    - Memory Management
    - Messaging and Logging
    - Random Number Generation
    - Cross-Platform Portability
    - Command-Line Option Processing
    - Combat Interface
    - Remote Control Interface
    - Config File Reader Interface
    - Special Ship Function Accessors
    - Wraparound Map Functions

Manifest Constants
==================

The file PHOSTPDK.H defines some constants that may be useful in writing
your program. The constants are used in the PDK itself so using these
constants ensures that your program will be compatible with the PDK through
all revisions.

RACE_NR       -- The number of races in the game (11)
SHIP_NR       -- The maximum number of ships in the game (500)
PLANET_NR     -- The maximum number of planets in the game (500)
BASE_NR       -- The maximum number of bases in the game (500)
MINE_NR       -- The maximum number of minefields in the game (10000 - NEW)
HULL_NR       -- The number of different hull types in the game (105)
ENGINE_NR     -- The number of different engine types in the game (9)
BEAM_NR       -- The number of different beam types in the game (10)
TORP_NR       -- The number of different torpedo/tube types in the game (10)

LONGNAME_SIZE   -- The maximum length of a race's full name (30 characters)
SHORTNAME_SIZE  -- The maximum length of a race's short name (20 characters)
ADJECTIVE_SIZE  -- The maximum length of a race's adjective (12 characters)
PLANETNAME_SIZE -- The maximum length of a planet's name (20 characters)

RACEHULLS         -- The number of hulls a race can build at a base (20)
MAX_SPEED         -- The maximum warp speed on ships (9)
MAX_BEAMS         -- The maximum number of beams on a ship (20)
MAX_TUBES         -- The maximum number of tubes on a ship (20)
MAX_BAYS          -- The maximum number of fighter bays on a ship (20)
MAX_PLANET_BAYS   -- The maximum number of bays a planet gets in combat (50)
MAX_BASE_DEFENSE  -- The maximum number of defense posts on a base (200)
MAX_BASE_FIGHTERS -- The maximum number of fighters on a starbase (60)
MAX_TECH          -- The maximum tech level in any tech (10)
MAX_DENSITY       -- The maximum mineral density in a planet (100)
MAX_HAPPY         -- The maximum happiness of colonists and natives (100)
MIN_HAPPY         -- The minimum happiness of colonists and natives (-300)
MAX_COORDINATE    -- The maximum X or Y co-ordinate value of objects (10000)
MIN_COORDINATE    -- The minimum X or Y co-ordinate value of objects (0)
MAX_SHIP_CREDITS  -- The maximum number of credits on a ship (10000)
MAX_WORMHOLES     -- The maximum number of supported wormholes (100)
MAX_MINES         -- The maximum number of mines on a planet (700)
MAX_FACTORIES     -- The maximum number of factories on a planet (600)
MAX_DEFENSE       -- The maximum number of defense posts on a planet (550)
MAX_POPULATION    -- The maximum number of colonists/natives on a planet (25E6)
MAX_TAX           -- The maximum tax rate on a planet (100)
MAX_TEMP          -- The maximum temperature on a planet (100)


Common Types
============

The following typedefs are used throughout the PDK code as both function
parameters and return values. For compatibility and portability to multiple
platforms, the use of the following types in code that interfaces to the
PDK is encouraged.

    Int16     -- a 16-bit signed integer
    Uns16     -- a 16-bit unsigned integer
    Int32     -- a 32-bit signed integer
    Uns32     -- a 32-bit unsigned integer
    Boolean   -- an enumerated type with the values False (0) and True (1)

    RandType_Def -- the return type of the PDK's random number functions
                    (equivalent to Uns16)

    CargoType_Def   -- an enumerated type listing the possible types of cargo
    RaceType_Def    -- an enumerated type listing the different races
    NativeType_Def  -- an enumerated type listing the different native types
    NativeGovm_Def  -- an enumerated type listing the different native
                       government types
    ShipMission_Def -- an enumerated type listing the various ship missions
    BaseMission_Def -- an enumerated type listing the various base missions
    BaseFixMission_Def -- an enumerated type indicating whether the base
                          is performing a fix or a recycle mission
    BaseTech_Def       -- an enumerated type listing the 4 types of base tech
    BuildOrder_Struct  -- a structure containing the components of a base
                          build order
    BaseOrder_Struct   -- a structure containing the components of an entry
                          in PHOST's build queue
    AllianceLevel_Def  -- an enumerated type listing the various levels of
                          alliance supported by PHOST
    AllianceState_Def  -- an enumerated type listing the 3 possible states
                          for each level of alliance (on, off, conditional)
    FileLocation_Def   -- an enumerated type listing various options for
                          the file management functions
    CombatResult_Def   -- an enumerated type describing the various
                          outcomes of a battle
    Language_Def       -- an enumerated type listing the various languages
                          supported by PHOST


Data Structures
===============

The only data structures defined by the PDK are Pconfig_Struct which
contains all of the host configuration information and UFO_Struct which
defines an entry in the UFO.HST file. Note that the Pconfig_Struct
structure is NOT backwards compatible with PHOST v2.x and HOST since it has
several "array-ized" config options. These are options that were previously
identical for all players but have now been made per-player-configurable in
PHOST 3. For example, gPconfigInfo->TerraformRate is now an array of 12
elements (the 0th element is ignored, the rest are indexed by player number
from 1 to 11).

Note that some members of this structure are arrays. For arrays that are
indexed by player, element 0 of these arrays is ignored.

Note that all "array-ized" config options (and ones that were
per-player-configurable in previous versions) are indexed by PLAYER number,
not RACE number. For games in which PlayerRace is nonstandard, this is a
significant distinction. It allows two players to play the same race yet
have different configuration options, if so desired.


Global Variables
================

The PDK defines and uses the following global variables.

           const char *gRootDirectory
This variable indicates the root (main) directory in which global data
files (such as PLANET.NM, HULLSPEC.DAT) usually reside. By default, this
variable points to "." indicating that the current directory is to be used
as the root directory. The PDK file input/output functions use this
variable in searching for global data files.

This variable can be reassigned to point to another string, but note that
the variable does not point to writable storage. Look at the example source
files for models of how to use this variable.

           const char *gGameDirectory
This variable indicates the game directory in which game-specific files
(such as PLANET.HST, PCONFIG.SRC) are expected to reside. By default, this
variable points to "." indicating that the current directory is to be used
as the game directory. The PDK file input/output functions use this
variable in searching for game data files.

This variable can be reassigned to point to another string, but note that
the variable does not point to writable storage. Look at the example source
files for models of how to use this variable.

           FILE *gLogFile
This variable indicates a file that is to store logging information
generated during program execution. If this variable is NULL (0, the
default value) then no file logging is performed. The Error(), Info(), etc.
functions write to this file pointer if it is non-zero.

           Boolean gNewlyMastered
This variable is False by default but is set to True by the ReadHostData()
routine when a newly-mastered game is encountered (that is, the
NEXTTURN.HST file is of 0 length).

           Pconfig_Struct *gPconfigInfo
This variable points to the data contained in the game configuration file,
PCONFIG.SRC. By default, this variable is NULL (0). This pointer points to
modifiable data but the PDK does not save any modifications to the
PCONFIG.SRC file. Changing the PCONFIG.SRC file (if desired) is up to the
application.

           char *poptarg
           int   poptind
These variables are used by the command-line option processing function
pgetopt(). Please see the description of pgetopt() below for usage
information on these global variables.

           Boolean gNonPHOSTWarnings
This variable should be set to True if the PDK is to display warnings about
a game not being hosted by PHOST (for example, when the AUXDATA.HST file is
not found). If a program that uses the PDK works differently for PHOST
games then it is best to set this variable to True, to let the host know
that behavior may not be as expected. If a program works just as well for
HOST games as for PHOST games then it is better to set this variable to
False in order to not generate warning messages that are irrelevant.


Function Call Interface
=======================

The heart of the PDK API is the function call interface. Function calls are
described here according to logical groupings. The best method of
discerning how these functions are to be used together is to study the
example source code files that are provided with the PDK distribution.

PDK Initialization and Cleanup
------------------------------

           void InitPHOSTLib(void)
This function must be called before any other PDK function is invoked.
Memory is allocated for some necessary data structures and some global
variables are initialized. This function should only be called once in any
program, or once after every call to FreePHOSTLib().

           void FreePHOSTLib(void)
This function should be called before the program exits. It ensures orderly
deallocation of memory and other resources that were created in
InitPHOSTLib(). After calling this function, it is possible to call
InitPHOSTLib() again, which should also (eventually) be followed by another
call to FreePHOSTLib().

Data File Input/Output
----------------------

All of these functions return True if successful, or False if unsuccessful.
Note that the Read_XXX_File() routines from version 2 of the PDK have been
removed as they caused too much confusion when dependencies arose between
the data files.

NOTE: These routines should not be called multiple times in one program
without first calling FreePHOSTLib(). For example, the following usage is
incorrect:

            InitPHOSTLib();
              /* ... */
            ReadGlobalData();
              /* ... */             /* THIS IS WRONG!!! */
            ReadGlobalData();
              /* ... */
            FreePHOSTLib();

Calling FreePHOSTLib() prior to re-reading the data solves the problem:

            InitPHOSTLib();
              /* ... */
            ReadGlobalData();
              /* ... */             /* This is RIGHT */
            FreePHOSTLib();
            InitPHOSTLib();
            ReadGlobalData();
              /* ... */
            FreePHOSTLib();


           Boolean ReadGlobalData(void)
This routine reads "static" game data. Specifically, the following files
are read:
         BEAMSPEC.DAT
         TORPSPEC.DAT
         HULLSPEC.DAT
         ENGSPEC.DAT
         TRUEHULL.DAT
         XYPLAN.DAT
         RACE.NM
         PLANET.NM

The routine returns False if unsuccessful.

           Boolean ReadHostData(void)
This routine reads all "dynamic" game data. Specifically, the following
files are read:
         PCONFIG.SRC
         NEXTTURN.HST
         PDATA.HST
         SHIP.HST
         BDATA.HST
         MINES.HST
         GEN.HST
         WORMHOLE.TXT
         AUXDATA.HST
         HULLFUNC.TXT

This routine returns False if unsuccessful.

        Boolean IsCLOAKCFound(void)
This function returns whether CLOAKC.HST was found or not.
The CLOAKC.HST file is available in later HOST and PHOST versions,
ReadHostData() will try to read CLOAKC.HST but it will return no error
if CLOAKC.HST was not found.

NOTE: It is strongly recommended that you always call both ReadHostData()
and ReadGlobalData() (the latter first) as dependencies still remain
between accessors of dynamic data and the existence of static data.

           Boolean Write_Planets_File(Int16 pControl)
This routine writes the PDATA.HST file to the game directory. Any changes
made to planetary data are saved to this file. If the planetary data was
not initially read using ReadHostData(), then a call to this function
has no effect (any existing PDATA.HST file is not overwritten). The
'pControl' parameter specifies the first word to write to this file.

           Boolean Write_Ships_File(Int16 pControl)
This routine writes the SHIP.HST file to the game directory. Any changes
made to ship data are saved to this file. If the ship data was not
initially read using ReadHostData(), then a call to this function has no
effect (any existing SHIP.HST file is not overwritten).

           Boolean Write_Bases_File(Int16 pControl1, Int16 pControl2)
This routine writes the BDATA.HST file to the game directory. Any changes
made to starbase data are saved to this file. If the starbase data was not
initially read using ReadHostData(), then a call to this function has no
effect (any existing BDATA.HST file is not overwritten). The 'pControl1'
and 'pControl2' parameters specify the first and last words to write to
this file. The 'pControl2' parameter should be the current turn number for
HOST compatibility.

           Boolean Write_Mines_File(void)
This routine writes the MINES.HST file to the game directory. Any changes
made to minefield data are saved to this file. If the minefield data was
not initially read using ReadHostData(), then a call to this function
has no effect (any existing MINES.HST file is not overwritten).

           Boolean Write_HostGen_File(void)
This routine writes the GEN.HST file to the game directory. Any changes
made to player active status or to player passwords are saved to this file.
If the above data was not initially read using ReadHostData(), then a
call to this function has no effect (any existing GEN.HST file is not
overwritten).

           Boolean Write_AuxData_File(void)
This routine writes the AUXDATA.HST file to the game directory. Any changes
made to PHOST-specific data (e.g., the build queue, player alliance info,
etc.) are saved to this file. If the above data was not initially read
using ReadHostData(), then a call to this function will create a new
AUXDATA.HST file with default (mostly 0) values.

           Boolean Write_Racenames_File(void)
This routine writes the RACE.NM file to the game directory. Any changes
made to race names are saved to this file. If the above data was not
initially read using ReadGlobalData(), then the data written out will
be all blanks (not recommended). Note that the RACE.NM file will always be
written to the game directory, even if the original file was found in the
main directory so that the master name file is never overwritten.

           Boolean WriteWormholeFile(void)
This routine writes the WORMHOLE.TXT file to the game directory with the
current wormhole information.

           Boolean WriteHostData(void)
This routine is a short-cut way of calling all of the individual
data-writing routines. That is, calling this function is equivalent to
calling the following functions in order:

               Write_Planets_File
               Write_Ships_File
               Write_Bases_File
               Write_Mines_File
               Write_AuxData_File
               Write_HostGen_File
               WriteWormholeFile    (EXCEPT in Microsoft-DOS)

Note that Write_Racenames_File() is not included.

Data File Mastering
-------------------

These routines can be called in place of the ReadHostData() routine to
create the necessary data structures. They can also be called at any time
to re-initialize those structures with null data (i.e., clearing out all
elements from the structures). These routines support the creation of a
portable MASTER program since they allow a Write_XXX_File() routine to be
called without a corresponding call to ReadHostData().

               void InitializePlanets(void)
This routine clears all planet structures. Minerals, owners, colonists,
etc. are all removed and set to 0.

               void InitializeShips(void)
This routine clears all ships. All ships are deleted.

               void InitializeBases(void)
This routine clears all bases. All bases are deleted.

               void InitializeMines(void)
This routine removes all mine fields.

               void InitializeHostGen(void)
This routine prepares for a call to Write_HostGen_File() if there was no
call to ReadHostData(). All players are marked inactive and all player
passwords are set to NOPASSWORD.

Player Status
-------------

The following functions require a prior call to ReadHostData().

           Boolean PlayerIsActive(RaceType_Def pPlayer)
This function returns True if the given player is active in this game,
otherwise False is returned.

           void PutPlayerIsActive(RaceType_Def pPlayer, Boolean pActive)
This function can set or clear the active status of a player in the game.
The KILLRACE program, for example, calls this function to remove a player
from the game. The player's activity status is not saved unless a call to
Write_HostGen_File() is performed.

           const char *PlayerPassword(RaceType_Def pPlayer)
This function returns the password for a given player as a null-terminated
character string.

           void PutPlayerPassword(RaceType_Def pPlayer, const char *pPwd)
This function sets the password for a given player. The 'pPwd' parameter
must be a null-terminated plain-text string of no more than 10 characters.
The player's password is only saved when Write_HostGen_File() is called.

Ship Accessors
--------------

The following functions all assume that the SHIPS.HST file has been read
from disk using the ReadHostData() function. Your program will likely
crash if this assumption isn't met.

           Boolean IsShipExist(Uns16 pID)
This function returns True if the given parameter represents a valid ship
number (in the range 1 to SHIP_NR) and the ship is in play. All other
functions listed below assume that the ship specified by the function's
parameter is a valid ship. Only this function will accept a parameter that
is not a legal, active ship number.

           void DeleteShip(Uns16 pID)
This function removes the given ship from play.

           Boolean IsShipCloaked(Uns16 pID)
This seemingly simple function is actually quite complicated. The problem
is that this function tries to return the most accurate information about a
ship's cloak status that it can find. Unfortunately, this information is
not always available. Simply checking the ship's mission is insufficient
since it may be set to 'Cloak' yet the host program has decided that the
ship's cloak has failed on this turn (due to random chance, or due to
excessive damage or lack of fuel, etc.)

The one case in which the true cloak status of the ship is known is when
PHOST version 3.2.2.11 or higher has been used to write the AUXDATA.HST
file (including all versions of PHOST 3). In this case, PHOST will write to
this file the true cloak status of the ship, and IsShipCloaked() returns
this information. Obviously, a call to ReadHostData() must be performed in
this case.

In all other cases (HOST is used, no AUXDATA file exists or this file is
not read, or the game is being hosted with PHOST 3.2.2.10 or lower) then
IsShipCloaked() simply performs the check on the ship's mission to estimate
cloak status. That is, if the ship can cloak, and the ship's mission is
Cloak or the ship is owned by the Birdman race and the ship's mission is
Super Spy, then the ship is considered to be cloaked.


           void    MarkShipCloaking(Uns16 pID, Boolean pCloaked)
This function sets the cloak status of a ship using the CLOAKC.HST file.
Setting the cloak status True works only if the ship is capable of cloaking.
Note that the cloak status is not permanent in PHOST, the cloak status
is redetermined after all acions that affect cloaking (damage, fuel
usage etc.)
Setting the cloak status to False works different since PHOST 3.2.3.3:
If a ship was cloaked and the status is set to False, then PHOST assumes
that the ship remains uncloaked for the rest of the turn. There will be no
cloak failure message (PHOST assumes that the program that altered the cloak
status sends the appropriate messages).

          Uns16   ShipCombatShieldLevel(Uns16 pID)
This returns the shield value for combat frim CLOAKC.HST. ShipCombatShieldLevel
will return 0 if no CLOAKC.HST was found (check IsCLOAKCFound()).


          void    SetShipCombatShieldLevel(Uns16 pID, Uns16 pShields)
This function sets the combat shield level of a ship. Since the shield
level is redetermined after all events that affect the damage of a ship
(repairs, movement, combat) it is intended to allow programs to manipulate
the shields in the auxbc phase. Note that this function will work
only with PHOST 3.2.3.3 or later (check GameFilesVersion())


           RaceType_Def ShipOwner(Uns16 pID)
This function returns the current owner of the given ship.

           Uns16 ShipSpeed(Uns16 pID)
This function returns the warp speed setting of the given ship.

           Uns16 ShipLocationX(Uns16 pID)
This function returns the X component of the given ship's position.

           Uns16 ShipLocationY(Uns16 pID)
This function returns the Y component of the given ship's position.

           Uns16 ShipWaypointX(Uns16 pID)
This function returns the X component of the given ship's destination. The
returned value is an *absolute* position, not a position relative to the
ship's current location.

           Uns16 ShipWaypointY(Uns16 pID)
This function returns the Y component of the given ship's destination. The
returned value is an *absolute* position, not a position relative to the
ship's current location.

           Int16 ShipRelWaypointX(Uns16 pID)
This function returns the X displacement component of the given ship's
waypoint. The returned value is a signed *relative* displacement, relative
to the ship's current position.

           Int16 ShipRelWaypointY(Uns16 pID)
This function returns the Y displacement component of the given ship's
waypoint. The returned value is a signed *relative* displacement, relative
to the ship's current position.

           Uns16 ShipHull(Uns16 pID)
This function returns the hull type of the given ship (in the range 1 to
HULL_NR).

           Uns16 ShipEngine(Uns16 pID)
This function returns the engine type of the given ship (in the range 1 to
ENGINE_NR).

           Uns16 ShipBeamType(Uns16 pID)
This function returns the type of beams on the given ship (in the range 1
to BEAM_NR).

           Uns16 ShipBeamNumber(Uns16 pID)
This function returns the number of beams mounted on the given ship.

           Uns16 ShipTorpType(Uns16 pID)
This function returns the type of torpedo launchers on the given ship (in
the range 1 to TORP_NR).

           Uns16 ShipTubeNumber(Uns16 pID)
This function returns the number of torpedo launchers on the given ship.

           Uns16 ShipBays(Uns16 pID)
This function returns the number of fighter bays on the given ship.

           Uns16 ShipAmmunition(Uns16 pID)
This function returns the number of torpedoes or fighters on the given
ship. If the ship has torpedo launchers, then this function returns the
number of torpedoes. If the ship has fighter bays, then this function
returns the number of fighters.

           ShipMission_Def ShipMission(Uns16 pID)
This function returns the current ship's mission.

           RaceType_Def ShipEnemy(Uns16 pID)
This function returns the primary enemy setting of the given ship.

           Uns16 ShipTowTarget(Uns16 pID)
This function returns the ship ID number of the ship that is specified as a
tow target of the given ship. If the given ship has no tow target, this
function returns 0. Note that it is NOT guaranteed that the returned value
represents an active ship that can legally be towed. Programs should
perform error checks before using the return value.

           Uns16 ShipInterceptTarget(Uns16 pID)
This function returns the ship ID number of the ship that is specified as
the given ship's intercept target. If the given ship is not intercepting
another ship, then this function returns 0. Note that it is NOT guaranteed
that the returned value represents an active ship that is visible to the
given ship's owner. Programs should perform error checks before using the
return value.

           Uns16 ShipDamage(Uns16 pID)
This function returns the damage level of the given ship.

           Uns16 ShipCrew(Uns16 pID)
This function returns the number of crew members on the given ship.

           Uns16 ShipDump(Uns16 pID, CargoType_Def pType)
This function returns the amount of the specified cargo to dump from the
given ship.

           Uns16 ShipDumpPlanet(Uns16 pID)
This function returns the planet number at which the given ship has been
set to dump cargo. If the planet number is 0, then the ship is jettisoning
cargo rather than dumping it at a planet.

           Uns16 ShipTransfer(Uns16 pID, CargoType_Def pType)
This function returns the amount of the specified cargo to transfer to
another ship. The ship to transfer to is determined by calling
ShipTransferShip().

           Uns16 ShipTransferShip(Uns16 pID)
This function returns the ship ID number of the ship to which the given
ship is transferring cargo. This function returns 0 if there is no ship to
ship transfer ocurring.

           char* ShipName(Uns16 pID, char* pName)
This function returns the name of the given ship. If the 'pName' parameter
is 0, then the name is stored in a temporary area which is overwritten with
each call to this routine. Otherwise, the name is stored in the area
pointed to by 'pName', which must be at least 21 characters long. The
return value of this routine points to either 'pName' if it is non-zero or
to the temporary area containing the ship's name.

           const char* ShipFC(Uns16 pID, char* pFCode)
This function returns the friendly code of the given ship. If the 'pFCode'
parameter is 0, then the friendly code is stored in a temporary area which
is overwritten with each call to this routine. Otherwise, the friendly code
is stored in the area pointed to by 'pFCode', which must be at least 4
characters long. The return value of this routine points to the
null-terminated friendly code string, either in 'pFCode' or in the
temporary area.

           Uns16 ShipCargo(Uns16 pID, CargoType_Def pType)
This routine returns the amount of the specified cargo on the given ship.

           Uns16 CreateShip(RaceType_Def pOwner)
This function activates a new ship ID. If all ship slots are full, then
this function returns 0. Otherwise, this function returns the ship ID of a
newly-created ship (which will be the lowest number that does not represent
an active ship). The new ship has no attributes set other than its ID and
its owner, which is specified in 'pOwner'. The hull type, weapons, engines,
etc. must all be set separately.

           void PutShipCargo(Uns16 pID, CargoType_Def pType, Uns16 pCargo)
This routine sets the specified cargo on the given ship to a new amount.

           void PutShipName(Uns16 pID, const char* pName)
This routine sets the given ship's name to a new value. The 'pName'
parameter must point to a null-terminated string. Only the first 20
characters will be used.

           void PutShipOwner(Uns16 pID, RaceType_Def pOwner)
This routine sets the given ship's owner to the specified value.

           void PutShipFC(Uns16 pID, char* pFCode)
This routine changes the given ship's friendly code to a new value. The
'pFCode' parameter must point to a null-terminated string. Only the first 3
characters are used.

           void PutShipSpeed(Uns16 pID, Uns16 pSpeed)
This routine changes the given ship's speed to a new value. The 'pSpeed'
parameter must be in the range 0 through 9.

           void PutShipWaypointX(Uns16 pID, Uns16 pWaypoint)
This routine sets the X component of an absolute waypoint for the ship.

           void PutShipWaypointY(Uns16 pID, Uns16 pWaypoint)
This routine sets the Y component of an absolute waypoint for the ship.

           void PutShipRelWaypointX(Uns16 pID, Int16 pRel)
This routine sets the X displacement of a relative waypoint for the ship
(relative to the ship's current position).

           void PutShipRelWaypointY(Uns16 pID, Int16 pRel)
This routine sets the Y displacement of a relative waypoint for the ship
(relative to the ship's current position).

           void PutShipLocationX(Uns16 pID, Int16 pLocation)
This routine sets the X component of the ship's position.

           void PutShipLocationY(Uns16 pID, Int16 pLocation)
This routine sets the Y component of the ship's position.

           void PutShipHull(Uns16 pID, Uns16 pHull)
This routine changes the ship's hull to the specified value (which must be
in the range 1 through HULL_NR).

           void PutShipEngine(Uns16 pID, Uns16 pEngine)
This routine sets the given ship's engine type to the specified value
(which must be in the range 1 through ENGINE_NR).

           void PutShipBeamType(Uns16 pID, Uns16 pBeamType)
This routine sets the given ship's beam weapon type to the specified value
(which must be in the range 1 through BEAM_NR).

           void PutShipBeamNumber(Uns16 pID, Uns16 pBeamNumber)
This routine sets the given ship's number of beam weapons to the specified
value.

           void PutShipTorpType(Uns16 pID, Uns16 pTorpType)
This routine sets the given ship's torpedo launcher type to the specified
value (which must be in the range 1 through TORP_NR).

           void PutShipTubeNumber(Uns16 pID, Uns16 pTubeNumber)
This routine sets the given ship's number of torpedo launchers to the
specified value.

           void PutShipBays(Uns16 pID, Uns16 pBays)
This routine sets the given ship's number of fighter bays to the specified
value. Note that a ship cannot have both fighter bays and torpedo
launchers.

           void PutShipAmmunition(Uns16 pID, Uns16 pAmmunition)
This routine sets the given ship's number of torpedoes or fighters to the
specified value. If the ship has torpedo launchers, then this function sets
the number of torpedoes. If the ship has bays, then this function sets the
number of fighters.

           void PutShipMission(Uns16 pID, ShipMission_Def pMission)
This function sets the given ship's mission.

           void PutShipEnemy(Uns16 pID, RaceType_Def pEnemy)
This function sets the given ship's primary enemy.

           void PutShipTowTarget(Uns16 pID, Uns16 pTarget)
This function specifies the ship ID number of the ship that the given ship
is trying to tow.

           void PutShipInterceptTarget(Uns16 pID, Uns16 pTarget)
This function specifies the ship ID number of the ship that the given ship
is trying to intercept.

           void PutShipDamage(Uns16 pID, Uns16 pDamage)
This function sets the damage level of the given ship. The damage level
must not exceed 150.

           void PutShipCrew(Uns16 pID, Uns16 pCrew)
This function sets the number of crew members on the given ship.

           void PutShipDump(Uns16 pID, CargoType_Def pType, Uns16 pCargo)
This function sets the amount of cargo that the given ship will dump or
jettison.

           void PutShipDumpPlanet(Uns16 pID, Uns16 pPlanet)
This function sets the planet at which the given ship will dump cargo. If
the planet number is given as 0, then the ship is jettisoning cargo rather
than dumping it to a planet.

           void PutShipTransfer(Uns16 pID, CargoType_Def pType, Uns16 pCargo)
This function sets the amount of cargo that the given ship will transfer to
another ship.

           void PutShipTransferShip(Uns16 pID, Uns16 pShip)
This function sets the target ship that is to receive all cargo that the
given ship is transferring.

Planet Accessors
----------------

The following functions all assume that the PDATA.HST and XYPLAN.DAT files
have been read from disk using the ReadHostData() and ReadGlobalData()
functions. Your program will likely crash if this assumption isn't met.

           Boolean IsPlanetExist(Uns16 pID)
This function returns True if the given parameter represents a valid planet
number (in the range 1 to PLANET_NR) and the planet is in play. All other
functions listed below assume that the planet specified by the function's
parameter is a valid planet. Only this function will accept a parameter
that is not a legal, active planet number.

           Uns16 PlanetLocationX(Uns16 pID)
This function returns the X component of the given planet's location.

           Uns16 PlanetLocationY(Uns16 pID)
This function returns the Y component of the given planet's location.

           RaceType_Def PlanetOwner(Uns16 pID)
This function returns the current owner of the given planet. The return
value may be 'NoOwner' if the planet is unowned.

           Uns16 PlanetMines(Uns16 pID)
This function returns the number of mines on the given planet.

           Uns16 PlanetFactories(Uns16 pID)
This function returns the number of factories on the given planet.

           Uns16 PlanetDefense(Uns16 pID)
This function returns the number of defense posts on the given planet.

           Uns32 PlanetCargo(Uns16 pID, CargoType_Def pType)
This function returns the amount of cargo of the given type on the planet.
Note that if the cargo type is COLONISTS, then the true number of colonists
(not clans) is returned.

           Uns32 PlanetCore(Uns16 pID, CargoType_Def pType)
This function returns the amount of the specified cargo in the given
planet's core.

           Uns16 PlanetDensity(Uns16 pID, CargoType_Def pType)
This function returns the mineral density of the specified mineral in the
given planet's core.

           Uns16 PlanetColTax(Uns16 pID)
This function returns the current colonist tax rate on the given planet.
The number is interpreted as a percentage so a return value of 5 means that
the tax rate is 5%.

           Uns16 PlanetNatTax(Uns16 pID)
This function returns the current native tax rate on the given planet. The
number is interpreted as a percentage so a return value of 5 means that the
tax rate is 5%.

           Int16 PlanetColHappy(Uns16 pID)
This function returns the happiness level of colonists on the given planet.
The return value is upper-bounded by 100.

           Int16 PlanetNatHappy(Uns16 pID)
This function returns the happiness level of natives on the given planet.
The return value is upper-bounded by 100.

           NativeType_Def PlanetNatType(Uns16 pID)
This function returns the type of natives on the given planet. If the
planet has no natives, then 'NoNatives' is returned.

           NativeGovm_Def PlanetNatGovm(Uns16 pID)
This function returns the type of native government on the given planet.

           Uns32 PlanetNativePopulation(Uns16 pID)
This function returns the number of natives on the given planet. Note that
the true number of natives, not clans, is returned.

           Uns16 PlanetTemp(Uns16 pID)
This function returns the given planet's temperature in the range 0 through
100.

           Boolean PlanetBuildBase(Uns16 pID)
This function returns True if the given planet is constructing a starbase
on this turn.

           Boolean PlanetHasNatives(Uns16 pPlanet)
This function returns True if the given planet has natives. This function
is just a short-cut for checking both PlanetNativePopulation() and
PlanetNatType().

           const char *PlanetName(Uns16 pID, char *pBuffer)
This function returns the given planet's name as a null-terminated string.
If the 'pBuffer' parameter is 0, then the planet's name is stored in a
temporary location that is overwritten with each call to this routine.
Otherwise, the planet's name is stored in 'pBuffer', which must point to an
area that is at least PLANETNAME_SIZE+1 characters in length.

           const char* PlanetFCode(Uns16 pID, char* pFCode)
This function returns the given planet's friendly code as a null-terminated
string. If the 'pFCode' parameter is 0, then the planet's friendly code is
stored in a temporary location that is overwritten with each call to this
routine. Otherwise, the planet's friendly code is stored in 'pFCode' which
must point to an area that is at least 4 characters in length.

           const char *PlanetTempString(Uns16 pPlanet)
This function returns a string that describes the planet's climate (e.g.,
"Arctic World", "Temperate - cool", etc.)

           void PutPlanetOwner(Uns16 pID, RaceType_Def pOwner)
This function sets the given planet's owner to the specified race. Note
that care must be exercised to take into account any starbase that may be
present at this planet.

           void PutPlanetFC(Uns16 pID, char* pFCode)
This function sets the given planet's friendly code to the string pointed
to by 'pFCode'. This parameter must point to a null-terminated string. Only
the first 3 characters are used.

           void PutPlanetMines(Uns16 pID, Uns16 pMines)
This function sets the number of mines on the given planet.

           void PutPlanetFactories(Uns16 pID, Uns16 pFactories)
This function sets the number of factories on the given planet.

           void PutPlanetDefense(Uns16 pID, Uns16 pDefense)
This function sets the number of defense posts on the given planet.

           void PutPlanetCargo(Uns16 pID, CargoType_Def pType, Uns32 pAmount)
This function sets the amount of the specified cargo on the surface of the
given planet. Note that for a cargo type of COLONISTS, the cargo amount
represents the true number of colonists, not clans. Also note, however,
that the colonist number is stored as clans, so that if the number of
colonists is not a multiple of 100, this number is divided by 100 and
truncated before being stored.

           void PutPlanetCore(Uns16 pID, CargoType_Def pType, Uns32 pAmount)
This routine sets the amount of a mineral in the given planet's core.

           void PutPlanetDensity(Uns16 pID, CargoType_Def pType, Uns16 pDensity)
This routine sets the given planet's mineral density. The density must be
in the range 10 through 100.

           void PutPlanetColTax(Uns16 pID, Uns16 pTax)
This routine sets the given planet's colonist tax rate. The tax rate must
be in the range 0 through 100.

           void PutPlanetNatTax(Uns16 pID, Uns16 pTax)
This routine sets the given planet's native tax rate. The tax rate must be
in the range 0 through 100.

           void PutPlanetColHappy(Uns16 pID, Int16 pHappy)
This routine sets the colonist happiness level on the given planet. The
happiness level must not exceed 100.

           void PutPlanetNatHappy(Uns16 pID, Int16 pHappy)
This routine sets the native happiness level on the given planet. The
happiness level must not exceed 100.

           void PutPlanetNatGovm(Uns16 pID, NativeGovm_Def pGovm)
This routine sets the type of native government on the given planet.

           void PutPlanetNativePopulation(Uns16 pID, Uns32 pPopulation)
This routine sets the number of natives on the given planet. Note that the
true number of natives must be specified, not the number of clans.

           void PutPlanetNatType(Uns16 pID, NativeType_Def pType)
This routine sets the natives' type on the given planet.

           void PutPlanetTemp(Uns16 pID, Uns16 pTemp)
This routine sets the given planet's temperature. The temperature must be
in the range 0 through 100.

           void PutPlanetBuildBase(Uns16 pID, Boolean pBuild)
This routine sets or clears the flag that indicates that the given planet
wishes to build a starbase on the current turn.

Starbase Accessors
------------------

The following functions all assume that the BDATA.HST file has been read
from disk using the ReadHostData() function. Your program will likely
crash if this assumption isn't met.

           Boolean IsBasePresent(Uns16 pID)
This function returns True if the given parameter represents a valid base
number (in the range 1 to PLANET_NR) and the base is physically present.
All other functions listed below (except for IsBaseExist()) assume that the
base specified by the function's parameter is a valid base. Only these two
functions will accept a parameter that is not a legal, active base number.

Note that a base may be physically present but not "active", meaning that
the corresponding planet is unowned. When a planet is owned, the
corresponding base must have the same owner, but it is possible for a base
to be owned and the corresponding planet to have no owner.

           Boolean IsBaseExist(Uns16 pID)
This function is identical to IsBasePresent() except that the given base
must also be owned by the corresponding planet's owner, in addition to
being physically present. That is, the base is "active" in that it can
defend the planet, produce ships, etc.

           void CreateBase(Uns16 pPlanet)
This function creates a starbase at the corresponding planet. There must
not already be a base physically present at that planet. The base owner is
set to be the same as the planet owner and all tech levels are set to 1.
Otherwise, all values for the new base are set to 0.

           void DeleteBase(Uns16 pID)
This function physically deletes a starbase. Everything on the base (ship
components, fighters, etc.) is lost.

           RaceType_Def BaseOwner(Uns16 pID)
This function returns a starbase's owner. This owner must match the
corresponding planet's owner when the planet is owned, otherwise it should
remain as the former owner of the planet.

           Uns16 BaseDefense(Uns16 pID)
This routine returns the number of defense posts on the starbase.

           Uns16 BaseDamage(Uns16 pID)
This routine returns the damage level of the starbase in the range 0
through 100.

           Uns16 BaseFighters(Uns16 pID)
This routine returns the number of fighters on the starbase.

           BaseMission_Def BaseOrder(Uns16 pID)
This routine returns the starbase's current mission.

           BaseFixMission_Def BaseFixOrder(Uns16 pID)
This routine returns an indication of whether the base is fixing or
recycling a ship.

           Uns16 BaseFixingShip(Uns16 pID)
This routine returns the ID number of a ship which the base is fixing or
recycling. If this routine returns 0, then there is no ship being fixed or
recycled.

           Uns16 BaseTech(Uns16 pID, BaseTech_Def pType)
This routine returns the level (in the range 1 through 10) of the
specified tech at the base.

           Uns16 BaseHulls(Uns16 pID, Uns16 pHullType)
This routine returns the number of hulls in storage at the given base. The
'pHullType' parameter must be in the range 1 through RACEHULLS and does not
represent a true hull number, but rather an index into the list of hull
numbers (accessible via the TrueHull() function).

           Uns16 BaseEngines(Uns16 pID, Uns16 pEngineType)
This routine returns the number of engines of the given tech (in the range
1 through ENGINE_NR) in storage at the given base.

           Uns16 BaseBeams(Uns16 pID, Uns16 pBeamType)
This routine returns the number of beams of the given tech (in the range 1
through BEAM_NR) in storage at the given base.

           Uns16 BaseTubes(Uns16 pID, Uns16 pTorpType)
This routine returns the number of torpedo launchers of the given tech (in
the range 1 through TORP_NR) in storage at the given base.

           Uns16 BaseTorps(Uns16 pID, Uns16 pTorpType)
This routine returns the number of torpedoes of the given tech (in the
range 1 through TORP_NR) in storage at the given base.

           Boolean BaseBuildOrder(Uns16 pID, BuildOrder_Struct *pOrder)
This routine returns True if the given base has a pending build order,
otherwise it returns False. If there is a pending build order, then the
build order is stored in the 'pOrder' structure (which must already have
been allocated).

           void PutBaseOwner(Uns16 pID, RaceType_Def pOwner)
This routine sets the new owner of a starbase. A starbase must always be
owned (i.e., 'pOwner' cannot be 'NoOwner') and a starbase's owner must
match the owner of the corresponding planet, when the planet is owned.

           void PutBaseDefense(Uns16 pID, Uns16 pDefense)
This routine sets the number of defense posts on the given base (which must
be in the range 0 through 200).

           void PutBaseDamage(Uns16 pID, Uns16 pDamage)
This routine sets the damage level of the given base (in the range 0
through 99).

           void PutBaseFighters(Uns16 pID, Uns16 pFighters)
This routine sets the number of fighters on the given base (in the range 0
through 60).

           void PutBaseOrder(Uns16 pID, BaseMission_Def pOrder)
This routine sets the given base's primary mission.

           void PutBaseFixOrder(Uns16 pID, BaseFixMission_Def pOrder)
This routine sets the given base's fix/recycle mission.

           void PutBaseFixingShip(Uns16 pID, Uns16 pShip)
This routine sets the ship ID number of the ship that is to be fixed or
recycled at the given base.

           void PutBaseTech(Uns16 pID, BaseTech_Def pType, Uns16 pTech)
This routine sets a tech level at the given base. Tech levels must be in
the range 1 through 10.

           void PutBaseHulls(Uns16 pID, Uns16 pHullType, Uns16 pNumber)
This routine sets the number of the given hull type at the given base. The
'pHullType' parameter must be in the range 1 through RACEHULLS and does not
represent a true hull number. This parameter represents an index into the
list of true hull numbers, which is accessible via the TrueHull() function.

           void PutBaseEngines(Uns16 pID, Uns16 pEngineType, Uns16 pNumber)
This routine sets the number of engines of the given tech (in the range 1
through ENGINE_NR) at the given base.

           void PutBaseBeams(Uns16 pID, Uns16 pBeamType, Uns16 pNumber)
This routine sets the number of beams of the given tech (in the range 1
through BEAM_NR) at the given base.

           void PutBaseTubes(Uns16 pID, Uns16 pTorpType, Uns16 pNumber)
This routine sets the number of torpedo launchers of the given tech (in the
range 1 through TORP_NR) at the given base.

           void PutBaseTorps(Uns16 pID, Uns16 pTorpType, Uns16 pNumber)
This routine sets the number of torpedoes of the given tech (in the range 1
through TORP_NR) at the given base.

           void PutBaseBuildOrder(Uns16 pID, BuildOrder_Struct *pOrderPtr)
This routine sets the given base's build order.

           void ClearBaseBuildOrder(Uns16 pID)
This routine clears any build order pending at the current base. Note that
this routine does not remove any build order from the build queue.

           void ClearBaseHulls(Uns16 pID)
This routine removes all hulls from storage at the given base.

Minefield Accessors
-------------------

The following functions all assume that the MINES.HST file has been read
from disk using the ReadHostData() function. Your program will likely
crash if this assumption isn't met.


           Uns16 GetNumMinefields(void)
This function returns the max number of minefields in the game.
It will return 500 if the configuration file wasn't read and
CPNumMinefields otherwise.

           Boolean IsMinefieldExist(Uns16 pID)
This function returns True if the minefield ID is lower than
CPNumMinefields (configuration variable) and the minefield 
with the given ID exists (i.e., has more than 0 units in it). 
The ID number must be in the range 1 through MINE_NR.

           double MinefieldRadius(Uns16 pID)
This function returns the radius of the given minefield.

           Uns16 MinefieldPositionX(Uns16 pID)
This function returns the X component of the center of the given minefield.

           Uns16 MinefieldPositionY(Uns16 pID)
This function returns the Y component of the center of the given minefield.

           RaceType_Def MinefieldOwner(Uns16 pID)
This function returns the race that owns the given minefield.

           Uns32 MinefieldUnits(Uns16 pID)
This function returns the number of units in the given minefield.

           Boolean IsMinefieldWeb(Uns16 pID)
This function returns True if the given minefield is a web mine, otherwise
it returns False.

           void PutMinefieldUnits(Uns16 pID, Uns32 pUnits)
This function sets the number of units in the given minefield. If the
number of units is set to 0, the minefield is considered to be gone.

           void PutMinefieldOwner(Uns16 pID, RaceType_Def pRace)
This function sets the owner of the minefield to the given race.

           Uns16 CreateMinefield(Uns16 pXloc, Uns16 pYloc,
                 RaceType_Def pRace, Uns32 pUnits, Boolean pIsWeb)
This function creates a new minefield. The (X,Y) components of the
minefield's center must be given, along with the owner race, the initial
number of units in the mine, and a flag indicating whether or not the
minefield is a web mine. The return value is the ID number of the new
minefield, or 0 if all minefield slots are used up and the minefield could
not be created.


Wormhole Accessors
------------------

These routines provide an interface to wormholes in PHOST. These routines
have no effect for games using HOST. These routines should not be invoked
unless ReadHostData() has been called.

                         ********** NOTE **********

          All of the wormhole functions are currently UNAVAILABLE in
          the Microsoft distribution of the PDK for DOS. The Borland
          distribution of the PDK for DOS has these functions, as do
          all of the non-DOS distributions.


           Uns16 NumWormholes(void)
This routine returns the number of wormholes in the game.

           Uns16 CreateWormhole(void)
This routine creates a new wormhole. If the maximum number of wormholes are
already in use, then this routine returns 0. Otherwise, a wormhole ID
number is returned. All parameters for this wormhole are set to 0.

           void DeleteWormhole(Uns16 pID)
This routine removes the wormhole with the given ID from play.

           Uns16 WormholeStabilityCode(Uns16 pID)
This routine returns a number in the range 0 through 4 indicating the
stability of the wormhole. The mapping of instability to the stability code
is as follows:
          Instability <= 5:  code 0
          Instability <= 15: code 1
          Instability <= 30: code 2
          Instability <= 50: code 3
          Instability <= 80: code 4

           Uns16 WormholeStartX(Uns16 pID)
This routine returns the X-position of a wormhole's starting location.

           Uns16 WormholeStartY(Uns16 pID)
This routine returns the Y-position of a wormhole's starting location.

           Uns16 WormholeEndX(Uns16 pID)
This routine returns the X-position of a wormhole's ending location.

           Uns16 WormholeEndY(Uns16 pID)
This routine returns the Y-position of a wormhole's ending location.

           Int16 WormholeMass(Uns16 pID)
This routine returns a wormhole's mass. This quantity may be negative,
indicating that the wormhole is unidirectional (i.e., travel is possible
only from start to end). In any case, the true mass should be computed as
the absolute value of the number returned by this routine.

           float WormholeInstability(Uns16 pID)
This routine returns the instability of the given wormhole in the range
[0,100].

           Uns16 WormholeWaypointStartX(Uns16 pID)
This routine returns the X-position of a wormhole starting position's
waypoint.

           Uns16 WormholeWaypointStartY(Uns16 pID)
This routine returns the Y-position of a wormhole starting position's
waypoint.

           Uns16 WormholeWaypointEndX(Uns16 pID)
This routine returns the X-position of a wormhole ending position's
waypoint.

           Uns16 WormholeWaypointEndY(Uns16 pID)
This routine returns the Y-position of a wormhole ending position's
waypoint.

           void PutWormholeStartX(Uns16 pID, Uns16 pX)
This routine changes the X-position of a wormhole's starting location.

           void PutWormholeStartY(Uns16 pID, Uns16 pY)
This routine changes the Y-position of a wormhole's starting location.

           void PutWormholeEndX(Uns16 pID, Uns16 pX)
This routine changes the X-position of a wormhole's ending location.

           void PutWormholeEndY(Uns16 pID, Uns16 pY)
This routine changes the Y-position of a wormhole's ending location.

           void PutWormholeMass(Uns16 pID, Int16 pMass)
This routine changes a wormhole's mass. If 'pMass' is negative, then the
actual mass is the magnitude of 'pMass', and the wormhole is marked as
being unidirectional (i.e., supports travel from start to end only).

           void PutWormholeInstability(Uns16 pID, float pInstability)
This routine changes a wormhole's instability. The instability must be in
the range [0,100].

           void PutWormholeWaypointStartX(Uns16 pID, Uns16 pX)
This routine sets the X-position of a wormhole's starting position
waypoint.

           void PutWormholeWaypointStartY(Uns16 pID, Uns16 pY)
This routine sets the Y-position of a wormhole's starting position
waypoint.

           void PutWormholeWaypointEndX(Uns16 pID, Uns16 pX)
This routine sets the X-position of a wormhole's ending position waypoint.

           void PutWormholeWaypointEndY(Uns16 pID, Uns16 pY)
This routine sets the Y-position of a wormhole's ending position waypoint.

Hull Accessors
--------------

These routines provide an interface to the hull data stored in the
HULLSPEC.DAT file. These routines should not be invoked unless the
ReadGlobalData() routine has been called. All hull number parameters
specified to these routines must be in the range 1 through HULL_NR.

           Uns16 HullPicnumber(Uns16 pHullNr)
This routine returns the bitmap number in the RESOURCE.PLN file
corresponding to the given hull number.

           Uns16 HullTritCost(Uns16 pHullNr)
This routine returns the amount of Tritanium required to build the given
hull.

           Uns16 HullDurCost(Uns16 pHullNr)
This routine returns the amount of Duranium required to build the given
hull.

           Uns16 HullMolyCost(Uns16 pHullNr)
This routine returns the amount of Molybdenum required to build the given
hull.

           Uns16 HullFuelCapacity(Uns16 pHullNr)
This routine returns the size of a given hull's fuel tank.

           Uns16 HullCrewComplement(Uns16 pHullNr)
This routine returns the maximum number of crew members that are allowed on
a given hull type.

           Uns16 HullEngineNumber(Uns16 pHullNr)
This routine returns the number of engines required on a given hull.

           Uns16 HullMass(Uns16 pHullNr)
This routine returns the mass of a given hull.

           Uns16 HullTechLevel(Uns16 pHullNr)
This routine returns the tech level required to build a given hull.

           Uns16 HullCargoCapacity(Uns16 pHullNr)
This routine returns the amount of cargo space available on a given hull.

           Uns16 HullBays(Uns16 pHullNr)
This routine returns the number of fighter bays on a given hull.

           Uns16 HullTubeNumber(Uns16 pHullNr)
This routine returns the maximum number of torpedo tubes that can be
mounted on the given hull.

           Uns16 HullBeamNumber(Uns16 pHullNr)
This routine returns the maximum number of beam weapons that can be mounted
on the given hull.

           Uns16 HullMoneyCost(Uns16 pHullNr)
This routine returns the number of megacredits required to build the given
hull.

           Uns16 TrueHull(RaceType_Def pRace, Uns16 pHullIndex)
This routine maps a race-specific hull number in the range 1 through
RACEHULLS to a true hull number in the range 1 through HULL_NR. If this
routine returns 0, then the given race hull index is unused for that race.

           const char* HullName(Uns16 pHullNr, char* pBuffer)
This routine returns the name of a given hull number. If 'pBuffer' is
non-NULL, then it must point to a previously allocated area of at least 31
bytes. The hull name is then stored in this area and the routine returns
'pBuffer'. If 'pBuffer' is NULL, then the hull name is stored in a
temporary area which is overwritten with each call to this routine. The
return value is then a pointer to this temporary area.

Engine Accessors
----------------

These routines provide an interface to the engine data stored in the
ENGSPEC.DAT file. These routines should not be invoked unless the
ReadGlobalData() routine has been called. All engine number parameters
specified to these routines must be in the range 1 through ENGINE_NR.

           char* EngineName(Uns16 pEngNr, char* pBuffer)
This routine returns the name of a given engine number. If 'pBuffer' is
non-NULL, then it must point to a previously allocated area of at least 21
bytes. The engine name is then stored in this area and the routine returns
'pBuffer'. If 'pBuffer' is NULL, then the engine name is stored in a
temporary area which is overwritten with each call to this routine. The
return value is then a pointer to this temporary area.

           Uns16 EngMoneyCost(Uns16 pEngNr)
This routine returns the number of megacredits required to build one engine
of the given type.

           Uns16 EngTritCost(Uns16 pEngNr)
This routine returns the amount of Tritanium required to build an engine of
the given type.

           Uns16 EngDurCost(Uns16 pEngNr)
This routine returns the amount of Duranium required to build an engine of
the given type.

           Uns16 EngMolyCost(Uns16 pEngNr)
This routine returns the amount of Molybdenum required to build an engine
of the given type.

           Uns16 EngTechLevel(Uns16 pEngNr)
This routine returns the minimum tech level required to build engines of
the given type.

           Uns32 EngFuelConsumption(Uns16 pEngNr, Uns16 pSpeed)
This routine returns a quantity that indicates the amount of fuel consumed
by an engine of the given type at the warp speed specified by 'pSpeed'.

Torpedo Accessors
-----------------

These routines provide an interface to the torpedo data stored in the
TORPSPEC.DAT file. These routines should not be invoked unless the
ReadGlobalData() routine has been called. All torpedo number parameters
specified to these routines must be in the range 1 through TORP_NR.

           char* TorpName(Uns16 pTorpNr, char* pBuffer)
This routine returns the name of a given torpedo number. If 'pBuffer' is
non-NULL, then it must point to a previously allocated area of at least 21
bytes. The torpedo name is then stored in this area and the routine returns
'pBuffer'. If 'pBuffer' is NULL, then the torpedo name is stored in a
temporary area which is overwritten with each call to this routine. The
return value is then a pointer to this temporary area.

           Uns16 TorpTorpCost(Uns16 pTorpNr)
This routine returns the number of megacredits required to build one
torpedo of the given type.

           Uns16 TorpTubeCost(Uns16 pTorpNr)
This routien returns the number of megacredits required to build one
torpedo launcher tube of the given type.

           Uns16 TorpTritCost(Uns16 pTorpNr)
This routine returns the amount of Tritanium required to build one tube of
the given type.

           Uns16 TorpDurCost(Uns16 pTorpNr)
This routine returns the amount of Duranium required to build one tube of
the given type.

           Uns16 TorpMolyCost(Uns16 pTorpNr)
This routine returns the amount of Molybdenum required to build one tube of
the given type.

           Uns16 TorpTubeMass(Uns16 pTorpNr)
This routine returns the mass of one tube of the given type.

           Uns16 TorpTechLevel(Uns16 pTorpNr)
This routine returns the minimum tech level required to build torpedoes and
tubes of the given type.

           Uns16 TorpKillPower(Uns16 pTorpNr)
This routine returns the amount of life-destroying power of the given
torpedo type.

           Uns16 TorpDestructivePower(Uns16 pTorpNr)
This routine returns the amount of structure-destroying power of the given
torpedo type.

Beam Weapon Accessors
---------------------

These routines provide an interface to the beam weapon data stored in the
BEAMSPEC.DAT file. These routines should not be invoked unless the
ReadGlobalData() routine has been called. All beam number parameters
specified to these routines must be in the range 1 through BEAM_NR.

           char* BeamName(Uns16 pBeamNr, char* pBuffer)
This routine returns the name of a given beam number. The 'pBuffer' parameter
must be non-NULL and must point to a previously allocated area of at least 21
bytes. The beam name is then stored in this area and the routine returns
'pBuffer'.

           Uns16 BeamMoneyCost(Uns16 pBeamNr)
This routine returns the amount of megacredits required to build a beam
weapon of the given type.

           Uns16 BeamTritCost(Uns16 pBeamNr)
This routine returns the amount of Tritanium required to build a beam
weapon of the given type.

           Uns16 BeamDurCost(Uns16 pBeamNr)
This routine returns the amount of Duranium required to build a beam weapon
of the given type.

           Uns16 BeamMolyCost(Uns16 pBeamNr)
This routine returns the amount of Molybdenum required to build a beam
weapon of the given type.

           Uns16 BeamMass(Uns16 pBeamNr)
This routine returns the mass of one beam weapon of the given type.

           Uns16 BeamTechLevel(Uns16 pBeamNr)
This routine returns the minimum tech level required to build a beam weapon
of the given type.

           Uns16 BeamKillPower(Uns16 pBeamNr)
This routine returns the amount of life-destroying power of the given
beam type.

           Uns16 BeamDestructivePower(Uns16 pBeamNr)
This routine returns the amount of structure-destroying power of the given
beam type.

Race Name Accessors
-------------------

These routines provide an interface to the race name data stored in the
RACE.NM file. These routines should not be invoked unless the
ReadGlobalData() routine has been called.

      const char* RaceLongName(RaceType_Def pRace, char* pBuffer)
This routine returns the full name of a race. If 'pBuffer' is non-NULL,
then the race name is also copied to this buffer, which must point to an
area at least 31 bytes long.

      const char* RaceShortName(RaceType_Def pRace, char *pBuffer)
This routine returns the short name of a race. If 'pBuffer' is non-NULL,
then the short race name is also copied to this buffer, which must point to
an area at least 21 bytes long.

      const char* RaceNameAdjective(RaceType_Def pRace, char *pBuffer)
This routine returns the adjective name of a race. If 'pBuffer' is
non-NULL, then the adjective name is also copied to this buffer, which must
point to an area at least 13 bytes long.

      void PutRaceLongName(RaceType_Def pRace, const char* pBuffer)
This routine modifies the long race name of the given race to the string
pointed to by 'pBuffer'. Only the first 30 characters of the new string are
used.

      void PutRaceShortName(RaceType_Def pRace, const char *pBuffer)
This routine modifies the short race name of the given race to the string
pointed to by 'pBuffer'. Only the first 20 characters of the new string are
used.

      void PutRaceNameAdjective(RaceType_Def pRace, const char *pBuffer)
This routine modifies the race name adjective of the given race to the
string pointed to by 'pBuffer'. Only the first 12 characters of the new
string are used.

Host Run Time Accessors
-----------------------

These routines provide an interface to the host run time and host turn
number. These routines should not be invoked unless the ReadHostData()
routine has been called.

              Uns16 TurnNumber(void)
This routine returns the current turn number.

              char *HostTimeStamp(char *pTimeStamp)
This routine stores the 18-character host run time information in the area
pointed to by 'pTimeStamp' which must be at least 18 characters long. There
is no NULL appended to this data. The return value of this routine is
'pTimeStamp'.

Enumeration Functions
---------------------

The following functions are provided simply as a service to programmers
because they are routines that are commonly used. All of the routines are
used for finding objects (ships, minefields, etc.). Routines that have a
return type of 'Uns16 *' all return a pointer to a temporary list of
integers, which is terminated by a 0 entry. This list is overwritten with
each call to ANY one of these functions so the values in the list should be
saved if necessary. For example, EnumerateShipsAt() returns a pointer to a
list of ships that all reside at one location in space. If there are 3
ships at this location, then the list will contain 3 Uns16 values
indicating the ship ID numbers, and a 4th value which is 0 (indicating the
end of the list). If there are no objects found, then the routines return a
pointer to a list containing only a single 0; the routines never return
NULL pointers.

Note that all of these routines are "wrap-map aware", meaning they respect
and properly implement the wraparound map feature of PHOST 3. The
gPconfigInfo->AllowWraparoundMap config option is checked so a prior call
to ReadHostData() must have been performed for wraparound map support to be
enabled.

           Uns16 *EnumerateShipsWithinRadius(Int16 pX, Int16 pY,
                               double pRadius)
This routine returns a list of all ships that are within a certain radius
of a given (X,Y) location.

           Uns16 *EnumerateShipsAt(Uns16 pX, Uns16 pY)
This routine returns a list of all ships that are located at the given
(X,Y) position.

           Uns16 *EnumerateMinesWithinRadius(Int16 pX, Int16 pY,
                               Uns16 pRadius)
This routine returns a list of all minefields that extend to within a given
radius of a certain (X,Y) location.

           Uns16 FindPlanetAtShip(Uns16 lShip)
This routine returns a single integer indicating the planet that the given
ship is orbiting. If the given ship is not at a planet, this routine
returns 0.

           Uns16 FindGravityPlanet(Int16 pX, Int16 pY)
This routine returns the first planet found that is within gravity well
range of the given (X,Y) co-ordinates.

           Uns16 *EnumeratePlanetsWithin(Int16 pX, Int16 pY, Uns16 pRadius)
This routine returns a list of all planets that are within the given radius
of a specified (X,Y) location.

           Uns16 *EnumerateShipsAtPlanet(Uns16 pPlanet)
This routine returns a list of all ships in orbit of the given planet.

           Uns16 *EnumerateMinesCovering(Int16 pX, Int16 pY)
This routine returns a list of all minefields that extend to the given
(X,Y) location.

           Uns16 *EnumerateOverlappingMines(Uns16 pMinefield)
This routine returns a list of all minefields that overlap the specified
minefield number.

External Message Interface
--------------------------

These routines manipulate the two external message files, MESS.EXT and
MESSPNT.EXT. These files contain messages that are read in by the host
program after the AUXHOST 2 phase. The SENDMESS program, for example, uses
these two files to store host-to-player messages. These routines, then, are
suitable for programs that run BEFORE RST files are generated.

           Boolean WriteExternalMessage(RaceType_Def pRace,
                            const char *pMessage)
This routine adds a plain text message to the message list for a given
player. The 'pMessage' parameter must point to a null-terminated text
string.

AUXHOST Message Interface
-------------------------

These routines add messages to a player's message list for programs that
execute as AUXHOST programs (that is, in the middle of host execution).
These routines, then, are suitable for programs that run DURING host
processing.

               Boolean WriteAUXHOSTMessage(RaceType_Def pRace,
                                                   const char *pMessage)
This routine adds a plain text message to the message list for a given
player. The 'pMessage' parameter must point to a null-terminated text
string.

RST Message Interface
---------------------

These routines add messages to a player's message list for programs that
run after the host has completed execution. These routines write their
messages directly to the player's RST files. These routines, then, are
suitable for programs that run AFTER host processing.

               Boolean WriteMessageToRST(RaceType_Def pRace, int pNumMsgs,
                                                   const char *pMessages[])
This routine adds plain text messages to the message list for a given
player. The 'pNumMsgs' parameter indicates the number of messages to
append, and the 'pMessages' array must contain a list of pointers to the
messages. Each message in this list is assumed to be a plain-text
null-terminated string not exceeding 840 characters (20 lines by 42
characters, with a 0Dh at the end of each line). The messages are written
to the player's RST file, but first a backup copy of the existing RST file
is made to the file 'PLAYERX.BAK'.

This routine may be called as often as necessary but it is a good idea to save
up all messages and only call this routine once as writing messages to an RST
file is a relatively slow operation.

NOTE: Usage of this routine is discouraged. The format of RST files has
been known to change in the past, making existing programs incompatible and
leading to bizarre errors on the player side. It is safest to never modify
RST files.

Build Queue Interface
---------------------

These routines are all involved with the PHOST-specific build queue. These
routines should not be called unless an AUXDATA.HST file was read (unless
only additions to the queue are performed). These routines have no effect
on games using HOST.

           Uns16 BuildQueuePeek(BaseOrder_Struct *pOrder)
This routine allows a look at the first build order in the build queue,
without actually modifying the build queue. The return value is the base ID
of the first build order. The 'pOrder' parameter must point to a previously
allocated area that is to hold the first build order, if any.

           void BuildQueuePush(BaseOrder_Struct *pOrderPtr)
This routine adds a build order to the build queue. If there is no build
order already in the queue for the given base, the given build order is
added at the end. If there is a build order already in the queue for the
given base, then if the new order is the same as the old order, nothing
happens. If the new order is different, the build order is handled
according to the priority build point system described in the BUILDQ.HTM
documentation file that comes with PHOST 3.

           void BuildQueueInvalidate(Uns16 pBase)
This routine removes a build order from the queue. The build order at the
specified base ID is removed.

           Uns16 ShipsInBuildQueue(void)
This routine returns the number of build orders in the queue.

           void SortBuildQueue(void)
This routine sorts all of the entries in the build queue in descending
order of priority (in the same way that PHOST 3 does). Note that this
routine does NOT take into account priority overrides via the PBn planetary
friendly codes.



Player Activity Level
---------------------

The PDK allows access to the player activity level (PAL). Access to the
turn activity level (TAL) is not possible, but may be added in future PDK
versions.

              Uns32 GetActivityLevel(Uns16 pRace);
This routine returns the activity level of a player.

              void  SetActivityLevel(Uns16 pRace, Uns32 pNewLevel);
This routine sets the activity level of a player.



Alliance Management
-------------------

These routines are all concerned with PHOST alliances. The PHOST alliance
information is stored in the AUXDATA.HST file, so meaningful information
will only be available if this file has been read. If this file is not
read, then all status functions will return False, and any changes made to
alliance status will not be saved since the AUXDATA.HST file is never
written if it has not been read. In any case, the Write_AuxData_File()
function must be called to save any changes in alliance status.

    void AllyAddRequest(RaceType_Def pPlayer, RaceType_Def pRace)
This routine indicates that the player 'pPlayer' is requesting an alliance
with 'pRace'. All alliance levels are disabled.

    void AllyDropRequest(RaceType_Def pPlayer, RaceType_Def pRace)
This routine withdraws the alliance that player 'pPlayer' has offered to
player 'pRace' and removes all levels of alliance.

    Boolean PlayerOffersAlliance(RaceType_Def pPlayer, RaceType_Def pRace)
This routine returns True if player 'pPlayer' has offered an alliance to
player 'pRace'. This will only be the case if AllyAddRequest() has been
called for these two players (i.e., AllyAddRequest(pPlayer, pRace)). The
specific levels of alliance that have/have-not been offered are not
relevant, it is simply the offer of alliance that is considered.

    Boolean PlayersAreAllies(RaceType_Def pPlayer, RaceType_Def pRace)
This routine returns True if both player 'pPlayer' and player 'pRace' have
offered alliances to each other. This routine is just a shorthand method of
writing:
                PlayerOffersAlliance(pPlayer, pRace)
             && PlayerOffersAlliance(pRace, pPlayer)

    Boolean IsAllyOfferAny(RaceType_Def pPlayer, RaceType_Def pRace,
                                        AllianceLevel_Def pLevel)
This routine returns True if player 'pPlayer' has offered the 'pLevel'
level of alliance to player 'pRace', in either the conditional or
unconditional form. The IsAllyOfferConditional() routine (below) can be
called to check on the conditional/unconditional status of the offer.

    Boolean IsAllyOfferConditional(RaceType_Def pPlayer, RaceType_Def pRace,
                                        AllianceLevel_Def pLevel)
This routine returns True if player 'pPlayer' has offered the 'pLevel'
level of alliance to player 'pRace' and if that offer has been made
conditionally. If either of these two conditions is False, then this
routine returns False.

    Boolean PlayerAllowsAlly(RaceType_Def pPlayer, RaceType_Def pRace,
                         AllianceLevel_Def pLevel)
This routine returns True if player 'pPlayer' has offered the 'pLevel' of
alliance to player 'pRace' unconditionally, or if the level has been
offered conditionally and the 'pRace' player has reciprocated. Note that it
is not sufficient to just call this routine in order to grant benefits to
allies, a call to PlayersAreAllies() must also be checked. The
PlayerAllowsAlly() routine may return True but unless the allied player has
also offered an alliance in return, PHOST does not consider the alliance to
be formed.

Note that this routine is just a shorthand method of writing:
          IsAllyOfferAny(pPlayer, pRace, pLevel)
       && (   (! IsAllyOfferConditional(pPlayer, pRace, pLevel))
           || (IsAllyOfferAny(pRace, pPlayer, pLevel))
          )

    void PutPlayerAllowsAlly(RaceType_Def pPlayer, RaceType_Def pRace,
                       AllianceLevel_Def pLevel, AllianceState_Def pState)
This routine indicates that player 'pPlayer' has offered, denied, or
conditionally offered (according to the setting of 'pState') the 'pLevel'
level of alliance to player 'pRace'.

Game Status
-----------

These routines return information about the game data itself.

               Boolean GameFilesVersion(Uns16 *pMajor, Uns16 *pMinor)
This routine returns the version number of the PHOST program that last
updated the game data files. The 'pMajor' and 'pMinor' parameters must
point to pre-allocated areas that will hold the major version and minor
version information, respectively. This routine can also be used to aid in
the determination of whether the game is being hosted with HOST or PHOST.

The validity of the information returned by this routine is conditional
upon the existence of an AUXDATA.HST file. Here are the various return
values that can occur and their dependence upon the AUXDATA.HST file:

     * If there is no attempt made to read the AUXDATA.HST file (by calling
       ReadHostData()) then this routine returns True and the major and
       minor versions are both reported as being 0.

     * If there is an attempt to read the AUXDATA.HST file (by calling
       ReadHostData()) but no AUXDATA.HST file exists then this routine
       returns False and no version information is provided.

       Thus, this routine returns False for games being hosted with HOST.
       Note, however, that the routine may also return False for PHOST
       games in which the AUXDATA.HST file has been deleted.

     * If there is an attempt to read the AUXDATA.HST file and the file
       exists (and is valid) then this routine returns True and version
       information is provided.

File Utility Functions
----------------------

These functions are not directly related to host processing but instead are
utility functions that programmers may find useful in managing game files.

           FILE *OpenInputFile(const char *pName, int pLocation)
This routine attempts to open a file in either the game or root directory.
If the file cannot be found, the program is terminated with an error
message (unless the 'pLocation' parameter contains the NO_MISSING_ERROR
flag, see below for more details). The 'pName' argument should contain a
simple filename (i.e., no pathname information). The location where the
filename is sought (game directory, root directory, or both) should be
specified by the 'pLocation' parameter. This parameter can consist of one
or more of the following constants OR'ed together:

    GAME_DIR_ONLY     -- This flag indicates that the file must be located
                         only in the game directory. The root directory is
                         not searched. The value of the 'gGameDirectory'
                         global variable is used to find the game
                         directory.

    ROOT_DIR_ONLY     -- This flag indicates that the file must be located
                         only in the root directory. The game directory is
                         not searched. The value of the 'gRootDirectory'
                         global variable is used to find the root
                         directory.

    GAME_OR_ROOT_DIR  -- This flag indicates that the file will be sought
                         first in the game directory, and then, if not
                         found, the root directory.

    TEXT_MODE         -- This flag indicates that the file is to be opened
                         as a text file, rather than a binary file (which
                         is the default) on operating systems that make a
                         distinction (i.e., DOS).

    NO_MISSING_ERROR  -- This flag indicates that OpenInputFile() should
                         not exit with an error if the file cannot be
                         found. The routine simply returns NULL in this
                         case.

           FILE *OpenOutputFile(const char *pName, int pLocation)
This routine attempts to create a file in either the game or root
directory. All of the flags used for OpenInputFile() have the same meaning
here but there are some differences:

    GAME_OR_ROOT_DIR  -- This flag may not be specified

    APPEND_MODE       -- This flag indicates that the file is to be opened
                         in append mode, adding to the end of any existing
                         file. By default, the file is opened in write
                         mode, overwriting any existing file.

           FILE *OpenUpdateFile(const char *pName, int pLocation)
This routine attempts to open a file for both reading and writing (i.e.,
update) in either the game or root directory. All of the flags mentioned
above are applicable with the following differences:

    GAME_OR_ROOT_DIR  -- This flag may not be specified

    REWRITE_MODE      -- This flag indicates that the file is to be opened
                         for rewriting (i.e., reading and writing at any
                         position). By default, the file is opened for
                         reading and writing only at the end of any
                         existing file.

           Boolean RemoveGameFile(const char *pName)
This routine attempts to remove the file with the given name in the game
directory only. If the file cannot be found or cannot be deleted, the
routine returns False.

           Boolean CopyFileToFile(FILE *pSrc, FILE *pDst, Uns32 pSize)
This routine copies data from one open file to another. The number of bytes
to copy is given by the 'pSize' parameter. This routine returns True if
successful, otherwise it prints an error message and returns False.

           Boolean CopyGameFile(const char *pSrcName, const char *pDstName)
This routine attempts to make a copy of a file in the game directory. The
'pSrcName' parameter gives the name of the existing file and 'pDstName'
gives the name of the file that is to receive the copy. The routine returns
True if the copy was successful, False otherwise.

           Boolean RenameGameFile(const char *OldName, const char *NewName)
This routine attempts to rename a game file from the name 'OldName' to the
name 'NewName'. The routine returns True if successful, False otherwise.

           Uns32 FileLength(FILE *lFile)
This routine returns the length of a file in bytes.

Memory Management
-----------------

These routines are not directly related to host processing but are provided
for convenience.

           void *MemAlloc(size_t pAmount)
This routine allocates the specified number of bytes from the pool of
available memory. If the required memory cannot be allocated, the program
is terminated with an error message. Thus, there is no reason to check the
return value from this routine for NULL.

           void *MemCalloc(size_t pNumber, size_t pSize)
This routine allocates 'pNumber' elements of 'pSize' bytes each from the
pool of available memory. The allocated memory is set to all 0's. If the
required memory cannot be allocated, the program is terminated with an
error message.

           void *MemRealloc(void *pPtr, size_t pAmount)
This routine resizes a previously allocated area (pointed to by 'pPtr') to
the number of bytes indicated by 'pAmount'. If the required memory cannot
be allocated, the program is terminated with an error message.

           void  MemFree(void *pPtr)
This routine deallocates a block of memory that was previously allocated
with MemAlloc() or MemCalloc(). If 'pPtr' is NULL, then nothing happens.

Messaging and Logging
---------------------

The following routines are not directly related to host processing but are
provided for convenience. These routines display messages to the user and
also log the messages to a log file, if enabled. By default, the messages
are sent to the standard output (stdout). If the 'gLogFile' global variable
points to a valid file, then the same message is also sent to this file.

           void Error(const char *pStr, ...)
This routine generates a message preceded by the string "Error: ". The
'pStr' string may contain printf-style format specifiers and a variable
number of arguments may follow 'pStr' to match these specifiers. For
example, "Error("bad parameter at line %u", lineNumber)" will generate the
message "Error: bad parameter at line 10" if 'lineNumber' is 10.

           void VError(const char *pStr, va_list pAP)
This routine is the same as Error() except that the variable argument list
is replaced with a va_list (stdarg.h usage).

           void ErrorExit(const char *pStr, ...)
This routine is the same as Error() except that the program is terminated
after the error message is displayed. The program exit code is set to -1.

           void VErrorExit(const char *pStr, va_list pAP)
This routine is the same as VError() except that the program is terminated
after the error message is displayed. The program exit code is set to -1.

           void Warning(const char *pStr, ...)
This routine is the same as Error() except that the string "Warning: " is
prepended to the output rather than "Error: ".

           void VWarning(const char *pStr, va_list pAP)
This routine is the same as Warning() except that the variable argument
list is replaced with a va_list (stdarg.h usage).

           void Info(const char *pStr, ...)
This routine is the same as Error() except that there is no string
prepended to the output message.

           void VInfo(const char *pStr, va_list pAP)
This routine is the same as Info() except that the variable argument list
is replaced with a va_list (stdarg.h usage).

           void passert(Boolean pExpr)
This routine is a replacement for the standard 'assert' function. If
'pExpr' is False, then ErrorExit() is called with an error message
indicating the file and line number of the statement. If the program has
been compiled with the constant NDEBUG defined to the preprocessor, then
'passert' does nothing, regardless of the value of 'pExpr'. This routine is
preferred over 'assert' because 'assert' usually calls 'abort' which does
not perform an orderly cleanup of the program.

Random Number Generation
------------------------

These routines are not directly related to host processing but are provided
for convenience. These routines allow for the portable generation of random
numbers. Since the range of native random number generators on different
platforms varies, these routines allow the same code to work on all
platforms. Furthermore, the underlying mechanisms of random number
generation are different on various platforms, but the following routines
all behave the same way on all platforms. Thus, the same pseudo-random
sequence will be obtained from a given starting seed regardless of which
platform is being used.

           void SetRandomSeed(Uns16 seed)
This routine sets the random number generator's seed to a specified value.

           RandType_Def RandomRange(RandType_Def pRange)
This routine returns a pseudo-random integer in the range 0 through
(pRange-1) inclusive. The pRange parameter must be in the range [1,32767].

           double RandomReal(void)  (UNAVAILABLE in Microsoft-DOS)
This routine returns a floating-point random number in the range [0,1).
That is, 0 may be returned, but 1 may not.

Cross-Platform Portability
--------------------------

These routines are not directly related to host processing but are provided
for convenience. These routines are meant to aid in writing portable
programs.

           void WordSwapLong(void *pData, Uns16 pNumWords)
This routine switches the byte order of 32-bit words if the system on which
the program is running is big-endian. On little-endian systems, this
routine does nothing. The 'pData' parameter points to the memory that is to
be swapped, and 'pNumWords' indicates the number of 32-bit words at this
memory location that are to be swapped. This routine is provided for making
programs endian-aware. When data is received from or sent to a DOS
platform, it must be in little-endian format. However, some platforms are
big-endian. Thus, this routine can be used to swap the byte order to or
from little-endian format before or after processing.

           void WordSwapShort(void* pData, Uns16 pNumWords)
This routine switches the byte order of 16-bit words if the system on which
the program is running is big-endian. On little-endian systems, this
routine does nothing. The 'pNumWords' parameter indicates the number of
16-bit words which are to be byte-swapped.

           Boolean DOSRead16(Uns16 *pData, Uns16 pNum, FILE *pInFile)
This routine reads 'pNum' 16-bit words from the file 'pInFile' and stores
them in the area pointed to by 'pData', which must have been previously
allocated. The data is assumed to have been generated on a DOS (i.e., IBM
PC compatible) machine. The data is byte-swapped if necessary before the
routine returns, so that the data may be accessed in the native mode of the
machine on which the program is running. This routine returns True if
successful, False otherwise.

           Boolean DOSRead32(Uns32 *pData, Uns16 pNum, FILE *pInFile)
This routine reads 'pNum' 32-bit words from the file 'pInFile' and stores
them in the area pointed to by 'pData', which must have been previously
allocated. The data is assumed to have been generated on a DOS (i.e., IBM
PC compatible) machine. The data is byte-swapped if necessary before the
routine returns, so that the data may be accessed in the native mode of the
machine on which the program is running. This routine returns True if
successful, False otherwise.

           Boolean DOSWrite16(Uns16 *pData, Uns16 pNum, FILE *pOutFile)
This routine writes 'pNum' 16-bit words to the file 'pOutFile' from the
area pointed to by 'pData'. The data is written out in a format expected by
DOS (i.e., IBM PC compatible) machines. The data is byte-swapped if
necessary prior to writing to 'pOutFile', then byte-swapped again to return
the data to the native format of the machine. Thus, the contents of 'pData'
remain unchanged. The routine returns True if successful, False otherwise.

           Boolean DOSWrite32(Uns32 *pData, Uns16 pNum, FILE *pOutFile)
This routine writes 'pNum' 32-bit words to the file 'pOutFile' from the
area pointed to by 'pData'. The data is written out in a format expected by
DOS (i.e., IBM PC compatible) machines. The data is byte-swapped if
necessary prior to writing to 'pOutFile', then byte-swapped again to return
the data to the native format of the machine. Thus, the contents of 'pData'
remain unchanged. The routine returns True if successful, False otherwise.

Command-Line Option Processing
------------------------------

        int pgetopt(int argc, char *argv[], char *optstring)
Users familiar with the common 'getopt()' routine found on many systems
will find this routine to be very similar. This routine is provided so that
programs can be portable to all platforms, rather than just the ones on
which 'getopt()' exists (which are fewer than one would hope).

This routine can be used to simplify the processing of command-line
options. The 'argc' and 'argv' parameters are simply the same as the ones
presented to the 'main()' function of the program. The 'optstring'
parameter indicates which command-line options are valid. This string
consists of characters that indicate valid options. Option characters are
case sensitive.

Each call to this routine returns one of the following:

     - a character found in 'optstring'. This means that the next command
       line option is the character itself.

     - the special character '?'. This means that the next command line
       option is a character not found in 'optstring'. An error message has
       already been displayed in this case.

     - EOF. This means that there are no more command line options.

After each call to 'pgetopt()', the global variable 'poptind' is an index
into 'argv' indicating the current command line parameter. After
'pgetopt()' returns EOF, 'poptind' points to the first non-option parameter
on the command line. That is, 'argv[poptind]' is the first parameter that
is not a command-line option.

There is one provision for command-line options that take parameters. If a
character in the 'optstring' string is followed by ':', then this option
requires a parameter. In this case, when 'pgetopt()' is processing this
option, the global variable 'poptarg' points to the command-line parameter
that is the argument of the option.

Here is a brief example on 'pgetopt()' usage. For better examples, please
see the EX*.C files (for example, EX6.C).

------------------------------------------------------------------------
        int c;

        // Command line usage is:
        //                    program [options] gamedir {rootdir}
        // options:     -h OR -H   -- get help
        //              -v         -- print version
        //              -n N       -- specify number N (parameter)
        //              -x         -- specify option X
        while ((c = pgetopt(argc, argv, "hHvn:x")) != EOF) {
            switch (c) {
             case 'h': case 'H': case '?': default:
                  printHelpText();
                  exit(0);

             case 'v':
                  printVersionInfo();
                  break;

             case 'n':
                  Number = atoi(poptarg);
                  break;

             case 'x':
                  OptionX = 1;
                  break;
            }
        }
        if (poptind < argc) {
            gGameDirectory = argv[poptind++];
        } else ErrorExit("Must specify game directory");

        if (poptind < argc) {
           gRootDirectory = argv[poptind++];
        } else return;

        if (poptind < argc) {
           ErrorExit("Too many parameters on command line");
        }
------------------------------------------------------------------------

Combat Interface (NOT AVAILABLE in Microsoft-DOS)
----------------

The PDK library contains a 'combat module' which implements combat in
exactly the same way as PHOST. Any code that calls the Combat() API routine
(see below) automatically links in this combat module. By linking in the
combat module, however, the PDK expects the user code to define several
functions that take action depending upon certain combat events. The
example source file EX6.C is a good introduction to interfacing with the
combat module.

       void Combat(Combat_Struct *pShip1, Combat_Struct *pShip2)
The Combat() routine is the main component of the combat module. It
performs a battle between two ships or between a ship and planet (in which
case the planet must always be represented by the second parameter to this
routine, 'pship2'). Prior to calling Combat(), the calling code must fill
in the values of two Combat_Struct structures (see PHOSTPDK.H for more info
on the contents of these structures).

Combat() has no return value but the outcome of the battle for each
ship/planet is stored in the 'Outcome' field of the corresponding
Combat_Struct structure.

Combat() correctly handles the 3X kill bonus of the Privateers and the 150%
damage limit for the Lizards, but other factors that affect pre-combat
conditions (such as the Fed crew bonus effect on mass, shields, etc.) are
not considered. These effects must be computed and reflected in the values
passed to Combat() via the Combat_Struct structures.

                             *** NOTE ***
                 A prior call to ReadGlobalData() and
                 ReadHostData() must be performed prior
                 to calling Combat().

The following routines are not included in the PDK. Rather, they define
routines that the user must provide in any code that uses the combat module
(in Windows parlance, they are "callback" routines). If only the results of
combat are of interest, then these routines can all be defined to do
nothing; Combat() does not require these routines to do anything. The EX6.C
example program shows how to define these routines to display a textual
commentary on a running battle, for example.

The following conventions apply to the following routines:

     * The 'pShip' parameter is either 0 or 1. The value 0 represents the
       ship described by the first parameter to Combat(), while the value
       1 represents the ship or planet described by the second parameter to
       Combat().

     * Distance and positions of objects is measured in meters. Ship 0
       (i.e., the ship described by the first parameter to Combat()) begins
       battle at the position -29000 meters while ship 1 begins battle at
       position 29000. If ship 1 is actually a planet, it does not move
       from its initial position, of course. Distance is always a positive
       32-bit measure, but position may be positive or negative (also a
       32-bit measure).

     * The word 'ship' can just as easily mean 'planet' or 'base' in the
       subsequent descriptions. The single word 'ship' is used for brevity.

     * All indices are 0-based. For example, the 'pBeam' parameter in some
       routines is in the range [0,NumBeams-1].

       void DrawInitBeams(Uns16 pShip, Uns16 pNumBeams, Uns16 pCharge)
This routine is called by Combat() before combat begins to indicate the
charge status of a ship's beams. The 'pNumBeams' parameter indicates the
number of beams, the 'pCharge' parameter indicates the initial charge (0
means fully discharged, 100 means fully charged).

       void DrawInitTubes(Uns16 pShip, Uns16 pNumTubes, Uns16 pCharge)
This routine is called by Combat() before combat begins to indicate the
charge status of a ship's torpedo tubes. The 'pNumTubes' parameter
indicates the number of tubes, the 'pCharge' parameter indicates the
initial charge (0 means fully discharged, 100 means fully charged).

       void DrawBeamRecharge(Uns16 pShip, Uns16 pBeam, Uns16 pCharge)
This routine is called by Combat() during a battle to indicate a new charge
level for a given beam 'pBeam'. The new charge level is in the range 0
(fully discharged) to 100 (fully charged). This routine is called very
often; optimizing the code in this routine is highly recommended.

       void DrawTubeRecharge(Uns16 pShip, Uns16 pTube, Uns16 pCharge)
This routine is called by Combat() during a battle to indicate a new charge
level for a given torpedo tube 'pTube'. The new charge level is in the
range 0 (fully discharged) to 100 (fully charged). This routine is called
very often; optimizing the code in this routine is highly recommended.

       void DrawBayRecharge(Uns16 pShip, Uns16 pBay, Uns16 pCharge)
This routine is called by Combat() during a battle to indicate a new charge
level for a given fighter bay 'pBay'. The new charge level is in the range
0 (fully discharged) to 100 (fully charged). This routine is called very
often; optimizing the code in this routine is highly recommended.

       void DrawFighterAttack(Uns16 pShip, Uns16 pFighter, Int32 pPos)
This routine is called by Combat() to indicate that fighter 'pFighter'
belonging to ship 'pShip' has advanced to position 'pPos'. A fighter is
"attacking" when it is moving towards the enemy. This means that attacking
fighters move in different directions depending upon which ship they belong
to (attacking fighters belonging to ship 0 move towards more positive
positions, attacking fighters belonging to ship 1 move towards more
negative positions). This routine is called very often; optimizing the code
in this routine is highly recommended.

       void DrawEraseFighterAttack(Uns16 pShip, Uns16 pFighter, Int32 pPos)
This routine is called by Combat() to indicate that fighter 'pFighter'
belonging to ship 'pShip' is no longer at the given position. The fighter
is still "attacking" however (see DrawFighterAttack() above). Combat()
moves a fighter by repeatedly calling DrawEraseFighterAttack() with its old
position followed by DrawFighterAttack() with its new position. This
routine is called very often; optimizing the code in this routine is highly
recommended.

       void DrawFighterReturn(Uns16 pShip, Uns16 pFighter, Int32 pPos)
This routine is called by Combat() to indicate that fighter 'pFighter'
belonging to ship 'pShip' has advanced to position 'pPos'. A fighter is
"returning" when it is moving away from the enemy and back to the owner
ship. This means that returning fighters move in different directions
depending upon which ship they belong to (returning fighters belonging to
ship 0 move towards more negative positions, returning fighters belonging
to ship 1 move towards more positive positions). This routine is called
very often; optimizing the code in this routine is highly recommended.

       void DrawEraseFighterReturn(Uns16 pShip, Uns16 pFighter, Int32 pPos)
This routine is called by Combat() to indicate that fighter 'pFighter'
belonging to ship 'pShip' is no longer at the given position. The fighter
is still "returning" however (see DrawFighterReturn() above). Combat()
moves a fighter by repeatedly calling DrawEraseFighterReturn() with its old
position followed by DrawFighterReturn() with its new position. This
routine is called very often; optimizing the code in this routine is highly
recommended.

       void DrawShipShields(Uns16 pShip, Int32 pPos, double pShields)
This routine is called by Combat() when a ship's shield level has changed.
The 'pPos' parameter indicates the current ship's position, while
'pShields' indicates the new shield level.

       void DrawShipDamage(Uns16 pShip, double pDamage)
This routine is called by Combat() when a ship's damage level has changed.
The 'pPos' parameter indicates the current ship's position, while 'pDamage'
indicates the new damage level.

       void DrawShipCaptured(Uns16 pShip)
This routine is called by Combat() when a ship's crew has fallen to 0 and
the battle ends since the given ship has been captured.

       void DrawShipDestroyed(Uns16 pShip, Int32 pPos, Boolean pIsPlanet)
This routine is called by Combat() when a ship's damage level is
sufficiently high so that the ship explodes.

       void DrawStalemateResult(Boolean pIsPlanet2)
This routine is called by Combat() when both ships have run out of
ammunition (i.e., both ships have no beams, no torpedoes, and no fighters
left).

       void DrawShipCrew(Uns16 pShip, double pCrew)
This routine is called by Combat() when a ship's crew count has changed.

       void DrawTorpNumber(Uns16 pShip, Uns16 pTorps)
This routine is called by Combat() when the number of torpedoes on a ship
changes.

       void DrawFighterNumber(Uns16 pShip, Uns16 pFighters)
This routine is called by Combat() when the number of fighters on a ship
changes.

       void DrawFighterHit(Uns16 pShip, Uns16 pFighter, Int32 pPos,
                                                             Int32 pEnemyPos)
This routine is called by Combat() when a fighter belonging to ship 'pShip'
scores a hit on the enemy ship. The fighter itself is at position 'pPos',
the enemy ship is at position 'pEnemyPos'. The fighter number is given by
'pFighter'.

       void DrawFighterHitFighter(Int32 pPos, Uns16 pFighter1, Uns16 pFighter2)
This routine is called by Combat() when a fighter destroys another (enemy)
fighter. The two fighters are both at or near position 'pPos'. The fighter
that is destroyed is given by 'pFighter2', while 'pFighter1' gives the
fighter that has destroyed the other. A call to DrawEraseFighter...() will
follow this call to remove the destroyed fighter from the display.

       void DrawTorpHit(Uns16 pShip, Int32 pPos, Int32 pEnemyPos)
This routine is called when ship 'pShip' at position 'pPos' scores a
torpedo hit on the enemy at position 'pEnemyPos'.

       void DrawTorpMiss(Uns16 pShip, Int32 pPos, Int32 pEnemyPos)
This routine is called when ship 'pShip' at position 'pPos' launches a
torpedo on the enemy at position 'pEnemyPos' but the torpedo misses.

       void DrawBeamHitFighter(Uns16 pShip, Uns16 pBeam, Int32 pPos,
                                    Uns16 pFighter, Int32 pEnemyFighterPos)
This routine is called when ship 'pShip' at position 'pPos' fires beam
number 'pBeam' to destroy the enemy fighter 'pFighter' at position
'pEnemyFighterPos'. A call to DrawEraseFighter...() will follow this call
to remove the destroyed fighter from the display.

       void DrawBeamMissedFighter(Uns16 pShip, Uns16 pBeam, Int32 pPos,
                                    Uns16 pFighter, Int32 pEnemyFighterPos)
This routine is called when ship 'pShip' at position 'pPos' fires beam
number 'pBeam' towards the enemy fighter 'pFighter' at position
'pEnemyFighterPos' but the beam weapon misses.

       void DrawBeamHitShip(Uns16 pShip, Int32 pPos, Int32 pEnemyPos)
This routine is called when ship 'pShip' at position 'pPos' fires and hits
the enemy ship at position 'pEnemyPos'.

       void DrawBeamMissedShip(Uns16 pShip, Int32 pPos, Int32 pEnemyPos)
This routine is called when ship 'pShip' at position 'pPos' fires and
misses the enemy ship at position 'pEnemyPos'.

       void DrawShip(Uns16 pShip, Int32 pPos)
This routine is called to draw the given ship at the given position. The
ship is moved on the battlefield by repeatedly calling DrawEraseShip() (see
below) with the ship's old position followed by DrawShip() with the new
position.

       void DrawEraseShip(Uns16 pShip, Int32 pPos)
This routine is called to erase the given ship at the given position. The
ship is moved on the battlefield by repeatedly calling DrawEraseShip() with
the ship's old position followed by DrawShip() with the new position.

       void DrawDistance(Int32 pDist)
This routine is called to update the display of distance between the two
ships.

Remote Control Interface
------------------------

The remote control interface functions give the application access to PHOST
3's remote control features. For more details, please see the REMOTE.HTM
documentation file that comes with PHOST 3.

       Boolean BeginShipRemoteControl(Uns16 pShipID, Uns16 pRemoteOwner)
This function initiates a remote control on a given ship. The
'pRemoteOwner' parameter indicates the player number of the remote
controller. This function returns True if successful, or False if the
remote control operation failed for any one of the following reasons:
       - The original ship owner has forbidden remote control
       - The remote controller is the same as the ship's owner
       - The required levels of alliance are not satisfied

       Boolean EndShipRemoteControl(Uns16 pShipID, Uns16 pRemoteOwner)
This function terminates a previously-established remote control on a given
ship. The 'pRemoteOwner' parameter indicates the number of the player
initiating the request to terminate the remote control. This must match the
current remote control player else the function fails (and returns False).
If the function succeeds it returns True.

       Boolean IsShipRemoteControlled(Uns16 pShip)
This function returns True if the given ship number is under remote
control.
       
       Boolean IsShipRemoteForbidden(Uns16 pShip)
This function returns True if the given ship is forbidden from being
controlled.

       void    ResetShipRemoteControl(Uns16 pShip)
This function removes all remote-control information about a ship (its
original owner, whether remote control is forbidden, etc.) Calling this
function is appropriate when a ship is destroyed, when a new ship is
created, etc.

       Boolean AllowShipRemoteControl(Uns16 pShipID, Uns16 pOrigOwner)
This function enables remote control on a ship, resetting any previous
forbid order. The 'pOrigOwner' parameter is the number of the player
initiating this request and must match the original ship's owner for the
function to succeed. If the function succeeds, it returns True.

       Boolean ForbidShipRemoteControl(Uns16 pShipID, Uns16 pOrigOwner)
This function forbids remote control on a ship. The 'pOrigOwner' parameter
is the number of the player initiating this request and must match the
original ship's owner for the function to succeed. If the function
succeeds, it returns True.

       Uns16   ShipRemoteController(Uns16 pShipID)
This function returns the number of the player currently possessing remote
control of a ship, or 0 if the ship is not under remote control.

       Uns16   ShipRemoteOwner(Uns16 pShipID)
This function returns the original owner of a ship that is currently under
remote control.

Config File Reader Interface
----------------------------

The config file reader interface allows application programs to parse
configuration files of the same structure as PCONFIG.SRC with a minimum of
effort. This frees programmers from having to "reinvent the wheel" and
incorporate a text-file parser into every new application.

       void ConfigFileReader(FILE *pInFile,
                             const char *pFileName,
                             const char *pSection,
                             Boolean pUseDefaultSection,
                             configAssignment_Func pAssignFunc)
This function implements a config file reader. The 'pInFile' argument
is a handle to previously-opened text file. The 'pFileName' argument gives
the name of this text file and is used only for error reporting. The
'pSection' argument is a string indicating the section name that your
program is looking for. This indicates a line of the form:

           % MYNAME

in the config file that indicates the beginning of configuration
information relevant to your program. For example, PHOST uses a name of
"PHOST" for the main config data in PCONFIG.SRC and "PCONTROL" for the
fine-grain hosting control config data.

The 'pUseDefaultSection' indicates whether or not the section name in
'pSection' is required to be found in the config file or whether a config
file without any section information will apply to your program. For
example, PHOST sets 'pUseDefaultSection' to True so that even if '% PHOST'
does not appear in the config file, the config file reader assumes the
config data applies to PHOST. If you expect your config data to reside in
the PCONFIG.SRC file, you must set 'pUseDefaultSection' to False. If you
will read a different config file, specific to your application, you may
set 'pUseDefaultSection' to True.

The 'pAssignFunc' parameter is a pointer to an assignment function with the
following prototype (defined in PHOSTPDK.H):

       Boolean AssignFunc(const char *lhs, char *rhs, const char *lInputLine)

The name 'AssignFunc' should be replaced with a function name of your own
choosing. This function should work as follows:

  * When 'lhs' and 'rhs' are both 0 (i.e., NULL), this indicates that the
    config file reader has encountered a blank line, a comment line (line
    beginning with '#'), or a section line (line beginning with '%'). A
    copy of the input line is given in the 'lInputLine' parameter. The
    assignment function is not required to do anything (but it may, for
    example, copy the input line to a backup file). For this case, the
    return value of the assignment function is not used.

  * When 'lhs' and 'rhs' are not 0, then 'lhs' is a pointer to string
    describing the left-hand-side of an assignment and 'rhs' is a pointer
    to the string describing the right-hand-side of an assignment. Once
    again, 'lInputLine' is a copy of the entire input line. The return
    value of the assignment function should be True if the parameters
    indicate a valid assignment or False if there is an error. In the
    latter case, the config file reader calls ErrorExit() with the name of
    the input file (given by 'pFileName') and the line number at which the
    error occurred. The assignment function should indicate more specific
    error information prior to returning False.

Special Ship Function Accessors
-------------------------------

These functions indicate whether a given ship is capable of a special
function, such as alchemy or terraforming. Whereas in HOST and PHOST v2.x
these functions were tied to specific hull numbers, the HULLFUNC.TXT
interface in PHOST 3 allows more flexibility. These functions, then,
replace the now-obsolete HullDoesXXXX() functions in version 2 of the PDK.
The HULLFUNC.TXT file is read by ReadHostData() hence the latter must have
been called for any of these accessors to return meaningful data. If the
HULLFUNC.TXT file is not present, the usual (HOST compatible) special hull
function assignments are in effect.

                            ****************
                            ***** NOTE *****
                            ****************

  The HullDoesXXX() functions took a hull number argument, like this:

           HullDoesAlchemy(ShipHull(ShipID))

  The ShipDoesXXX() functions take a ship number argument, like this:

           ShipDoesAlchemy(ShipID)


           Boolean ShipDoesAlchemy(Uns16 pShipNr)
This routine returns True if the given ship is an alchemy ship.

           Boolean ShipDoesRefinery(Uns16 pShipNr)
This routine returns True if the given ship is a neutronic refinery ship.

           Boolean ShipHeatsTo50(Uns16 pShipNr)
This routine returns True if the given ship is a terraformer that warms
planets to 50 degrees.

           Boolean ShipCoolsTo50(Uns16 pShipNr)
This routine returns True if the given ship is a terraformer that cools
planets to 50 degrees.

           Boolean ShipHeatsTo100(Uns16 pShipNr)
This routine returns True if the given ship is a terraformer that heats
planets to 100 degrees.

           Boolean ShipCanHyperwarp(Uns16 pShipNr)
This routine returns True if the given ship has hyperwarp capability.

           Boolean ShipIsGravitonic(Uns16 pShipNr)
This routine returns True if the given ship has gravitonic capability.

           Boolean ShipScansAllWormholes(Uns16 pShipNr)
This routine returns True if the given ship has advanced wormhole scanning
equipment and can scan all detectable wormholes in a single turn.

           Boolean ShipCanCloak(Uns16 pShipNr)
This routine returns True if the given ship is capable of cloaking.

           Boolean ShipDoesAdvancedRefinery(Uns16 pShipNr)
This routine returns True if the given ship is capable of advanced refinery
(such as for the Aries Class ship).

           Boolean ShipIsGamblingShip(Uns16 pShipNr)
This routine returns True if the given ship is capable of generating
megacredits for clans that are on board (from gambling revenue).

           Boolean ShipIsAntiCloaking(Uns16 pShipNr)
This routine returns True if the given ship emits tachyon pulses that
uncloak nearby ships.

           Boolean ShipDoesImperialAssault(Uns16 pShipNr)
This routine returns True if the given ship is capable of performing the
Imperial Assault mission.

           Boolean ShipDoesChunneling(Uns16 pShipNr)
This routine returns True if the given ship is able to perform chunneling.

           Boolean ShipHasRamScoop(Uns16 pShipNr)
This routine returns True if the given ship is outfitted with a fuel
ramscoop and can create fuel as it travels through space.

           Boolean ShipDoesBioscan(Uns16 pShipNr)
This routine returns True if the given ship is able to perform Bioscanning.

           Boolean ShipDoesFullBioscan(Uns16 pShipNr)
This routine returns True if the given ship can Bioscan all planets within
range.

           Boolean ShipHasAdvancedCloak(Uns16 pShipNr)
This routine returns True if the given ship has a cloaking device that
requires no fuel to operate.

           Boolean ShipHasGloryDevice(Uns16 pShipNr)
This routine returns True if the given ship has a "low-energy" glory device
that causes 10% of damage to own-player ships.

           Boolean ShipHasHEGloryDevice(Uns16 pShipNr)
This routine returns True if the given ship has a "high-energy" glory
device that causes 20% of damage to own-player ships.

Wraparound Map Functions
------------------------

The following functions support the wraparound map feature of PHOST 3. They
are intended to simplify distance and position calculations in your own
program when a wraparound map is in effect. Note that all of these routines
depend upon the gPconfigInfo->AllowWraparoundMap setting hence a prior call
to ReadHostData() must have been performed.

       Int32 DistanceSquared(Int16 pX1, Int16 pY1, Int16 pX2, Int16 pY2)
This functions returns the squared distance between the points (pX1,pY1)
and (pX2,pY2). The wraparound region is taken into account. For example, if
the wraparound region is the usual square universe (1000,1000)-(3000,3000)
then DistanceSquared(1001,1001,2999,2999) is 8. If the AllowWraparoundMap
config setting is False, then this routine would return 7,984,008.

       double Distance(Int16 pX1, Int16 pY1, Int16 pX2, Int16 pY2)
This function simply returns the square root of DistanceSquared() as a
floating point quantity.

       Boolean IsDistanceLTRadius(Int16 pX1, Int16 pY1,
                                    Int16 pX2, Int16 pY2, Uns32 pRadius)
This function can be used to test whether two objects are within a certain
distance of each other without the floating-point overhead of the
Distance() function. The function returns True if the distance between
points (pX1,pY1) and (pX2,pY2) is less than or equal to the value of
'pRadius'. No floating point math is used. Once again, the wraparound map
is taken into account.

       Int16 WrapMapX(Int16 pX)
This function returns the wrapped value of the X-coordinate given by 'pX'.
For example, if the wraparound region is the usual square universe
(1000,1000)-(3000,3000) then WrapMapX(3005) would return 1005. If 'pX' is
already in the wraparound region (or wraparound maps are not in effect),
then WrapMapX simply returns 'pX' itself.

       Int16 WrapMapY(Int16 pY)
This function returns the wrapped value of the Y-coordinate given by 'pY'.

       Int16 WrapDistX(Int16 pX)
This function return the wrapped value of the horizontal distance given by
'pX'. For example, if the wraparound region is the usual square universe
(1000,1000)-(3000,3000) then WrapDistX(2500) would return -500. In other
words, it is shorter to go 500 LY to the left than 2500 LY to the right on
this wraparound map.

       Int16 WrapDistY(Int16 pY)
This function returns the wrapped value of the vertical distance given by
'pY'.

       Boolean IsPointOnWrapMap(Int16 pX, Int16 pY)
This function returns True if the point (pX,pY) is inside the wraparound
region, or False otherwise. This function always returns True if wraparound
maps are not enabled.

       void RewrapShipsAndMines(void)
This function iterates over all ships and minefields in the game and
adjusts their position (if necessary) so that they lie inside the
wraparound region. This function may be useful if your program moves the
position of ships and/or mines to locations possibly outside the wraparound
region. Note that PHOST automatically calls an equivalent function any time
an external (AUXHOST) program returns control to PHOST.

